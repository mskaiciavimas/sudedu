<!DOCTYPE html>
<html lang="lt">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
	<title>sudedu - rašyba</title>
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
	<link rel="stylesheet" href="../main-nav-bar.css">
    <link rel="stylesheet" type="text/css" href="../index.css">
	<link id="questionsStyleSheet" rel="stylesheet" type="text/css" href="">
	<link rel="stylesheet" type="text/css" href="../summary.css">
	<link rel="stylesheet" href="../pet-game-pets.css">

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-96Q83PW8XY"></script>
	<script>
	//window.dataLayer = window.dataLayer || [];
	//function gtag(){dataLayer.push(arguments);}
	//gtag('js', new Date());

	//gtag('config', 'G-96Q83PW8XY');
	</script>	
	<script src="../refresh-token.js"></script>
		
	<style>
        * {
          -webkit-user-select: none;
          -webkit-tap-highlight-color: transparent;
          user-select: none;
          box-sizing: border-box;
          -webkit-user-drag: none;
          user-drag: none;
        }

      	html {
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: linear-gradient(to top, #ffbf9c, #ffbf92, #ffbf89, #ffbf7e, #ffc074);
            width: 100vw;
            height: 100svh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            margin: 0;
            font-family: 'SFpro', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .main-nav-mobile-btn {
            width: auto;
            height: auto;
        }

        .container {
            flex: 1;
            max-height: calc(100% - 80px - 16px - 16px);
			height: calc(100% - 80px - 16px - 16px);
            min-height: calc(100% - 80px - 16px - 16px);
            width: calc(100% - (2 * 16px));
            display: flex;
            justify-content: start;
            background: rgba(255, 255, 255, 0.08);
            margin: 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.1);
            flex-direction: column;
            padding: 20px;
        }

		.container.keyboard-open {
			max-height: 100%;
			min-height: 100%;
		}

	:root {
		--font-size: 26px; /* Set the base font size */
	}

	.field {
		padding: 10px 20px;
		counter-reset: div-counter;
	}

	span:focus,
	span:active {
		border: none;
		outline: none;
	}

	#field-for-text {
		width: 100%;
		background: rgba(255, 255, 255, 0.4);
		border: 1px solid rgba(255, 255, 255, 0.2);
		backdrop-filter: blur(10px);
		border-radius: 25px;
		display: flex;
		flex-direction: column;
		justify-content: start;
	}

	#field-for-text-outer {
		flex: 1 1 auto;
		width: 100%;
		display: flex;
		align-items: center;
		justify-content: center;
		position: relative;
		overflow-y: auto;
	}

	.field-for-text-outer-holder {
		flex: 1;
		height: 100%;
		flex-direction: column;
		overflow: hidden;
		background: rgba(255, 255, 255, 0.15);
		border: 1px solid rgba(255, 255, 255, 0.1);
		border-radius: 25px;
		padding: 15px;
		display: flex;
		justify-content: start;
		align-items: start;
		position: relative;
	}

	#increase-no-of-sentences,
	#decrease-no-of-sentences {
		background: transparent;
		border: none;
		font-size: 2rem;
		color: rgba(255, 255, 255, 0.4);
		cursor: pointer;
		padding: 0;
		font-weight: 800;
	}

	#decrease-no-of-sentences {
		margin-right: 2.5px;
	}

	.sakiniai {
		padding-top: 5px;
		padding-bottom: 5px;
		font-size: var(--font-size);
		color: #212529;
		counter-increment: div-counter;
		position: relative;
		margin-bottom: 10px;
		line-height: 1.5;
		white-space: pre-wrap;
	}

	.sakiniai::before {
		content: counter(div-counter) ". "; /* Display the number */
	}

	textarea {
		resize: none;          /* disable manual resize */
		overflow-x: auto;      /* allow horizontal scroll */
		overflow-y: hidden;    /* hide vertical scroll */
		white-space: nowrap;   /* prevent wrapping to next line */
		line-height: var(--input-size-full);
		padding: 0;  
		scrollbar-width: none;    /* Firefox */    
		outline: none;
		border: none;             
		border-bottom: 2px solid #212529;
		color: #212529; 
		min-width: 0.5ch;
		background: transparent;
		font-size: var(--font-size);  
		height: calc(var(--font-size) * 1.211538462);
		margin-bottom: calc(var(--font-size) / -3.75);
		text-align: center;
		font-family: 'SFpro', sans-serif;
	}

	.pulse {
	position: relative;
	border-radius: 25px;
	overflow: hidden;
	}

	.pulse::before {
	content: "";
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	border-radius: 25px;
	background: rgba(182, 200, 103, 0);
	animation: pulse 600ms ease-in-out forwards;
	z-index: -1;
	}

	@keyframes pulse {
	0% {
		background: rgba(182, 200, 103, 0);
	}
	50% {
		background: rgba(182, 200, 103, 0.6);
	}
	100% {
		background: rgba(182, 200, 103, 0);
	}
	}

	.pulse-wrong {
	position: relative;
	border-radius: 25px;
	overflow: hidden;
	}

	.pulse-wrong::before {
	content: "";
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	border-radius: 25px;
	background: rgba(182, 200, 103, 0);
	animation: pulse-wrong  600ms ease-in-out forwards;
	z-index: -1;
	}

	@keyframes pulse-wrong {
	0% {
		background: rgba(182, 200, 103, 0);
	}
	50% {
		background: rgba(213, 126, 126, 0.4);
	}
	100% {
		background: rgba(182, 200, 103, 0);
	}
	}

	input:disabled {
		user-select: none; /* Prevent text selection */
		pointer-events: none; /* Ensure the input is not interactable */
	}	

	.correct-answer {
		color: #32ac93;
		text-shadow: 0.5px 0.5px 0.5px rgba(0, 0, 0, 0.7);
		caret-color: black;
	}

	.wrong-answer {
		color: #D57E7C;
		text-shadow: 0.5px 0.5px 0.5px rgba(0, 0, 0, 0.7);
		caret-color: black;
	}

	@keyframes blink {
		0%, 50%, 100% { color: #D57E7C; }
		25%, 75% { color: #FFEE00; }
	}

	.current-focus-parent .wrong-answer {
		animation: blink 2s infinite;
	}
	.row {
		width: 100%;
	}

	.button-outer-holder {
		display: flex;
		justify-content: space-between;
		padding-top: 10px;
	}

	.check-next-question-row {
		display: flex;
		gap: 10px;
	}

	.check-help-show-answers-button-holder {
		display: flex;
		gap: 10px;
	}

	#stopButton,
	#check-answers,
	#next-question,
	#show-answers,
	.summary-button {
		position: relative;
		background: linear-gradient(135deg, #3288AC, #286D8A);
		border: none;
		/* border: 1px solid #286D8A; */
		color: #F5F5F7;
		display: flex;
		align-items: center;
		padding: 12px 18px 12px 18px;
		border-radius: 20px;
		cursor: pointer;
		font-size: 1rem;
		letter-spacing: 0.01em;
		transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
		margin: 0;
		justify-content: center;
		min-width: 10vw;
	}

	.summary-button {
		margin-top: 15px;
	}

	#stopButton::before,
	#check-answers::before,
	#next-question::before,
	#show-answers::before,
	.summary-button::before {
		content: '';
		position: absolute;
		inset: 0;
		background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 100%);
		border-radius: 20px;
		pointer-events: none;
		transition: background 0.3s ease;
	}

	#stopButton {
		width: 6vw;
		min-width: 75px;
		height: 42.5px;
		border-radius: 100px;
		font-size: 2rem;
	}

	#stopButton::after,
	#check-answers::after,
	#next-question::after,
	#show-answers::after,
	.summary-button::after {
		content: '';
		position: absolute;
		inset: 0;
		border-radius: 20px;
		padding: 1px;
		background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
		-webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
		-webkit-mask-composite: xor;
		mask-composite: exclude;
		pointer-events: none;
	}

	#stopButton:hover::before,
	#check-answers:hover::before,
	#next-question:hover::before,
	#show-answers:hover::before,
	.summary-button:hover::before {
		background: rgba(255, 255, 255, 0.15);
	}

	#stopButton:focus,
	#check-answers:focus,
	#next-question:focus,
	#show-answers:focus,
	.summary-button:focus,
	#stopButton:active,
	#check-answers:active,
	#next-question:active,
	#show-answers:active,
	.summary-button:active {
		outline: none;
	}

	#next-question {
		display: none;
	}

	.pagalba-span,
	.pagalba-span-perm {
		color: gray;
		font-size: calc(var(--font-size)*0.8);
	}

.reset-button-div {
  display: flex;
  justify-content: flex-end;
  z-index: 3;
}

.stop-button-div {
  display: flex;
  justify-content: flex-start;
  z-index: 3;
}

.reset-button:hover,
.reset-button:active,
.reset-button:focus {
  background-color: #32ac93;
  border-color: #32ac93;
  color: black;
}

.stop-button:hover,
.stop-button:active,
.stop-button:focus {
  background-color: #32ac93;
  border-color: #32ac93;
  color: black;
}

#restart-reset-button-row {
	display: flex;
	align-items: center;
	justify-content: center;
}

.col-2 {
	padding: 0;
}

.tracker-timer-holder {
	padding: 0 15px;
	margin-bottom: 10px;
}

.trackers-row {
	display: flex;
	flex-wrap: wrap;
}

.trackers-holder,
.timer-holder {
	display: flex;
	flex: 0 0 auto;
	white-space: nowrap;
	align-items: start;
}

.pet-on-walk-holder {
	flex: 1 1 auto;
	min-width: 0;
}

.timer-holder {
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: end;
	gap: 5px;
}

#mistake-tracker,
#answer-tracker,
#timer {
    margin: 0;
    font-weight: 600;
    font-size: 1.25rem;
}

#answer-tracker:not(:empty) {
    margin-bottom: 5px;
}

.help-toggle-holder {
	display: flex;
	align-items: center;
}

.switch {
	display: flex;
}

#help-toggle {
	height: 0 !important;
	width: 0 !important;
	visibility: hidden;
	margin: 0 !important;
}

#help-toggle + span {
	cursor: pointer;
	width: 96px;
	height: 30px;
	background: grey;
	display: inline-block;
	border-radius: 30px;
	position: relative;
	vertical-align: middle;
	transition: 0.3s;
}

#help-toggle + span:after {
	content: '';
	position: absolute;
	top: 3px;
	left: 3px;
	width: 24px;
	height: 24px;
	background: #F5F5F7;
	border-radius: 50%;
	transition: 0.3s;
}

#help-toggle:checked + span:after {
	left: calc(100% - 5px);
	transform: translateX(-100%);
}

.switch-text {
	color: #F5F5F7;
	padding-right: 7px;
}

#help-toggle:checked + span {
	background: linear-gradient(135deg, #3288AC, #286D8A);
	width: 60px;
}

#help-toggle:checked + .switch-slider .switch-text {
	display: none;
}

#help-toggle + .switch-slider {
	display: flex !important;
	justify-content: end;
	align-items: center;
}

#field-for-final-message {
    color: black;
    font-size: 4rem;
    text-align: center;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

#fireworks-div {
  position: absolute;
  top: 5%;
  right: 5%;
  max-height: 300px;
  width: 250px;
  z-index: 1000;
}

.grammar-view-selector {
	position: relative;
	border: none;
	border-radius: 4px;
	background-color: transparent;
	text-align: center;
	font-weight: bold;
	z-index: 10;
	pointer-events: auto;
	font-size: 1.25rem;
}

.material-symbols-rounded {
    font-size: 2rem;
    font-weight: 300;
}

#hidden-input {
	position: absolute;
	opacity: 0;
	pointer-events: none;
	width: 1px;
	height: 1px;
	z-index: -1;
}

.modern-popup {
	top: 190px;
}

@media (max-width: 767px) {
	.modern-popup {
		top: 170px;
	}

	#next-question,
	#show-answers {
		width: 20vw;
	}

	#check-answers{
		width: 20vw;
	}

	.container {
		width: 100%;
		max-height: calc(100% - 80px);
		min-height: calc(100% - 80px);
		margin: 0;
		background: transparent;
		border: none;
		border-radius: 0;
		padding: 15px;
	}

	:root {
        --font-size: 22px; /* Smaller font size for tablets */
    }

	#field-for-final-message {
		font-size: 3rem;
	}

	#fireworks-div {
    	width: 200px;
		bottom: -25%;
  	}
}

@media (max-width: 575px) {
	#check-answers,
	#show-answers,
	#next-question {
		width: 30vw;
	}
	:root {
        --font-size: 22px; /* Smaller font size for tablets */
    }

	#field-for-final-message {
		font-size: 2rem;
	}
	.stop-button {
		width: 4.25rem;
		height: 4.25rem;
	}

	.reset-button {
		width: 4.25rem;
		height: 4.25rem;
	}

	#fireworks-div {
    	width: 150px;
		bottom: 60%;
  	}

	.field-for-text-outer-holder {
		padding: 0;
		border: none;
	}

	#field-for-text {
		background: transparent;
    	border: none;
	}

	.grammar-view-selector {
		font-size: 1rem;
	}

	#sentence-number-selector {
		margin: 5px 0 0 20px;
	}

	#increase-no-of-sentences,
	#decrease-no-of-sentences {
		font-size: 1.75rem;
	}
}

	@media (min-device-width: 768px) and (max-device-width: 1200px) and (orientation: portrait)  {
		:root {
        	--font-size: 32px; /* Smaller font size for tablets */
    	}

		.container {
          width: 100%;
          max-height: calc(100% - 100px);
          min-height: calc(100% - 100px);
          margin: 0;
          background: transparent;
          border: none;
          border-radius: 0;
          padding: 30px;
      }
		
		.stop-button {
			height: 6rem;
			width: 6rem;
		}

		.reset-button {
			height: 6rem;
			width: 6rem;	
		}

		.material-symbols-rounded {
			font-size: 2.75rem;
		}

		#stopButton {
		  width: 10vw;
          min-width: 90px;
          height: 51.5px;
          border-radius: 100px;
          font-size: 2rem;
		}

		.summary-button {
			font-size: 1.5rem;
		}

		.question-submit-button {
			font-size: 1.5rem;
		}

		h3 {
			font-size: 2rem;
		}

		#mistake-tracker,
		#answer-tracker,
		#timer {
          font-size: 1.5rem;
        }

		#check-answers,
		#next-question {
			font-size: 1.5rem;
			width: 25vw;
		}

		table * {
			font-size: 1.5rem;
		}

		.grammar-view-selector {
			font-size: 1.5rem;
		}

		th,
		td {
			background-color: rgba(255, 255, 255, 0.2);
		}

		#help-toggle + span {
			width: 132px;
			height: 36px;
		}

		#help-toggle + span:after {
			content: '';
			position: absolute;
			top: 4px;
			left: 4px;
			width: 28px;
			height: 28px;
			background: #F5F5F7;
			border-radius: 50%;
			transition: 0.3s;
		}

		#help-toggle:checked + span:after {
			left: calc(100% - 5px);
			transform: translateX(-100%);
		}

		.switch-text {
			color: #F5F5F7;
			padding-right: 10px;
			font-size: 1.45rem;
		}

		#help-toggle:checked + span {
			background: linear-gradient(135deg, #3288AC, #286D8A);
			width: 70px;
		}

	}
	</style>
</head>

<body>
	<div id="customConfirmModal" class="modal">
		<div class="modal-content">
			<p id="customModalText"></p>
			<div class="modal-buttons">
			<button id="customConfirmYes" class="btn-confirm">Taip</button>
			<button id="customConfirmNo" class="btn-cancel">Ne</button>
			</div>
		</div>
	</div>

	<div id="object-popup" class="object-popup-overlay" style="display:none;">
    <div class="object-popup-panel">
        <button class="object-popup-close">&times;</button>
        <div class="title-subtitle-inline-button-wrapper">
        <div class="object-popup-title-subtitle-wrapper">
        <div class="object-popup-title" id="object-popup-title"></div>
        <div class="object-popup-subtitle" id="object-popup-subtitle"></div>
        </div>
        </div>
        <div class="object-popup-content" id="object-popup-content">
        <!-- Dynamic content goes here -->
        </div>
    </div>
    </div>

	<nav class="main-navbar" id="mainNavbar">
		<div class="main-nav-container">
			<!-- Logo -->
			<a href="#" class="main-nav-logo">
				<div class="main-nav-logo-icon">
					<img id="sudedu-main-nav-bar-logo" src="../images/sudedu_logo.png" alt="sudEdu">
				</div>
			</a>

			<!-- Desktop Navigation -->
			<div class="main-nav-links invisible">
				<a class="main-nav-back-btn" id="desktopBackBtn">
					<span class="main-nav-back-icon">←</span>
					<div class="main-nav-back-text">
						<span class="main-nav-back-label">Grįžti</span>
						<span class="main-nav-back-title">Atgal</span>
					</div>
				</a>
			</div>

			<!-- Mobile Navigation -->
			<div class="main-nav-mobile-btn simplified">
				<a class="main-nav-back-btn" id="mobileBackBtn">
					<span class="main-nav-back-icon">←</span>
					<div class="main-nav-back-text">
						<span class="main-nav-back-label">Grįžti</span>
						<span class="main-nav-back-title">Atgal</span>
					</div>
				</a>
			</div>
		</div>
	</nav>

		<div class="container" style="display: flex; flex-direction: column; justify-content: space-between;">
				<div class="tracker-timer-holder">
		<div class="trackers-row">
			<div class="trackers-holder">
			<div class="trackers">
					<div>
						<h3 id="answer-tracker"></h3>
					</div>
					<div>
						<h3 id="mistake-tracker"></h3>
					</div>
			</div>
		</div>
		<div class="pet-on-walk-holder">
        	<div id="pet-on-walk"></div>
      	</div>
		<div class="timer-holder">
			<div id="timer"></div>

			<div class="help-toggle-holder">
				<label class="switch"><input type="checkbox" id="help-toggle" class="help-toggle" checked>
					<span class="switch-slider">
						<span class="switch-text switch-text-object">
							Pagalba
						</span>
					</span>
				</label>
			</div>
		</div>
		</div>
		</div>
		
		<div class="field-for-text-outer-holder">
			<div id="fireworks-div" class="image-container fireworks-div"></div>
			<div id="sentence-number-selector-holder">
				<div id="sentence-number-selector">
					<button id="decrease-no-of-sentences">−</button>
					<button id="increase-no-of-sentences">+</button>
				</div>
			</div>

			<div id="field-for-text-outer">
			<div id="field-for-text" style="position: relative;" class="field">
				<textarea id="hidden-input" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-current-id=""></textarea>
				<div id="field-for-sentences"></div>
				<div id="field-for-final-message"></div>
				<div id="restart-reset-button-row" class="row justify-content-center align-items-center" style="display: none;">
					<div class="col-12 submit-button-div d-flex justify-content-center align-items-center">
						<div id="reset-mistake-buttons" class="col-12 d-flex justify-content-center align-items-center">
							<div class="col-12 d-flex position-relative justify-content-center align-items-center">
								<div class="d-flex justify-content-end align-items-center summary-div">
									<button class="summary-button">Klaidos</button>
								</div>

							</div>
						</div>
					</div>
				</div>
			</div>
		</div>
		</div>

		<div class="button-outer-holder">

			<div class="stop-reset-button-div">
				<div class="stop-button-div">
					<button id="stopButton" class="stop-button"><span id="stop-button-span"
							class="material-symbols-rounded">close</span></button>
				</div>
			</div>

			<div class="check-help-show-answers-button-holder">
			<div class="row justify-content-center align-items-center">
				<div class="col-12 d-flex justify-content-end align-items-center">
			<button id="show-answers" class="" style="visibility: hidden;">Atsakymai</button>
			</div>
			</div>
			<div class="check-next-question-row">
			<div class="check-button-holder">
				<button id="check-answers" class="">Tikrinti</button>
				<button id="next-question" class="">Toliau</button>
			</div>
			</div>
			</div>
	</div>
	</div>
  	<script src="../main-nav-bar.js"></script>
	<script src="../parameter_dictionary.js"></script>
	<script src="../mental-arithmetic.js"></script>

	<script>

window.onload = function () {
    if (!localStorage.getItem('controller')) {
        window.location.href = "./";
    } else {
      controller = JSON.parse(localStorage.getItem('controller')) 
      if (controller.mode !== "lang" || controller.modeChoice2 !== "C50") {
		window.location.href = "./";
	} else {
		styleGrammarPage();
		initPetOnWalk();
	}
    }
  }

  controller = JSON.parse(localStorage.getItem('controller'))

window.answerTrackerElement = document.querySelector('#answer-tracker');
window.stopButtonSpanElement = document.querySelector('#stop-button-span');
window.resetMistakeButtonsElement = document.querySelector('#restart-reset-button-row');

window.stopQuestionsCloseActions = function () {
	controller.questionsStopped = true;
	clearInterval(timerInterval);
	stopButtonSpanElement.innerHTML = "refresh";
	document.getElementById('check-answers').disabled = true;
	document.getElementById('check-answers').style.display = "inline-block";
	document.getElementById('help-toggle').disabled = true;
	document.getElementById('next-question').style.display = "none";
	document.getElementById('show-answers').style.visibility = "hidden";
	document.querySelector('.help-toggle-holder').style.visibility = "hidden";

	document.querySelectorAll('.question-input').forEach(input => {
		input.disabled = true;
	});

	resetMistakeButtonsElement.style.display = "flex";
	localStorage.setItem("elapsedTime", timerDisplay.textContent);
	localStorage.setItem('controller', JSON.stringify(controller))
	formatFinalMessageForGrammar();
}

  let jsonFiles = [];

	// Define an array of URLs for the JSON files you want to fetch
	if (controller.classChoice === "C75") {
		jsonFiles = [
			'../databases/1_2_klase_gramatika_tekstai.json',
			'../databases/rasyba_suitable_words.json',
			'../databases/rasyba_suitable_words_patterns.json',
			'../databases/rasyba_suitable_words_linguistic_info.json'
		];
	} else if (controller.classChoice === "C76") {
		jsonFiles = [
			'../databases/3_4_klase_gramatika_tekstai.json',
			'../databases/rasyba_suitable_words.json',
			'../databases/rasyba_suitable_words_patterns.json',
			'../databases/rasyba_suitable_words_linguistic_info.json'
		];
	}
	Promise.all(jsonFiles.map(file => fetch(file).then(response => {
		if(!response.ok) {
			throw new Error(`Network error while fetching ${file}`);
		}
		return response.json();
	}).catch(error => {
		console.error('Error:', error);
		return null; // Return null or empty object in case of error
	}))).then(([textsForGrammar, suitableWords, suitableWordPatterns, wordLinguisticInfo]) => {

		const MIN_SENTENCE_CHARACTER_NUMBER_FOR_GRADES_0_to_1 = 45;
		const MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_0_to_1 = 3;
		const MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_2_to_5 = 4;
		const PRIORITIZED_TASK_CATEGORIES = ["C66-C76", "C66-C75", "C64"]
		let questionsToDisplay = 1;
		let sakiniai = [];
		let sakiniaiAndAtsakymai = [];
		window.atsakymai = {};
		let questionId = 1;
		window.mistakeRecords = {};
		let firstTimeChecking = true;
    	let currentAnswerAttempts = 0;
		const maximumQuestionFrequencyPerWord = controller.questionFrequency;
		let allowAdjacentEndlessWords;
		let allModified = false;
		if (controller.modeChoice5 === "C73") {
			allowAdjacentEndlessWords = false;
		} else if (controller.modeChoice5 === "C74") {
			allowAdjacentEndlessWords = true;
		}
		let allAnswersCorrect = false;
		const hiddenInput = document.getElementById('hidden-input');
		let userInPreSchool = userData && userData.knowledgeLvl === 0;
		let userInFirstGrade = userData && userData.knowledgeLvl === 1;
		let userInSecondGrade = userData && userData.knowledgeLvl === 2;
		let userInThirdGrade = userData && userData.knowledgeLvl === 3;
		let userInFourthGrade = userData && userData.knowledgeLvl === 4;
		let userInHigherGrade = userData && userData.knowledgeLvl === 5;

		const codedConditions = controller.modeChoice3

		let conditions = []
		let globalFormattedSentenceCounter = 0;
		const categories = new Map();
		const items = new Map();
		let currentSeed = controller.modeChoice8;

		let currentPassNumber = 0;

		const precomputedWordPatterns = {};

		for (const [word, wordsPattern] of Object.entries(suitableWords)) {
			precomputedWordPatterns[word] = {};

		for (const [conditionKey, patternIds] of Object.entries(wordsPattern)) {
			precomputedWordPatterns[word][conditionKey] = patternIds
			.filter(id => suitableWordPatterns[id])  // keep only valid patterns
			.map(id => suitableWordPatterns[id]);    // replace ID with actual pattern
			}
		}

/**
 * Seeded Random Number Generator (Mulberry32)
 */
class SeededRandom {
    constructor(seed) {
        this.state = typeof seed === 'string' ? parseSeed(seed) : seed;
    }
    
    next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
    
    nextInt(min, max) {
        return Math.floor(this.next() * (max - min)) + min;
    }
    
    shuffle(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i--) {
            const j = Math.floor(this.next() * (i + 1));
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }
    
    choice(array) {
        return array[Math.floor(this.next() * array.length)];
    }
    
    derive(suffix) {
        return new SeededRandom(this.state + parseSeed(String(suffix)));
    }
}


// ===== CATEGORY INDEX BUILDER =====

/**
 * Build index: category -> Set of textIds that contain words matching that category
 * This is FAST - just checks if words appear in text, doesn't process sentences
 */
function buildCategoryToTextsIndex(texts, suitableWords, conditionsSet) {
    const categoryIndex = new Map();
    
    conditionsSet.forEach(cat => categoryIndex.set(cat, new Set()));
    
    for (const textId in texts) {
        const textObj = texts[textId];
        const sections = textObj.text || {};
        const parts = [];
        
        if (sections.start) parts.push(...sections.start);
        if (sections.middle) parts.push(...sections.middle);
        if (sections.end) parts.push(...sections.end);
        
        const combined = parts.join(" ").toLowerCase();
        const textCategories = new Set();
        
        for (const word in suitableWords) {
            if (combined.includes(word)) {
                const wordConditions = suitableWords[word];
                for (const condKey in wordConditions) {
                    if (conditionsSet.has(condKey)) {
                        textCategories.add(condKey);
                    }
                }
            }
        }
        
        textCategories.forEach(cat => {
            categoryIndex.get(cat).add(textId);
        });
    }
    
    return categoryIndex;
}

function extractSentencesWithCoords(texts) {
    const results = [];
    const NO_SPLIT_MARKER = '\uE000';
    
    for (const textID in texts) {
        const textObj = texts[textID];
        const sections = textObj.text || {};
        const parts = [];
        
        if (sections.start) parts.push(...sections.start);
        if (sections.middle) parts.push(...sections.middle);
        if (sections.end) parts.push(...sections.end);
        
        if (parts.length === 0) continue;
        
        const combined = parts.join("").trim();
        if (!combined) continue;
        
        // Process the combined text to find sentence boundaries
        let currentPos = 0;
        let sentenceStart = 0;
        let sentenceNumber = 0; // Add sentence counter
        
        while (currentPos < combined.length) {
            // Check if we're at a potential sentence end
            const match = findSentenceEnd(combined, currentPos);
            
            if (match) {
                const endPos = match.index + match[0].length;
                
                // Check if this is followed by NO_SPLIT_MARKER
                if (combined.substring(endPos, endPos + NO_SPLIT_MARKER.length) !== NO_SPLIT_MARKER) {
                    // Extract the sentence (including the end markers)
                    const sentence = combined.substring(sentenceStart, endPos).trim();
                    if (sentence) {
                        results.push([sentence, [Number(textID), sentenceNumber]]);
                        sentenceNumber++; // Increment sentence counter
                    }
                    sentenceStart = endPos;
                    currentPos = endPos;
                    continue;
                } else {
                    // Skip the NO_SPLIT_MARKER and continue
                    currentPos = endPos + NO_SPLIT_MARKER.length;
                    continue;
                }
            }
            
            currentPos++;
        }
        
        // Add any remaining text as the last sentence
        if (sentenceStart < combined.length) {
            const remaining = combined.substring(sentenceStart).trim();
            if (remaining) {
                results.push([remaining, [Number(textID), sentenceNumber]]);
            }
        }
    }
    
    return results;
}

function findSentenceEnd(text, startPos) {
    const EOS_SYMBOLS = /[!\.?]/;
    const QUOTATION_MARKS = /["'`„“”«»]/; // Including Lithuanian quotation marks
    
    let i = startPos;
    let foundEos = false;
    let sequence = '';
    
    // Look for the pattern: any quotes + EOS symbols + any quotes
    while (i < text.length) {
        const char = text[i];
        
        if (char === ' ') {
            // Spaces are allowed between symbols
            sequence += char;
            i++;
            continue;
        }
        
        if (QUOTATION_MARKS.test(char)) {
            sequence += char;
            i++;
            continue;
        }
        
        if (EOS_SYMBOLS.test(char)) {
            sequence += char;
            foundEos = true;
            i++;
            continue;
        }
        
        // If we encounter a non-matching character, stop
        break;
    }
    
    // We have a valid sentence end if we found at least one EOS symbol
    // and the sequence is not empty
    if (foundEos && sequence.length > 0) {
        return {
            index: startPos,
            length: sequence.length,
            0: sequence
        };
    }
    
    return null;
}


function indexSentenceWords(sentence, coords) {
	const cleaned = sentence
		.replace(/\uE000/g, "")
        .replace(/[\p{P}\p{S}]+/gu, " ")
        .replace(/[\s\u00A0]+/g, " ")
        .trim();

    if (!cleaned) return [];

    const words = cleaned.split(" ");
    const result = [];

    words.forEach((word, absoluteIndex) => {
        const w = word.trim();
        if (!w) return;

        const newCoords = Array.isArray(coords) ? [...coords, absoluteIndex] : [absoluteIndex];

        result[absoluteIndex] = {
            word: w,
            coords: newCoords
        };
    });

    return result;
}

function processAdjacentEndlessWords(words, rng) {
    const result = [...words];
    let i = 0;
    
    const separators = new Set(['ir', 'ar', 'o', 'ne']);
    
    const isSeparator = (wordObj) => {
        const wordText = (wordObj.word || '').toLowerCase();
        return separators.has(wordText);
    };
    
    while (i < result.length) {
        if (isSeparator(result[i])) {
            i++;
            continue;
        }
        
        const patterns = result[i].suitablePatterns;
        if (!patterns) {
            i++;
            continue;
        }
        
        const hasC61 = 'C61' in patterns;
        const hasC62C63 = 'C62' in patterns || 'C63' in patterns;
        
        if (!hasC61 && !hasC62C63) {
            i++;
            continue;
        }
        
        const sequenceType = hasC61 ? 'C61' : 'C62C63';
        let sequenceIndices = [i];
        let j = i + 1;
        
        while (j < result.length) {
            if (isSeparator(result[j])) {
                j++;
                continue;
            }
            
            const nextPatterns = result[j].suitablePatterns;
            if (!nextPatterns) {
                break;
            }
            
            const nextHasC61 = 'C61' in nextPatterns;
            const nextHasC62C63 = 'C62' in nextPatterns || 'C63' in nextPatterns;
            
            const matches = (sequenceType === 'C61' && nextHasC61) || 
                            (sequenceType === 'C62C63' && nextHasC62C63);
            
            if (!matches) {
                break;
            }
            
            sequenceIndices.push(j);
            j++;
        }
        
        const sequenceLength = sequenceIndices.length;
        
        if (sequenceLength >= 2) {
            const keepOdd = rng.next() < 0.5;
            
            for (let k = 0; k < sequenceIndices.length; k++) {
                const shouldRemove = keepOdd ? (k % 2 === 1) : (k % 2 === 0);
                
                if (shouldRemove) {
                    const wordIdx = sequenceIndices[k];
                    const p = result[wordIdx].suitablePatterns;
                    delete p.C61;
                    delete p.C62;
                    delete p.C63;
                    if (Object.keys(p).length === 0) {
                        delete result[wordIdx].suitablePatterns;
                    }
                }
            }
            
            i = j;
        } else {
            i++;
        }
    }
    
    return result;
}

function reduceToQuestionQuota(words, questionQuota, rng, PRIORITIZED_TASK_CATEGORIES) {
    let usableWordsPerSentence = words.filter(w => w.suitablePatterns && Object.keys(w.suitablePatterns).length > 0).length;
    
    if (usableWordsPerSentence <= questionQuota) {
        return words;
    }
    
    const amountToRemove = usableWordsPerSentence - questionQuota;
    const wordsWithPrioritized = [];
    const wordsWithoutPrioritized = [];
    
    words.forEach((word, index) => {
        if (!word.suitablePatterns || Object.keys(word.suitablePatterns).length === 0) {
            return;
        }
        
        const hasPrioritizedCategory = PRIORITIZED_TASK_CATEGORIES.some(cat => cat in word.suitablePatterns);
        
        if (hasPrioritizedCategory) {
            wordsWithPrioritized.push(index);
        } else {
            wordsWithoutPrioritized.push(index);
        }
    });
    
    const shuffledNonPrioritized = rng.derive('non-priority').shuffle(wordsWithoutPrioritized);
    const shuffledPrioritized = rng.derive('priority').shuffle(wordsWithPrioritized);
    
    let removed = 0;
    const result = [...words];
    
    for (const index of shuffledNonPrioritized) {
        if (removed >= amountToRemove) break;
        delete result[index].suitablePatterns;
        removed++;
    }
    
    for (const index of shuffledPrioritized) {
        if (removed >= amountToRemove) break;
        delete result[index].suitablePatterns;
        removed++;
    }
    
    return result;
}

function pickRandomPatterns(words, rng) {
    const modifiedWords = words.map((word, index) => {
        if (!word.suitablePatterns || Object.keys(word.suitablePatterns).length === 0) {
            return null;  // ← Changed from {} to null
        }

        const patternTypes = Object.keys(word.suitablePatterns);
        const wordRng = rng.derive(`word-${index}`);
        const randomPatternType = patternTypes[Math.floor(wordRng.next() * patternTypes.length)];

        const sublists = word.suitablePatterns[randomPatternType];
        const randomSublist = sublists[Math.floor(wordRng.next() * sublists.length)];

        return {
            ...word,
            suitablePatterns: {
                [randomPatternType]: [randomSublist]
            }
        };
    }).filter(word => word !== null);  // ← Filter out nulls

    const categorySet = new Set();
    modifiedWords.forEach(word => {
        const keys = Object.keys(word.suitablePatterns || {});
        keys.forEach(k => categorySet.add(k));
    });

    const uniqueCategories = Array.from(categorySet);
    return [modifiedWords, uniqueCategories];
}


function addSentenceToCategorisedSentences(sentence, categoryList, sentenceAnswers, categories, items, globalFormattedSentenceCounter) {
    if (!Array.isArray(categoryList)) {
        console.log("Second argument must be an array of categories");
        return globalFormattedSentenceCounter;
    }

    const uniqueID = "s" + (globalFormattedSentenceCounter++);

    items.set(uniqueID, {
        sentence,
        categories: new Set(),
        sentenceAnswers: sentenceAnswers
    });

    for (const category of categoryList) {
        if (!categories.has(category)) categories.set(category, new Set());
        categories.get(category).add(uniqueID);
        items.get(uniqueID).categories.add(category);
    }

    return globalFormattedSentenceCounter;
}

function drainAllCategories(categories, items) {
    const finalSentences = [];

    while (true) {
        let progress = false;

        for (const [category, set] of categories) {
            if (set.size > 0) {
                const uniqueID = set.values().next().value;
                const entry = items.get(uniqueID);

                if (!entry) continue;

                const sentenceHTML = entry.sentence;
                const answersForSentence = entry.sentenceAnswers;

                // Remove from all categories
                for (const cat of entry.categories) {
                    categories.get(cat).delete(uniqueID);
                }
                items.delete(uniqueID);

                finalSentences.push({
                    sentenceHTML,
                    answers: answersForSentence
                });

                progress = true;
            }
        }

        if (!progress) break;
    }

    return finalSentences;
}


function processSentences(extractedSentences, sessionSeed, passNumber, config, state) {
    const {
        precomputedWordPatterns,
        conditionsSet,
        allowAdjacentEndlessWords,
        MIN_SENTENCE_CHARACTER_NUMBER_FOR_GRADES_0_to_1,
        MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_0_to_1,
        MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_2_to_5,
        PRIORITIZED_TASK_CATEGORIES,
        userInPreSchool,
        userInFirstGrade,
        userInSecondGrade,
        userInThirdGrade,
        userInFourthGrade,
        userInHigherGrade,
        generateHelpSpans
    } = config;

    const {
		categories,
		items,
		questionIdRef,
		counterRef
	} = state;

    const mainRng = new SeededRandom(sessionSeed);
    const textRng = mainRng.derive(`pass-${passNumber}`);
    
    const shuffledSentences = textRng.derive('sentence-order').shuffle(extractedSentences);
    
	let currentQuestionId = questionIdRef.value;
	let currentCounter = counterRef.value;
    
    for (const [sentence, coords] of shuffledSentences) {
        if (controller.classChoice === "C75" && (userInPreSchool || userInFirstGrade)) {
            if (sentence.length > MIN_SENTENCE_CHARACTER_NUMBER_FOR_GRADES_0_to_1) {
                continue;
            }
        }

        let indexedSentenceWords = indexSentenceWords(sentence, coords);

        if (((userInPreSchool || userInFirstGrade) && indexedSentenceWords.length < MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_0_to_1) ||
            ((userInSecondGrade || userInThirdGrade || userInFourthGrade || userInHigherGrade) && indexedSentenceWords.length < MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_2_to_5)) {
            continue;
        }

        let usableWordsInSentence = 0;

        for (let i = 0; i < indexedSentenceWords.length; i++) {
            const item = indexedSentenceWords[i];
            const word = item.word.toLowerCase();
            const matchedPatterns = {};
            const matchedConditionsHelpSpans = {};

            if (precomputedWordPatterns[word]) {
                const wordConditions = precomputedWordPatterns[word];

                let wordIsSuitable = false;
                for (const condKey in wordConditions) {
                    if (conditionsSet.has(condKey)) {
                        wordIsSuitable = true;
                        matchedConditionsHelpSpans[condKey] = generateHelpSpans(word, condKey);
                        matchedPatterns[condKey] = wordConditions[condKey];
                    }
                }

                if (wordIsSuitable) usableWordsInSentence += 1;
            }

            if (Object.keys(matchedPatterns).length > 0) {
                item.suitablePatterns = matchedPatterns;
                item.helpSpans = matchedConditionsHelpSpans;
            }
        }
        
        if (usableWordsInSentence === 0) continue;
        
        const sentenceRng = textRng.derive(`sentence-${coords.join('-')}`);
        
        if (!allowAdjacentEndlessWords) {
            indexedSentenceWords = processAdjacentEndlessWords(indexedSentenceWords, sentenceRng.derive('adjacent'));
        }

		const sentenceLength = indexedSentenceWords.length;
        const questionQuota = Math.floor(sentenceLength / maximumQuestionFrequencyPerWord);

        if (usableWordsInSentence > questionQuota) {
            indexedSentenceWords = reduceToQuestionQuota(indexedSentenceWords, questionQuota, sentenceRng.derive('quota'), PRIORITIZED_TASK_CATEGORIES);
        }

        const [modifiedWords, remainingCategories] = pickRandomPatterns(indexedSentenceWords, sentenceRng.derive('patterns'));

        if (remainingCategories.length === 0) continue;

        let sentenceDiv = sentence.replace(/\uE000/g, '');

        const sentenceAnswers = {};

		for (const item of modifiedWords) {
			if (item.suitablePatterns) {
				let selectedCategory = Object.keys(item.suitablePatterns)[0];
				
				// Add safety check
				if (!item.suitablePatterns[selectedCategory] || 
					!Array.isArray(item.suitablePatterns[selectedCategory]) ||
					item.suitablePatterns[selectedCategory].length === 0) {
					console.error('Invalid pattern structure for word:', item.word, item.suitablePatterns);
					continue;
				}
				
				let [startIdx, endIdx, answerLetters] = item.suitablePatterns[selectedCategory][0];

                const wordStart = item.word.slice(0, startIdx);
                const removedPart = item.word.slice(startIdx, endIdx); 
                const firstLetterCapitalized = removedPart[0] === removedPart[0].toUpperCase() && /[A-ZĄČĘĖĮŠŲŪŽ]/.test(removedPart[0]);
                
                if (firstLetterCapitalized) {
                    answerLetters = answerLetters.map(str => {
                        if (!str) return str;
                        return str[0].toUpperCase() + str.slice(1);
                    });
                }

                const wordEnd = item.word.slice(endIdx);

                let wordHTML = `<span class="question-word-span middle" style="display: inline; white-space: nowrap;">${wordStart}<textarea autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" maxlength="6" id="id-${currentQuestionId}" class="question-input middle"></textarea>${wordEnd}<span class="pagalba-div">${item.helpSpans[selectedCategory]}</span></span>`;
                
                sentenceAnswers[`id-${currentQuestionId}`] = {};
                sentenceAnswers[`id-${currentQuestionId}`]["klausimas"] = [wordStart, wordEnd];
                sentenceAnswers[`id-${currentQuestionId}`]["atsakymas"] = [answerLetters];
                sentenceAnswers[`id-${currentQuestionId}`]["kl-grupe"] = selectedCategory;
                sentenceAnswers[`id-${currentQuestionId}`]["zodzio-id"] = item.coords;
                currentQuestionId++;

                sentenceDiv = sentenceDiv.replace(item.word, wordHTML);
            }
        }

        currentCounter = addSentenceToCategorisedSentences(
            `<div class="sakiniai">${sentenceDiv}</div>`, 
            remainingCategories, 
            sentenceAnswers,
            categories,
            items,
            currentCounter
        );
    }
    
    // Update state
    questionIdRef.value = currentQuestionId;
    counterRef.value = currentCounter;
}


async function prepareSentences(sessionSeed, passNumber, targetFormattedSentences, config, state) {
    const {
        textsForGrammar,
        suitableWords,
        suitableWordPatterns,
        codedConditions
    } = config;

    if (!(textsForGrammar && suitableWords && suitableWordPatterns)) return;

    const conditions = [];
    Object.entries(codedConditions).forEach(([key, value]) => {
        if (key === "C66") {
            if (controller.classChoice === "C75") {
                conditions.push("C66-C75");
            } else if (controller.classChoice === "C76") {
                conditions.push("C66-C76");
            }
        } else if (key === "C87") {
			if (userInPreSchool || userInFirstGrade) {
                conditions.push("C87-1");
            } else {
                conditions.push("C87-2");
            }
		} else {
            conditions.push(key);
        }
    });

    const conditionsSet = new Set(conditions);
    config.conditionsSet = conditionsSet;

    const mainRng = new SeededRandom(sessionSeed);
    const allTextIds = Object.keys(textsForGrammar);
    const shuffledTextIds = mainRng.derive(`text-selection-pass-${passNumber}`).shuffle(allTextIds);
    
    let processedTextCount = 0;
    const BATCH_SIZE = 50;
    
    while (state.sakiniaiAndAtsakymai.length < targetFormattedSentences && processedTextCount < shuffledTextIds.length) {
        const batchTextIds = shuffledTextIds.slice(processedTextCount, processedTextCount + BATCH_SIZE);
        const batchTexts = {};
        batchTextIds.forEach(id => {
            batchTexts[id] = textsForGrammar[id];
        });
        
        const extractedSentences = extractSentencesWithCoords(batchTexts);
        
        processSentences(extractedSentences, sessionSeed, passNumber, config, state);
        
        // Drain and add to sakiniaiAndAtsakymai
        const newSentences = drainAllCategories(state.categories, state.items);
        state.sakiniaiAndAtsakymai.push(...newSentences);
        
        processedTextCount += BATCH_SIZE;
        
        if (processedTextCount >= shuffledTextIds.length) {
            console.log(`Processed all ${shuffledTextIds.length} texts, got ${state.sakiniaiAndAtsakymai.length} formatted sentences`);
            break;
        }
    }
    
    console.log(`Generated ${state.sakiniaiAndAtsakymai.length} formatted sentences from ${processedTextCount} texts`);
}

async function prepareSentencesWrapper(sessionSeed, passNumber = 0, targetFormattedSentences = 500) {
    const config = {
        textsForGrammar,
        suitableWords,
        suitableWordPatterns,
        codedConditions,
        precomputedWordPatterns,
        conditionsSet: null,
        allowAdjacentEndlessWords,
        MIN_SENTENCE_CHARACTER_NUMBER_FOR_GRADES_0_to_1,
        MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_0_to_1,
        MIN_SENTENCE_WORD_NUMBER_FOR_GRADES_2_to_5,
        PRIORITIZED_TASK_CATEGORIES,
        userInPreSchool,
        userInFirstGrade,
        userInSecondGrade,
        userInThirdGrade,
        userInFourthGrade,
        userInHigherGrade,
        generateHelpSpans
    };

    const state = {
        categories: categories,
        items: items,
        questionIdRef: { value: questionId },
        counterRef: { value: globalFormattedSentenceCounter },
        sakiniaiAndAtsakymai: sakiniaiAndAtsakymai
    };

    await prepareSentences(sessionSeed, passNumber, targetFormattedSentences, config, state);
    
    questionId = state.questionIdRef.value;
    globalFormattedSentenceCounter = state.counterRef.value;
}


		function generateHelpSpans (word, condKey) {
			let pagalbaText = "";
			let valuesToShow = [];
	
			if (condKey === "C62" || condKey === "C63" || condKey === "C65") {
			const pagalbaIndex = {
				"vns": "vns.",
				"dgs": "dgs.",
				"1-a": "Ia.",
				"2-a": "IIa.",
				"3-a": "IIIa.",
				"es-l": "es.l.",
				"b-k-l": "būt.k.l.",
				"b-d-l": "būt.d.l.",
				"būs-l": "būs.l.",
				"vyr-g": "vyr.g.",
				"mot-g": "mot.g.",
				"prv": "prv.",
			};


			if (wordLinguisticInfo[word].includes("vks")) {
				if (wordLinguisticInfo[word].includes("3-a")) {
					valuesToCheck = ["es-l", "b-k-l", "b-d-l", "būs-l", "3-a"];
				} else {
					valuesToCheck = ["es-l", "b-k-l", "b-d-l", "būs-l", "vns", "dgs", "1-a", "2-a", "3-a"];
				}
					valuesToCheck.forEach(value => {
							if (wordLinguisticInfo[word].includes(value)) {  // If wordInfo has the specific value set to true
									valuesToShow.push(pagalbaIndex[value]);
							}
					});
			} else if (wordLinguisticInfo[word].includes("dkt") || wordLinguisticInfo[word].includes("bdv")) {
					valuesToCheck = ["vns", "dgs"];
					if (wordLinguisticInfo[word].includes("vns") && wordLinguisticInfo[word].includes("dgs")) {
						valuesToShow.push(`${pagalbaIndex["vns"]}?, ${pagalbaIndex["dgs"]}?`);
					} else if (wordLinguisticInfo[word].includes("vns")) {
						valuesToShow.push(pagalbaIndex["vns"]);
					} else if (wordLinguisticInfo[word].includes("dgs")) {
						valuesToShow.push(pagalbaIndex["dgs"]);
					}

					if (wordLinguisticInfo[word].includes("prv")) {
						valuesToShow.push("prv.?");
					}

					if (wordLinguisticInfo[word].includes("vyr-g") && wordLinguisticInfo[word].includes("mot-g")) {
						valuesToShow.push(`${pagalbaIndex["vyr-g"]}?, ${pagalbaIndex["mot-g"]}?`);
					} else if (wordLinguisticInfo[word].includes("vyr-g")) {
						valuesToShow.push(pagalbaIndex["vyr-g"]);
					} else if (wordLinguisticInfo[word].includes("mot-g")) {
						valuesToShow.push(pagalbaIndex["mot-g"]);
					}
			}
			} else if (condKey === "C85" || condKey === "C86" || condKey === "C87") {
				if (wordLinguisticInfo[word].includes("vns") && wordLinguisticInfo[word].includes("dgs") && wordLinguisticInfo[word].includes("g") && wordLinguisticInfo[word].includes("k")) {
					valuesToShow.push("ką vieną? | ko daug?")
				} else if (wordLinguisticInfo[word].includes('g')) {
					valuesToShow.push("ką vieną?")
				} else if (wordLinguisticInfo[word].includes('k')) {
					valuesToShow.push("ko daug?")
				} else if (wordLinguisticInfo[word].includes('vt')) {
					valuesToShow.push("kur?")
				}
			}

			if (valuesToShow.length > 0) {
				const valuesToShowString = valuesToShow.join(', ');
				const helpSpanHTML = `<span class="pagalba-span">(${valuesToShowString})</span>`
				return helpSpanHTML
			} else {
				return ``
			}
		}

		if (controller.modeChoice4 === "C40") {
			answerTrackerElement.innerHTML =`Atlikta: ${controller.randomSelection[2] || 0}/${controller.questionNumber}`;
		}

		// Function to get allowed matching categories

		function preserveFocusDuring(fn) {
		const previouslyFocused = document.activeElement !== document.body ? document.activeElement : null;
		fn(); // run your main logic
		if (previouslyFocused) {
			previouslyFocused.focus(); // restore focus
		} else {
			document.activeElement.blur(); // ensure nothing is focused
		}
		}

		function adjustFieldForTexts() {
			const outer = document.getElementById("field-for-text-outer");
			const inner = document.getElementById("field-for-text");

			if (!outer || !inner) return;

			// Compare heights
			const innerHeight = inner.scrollHeight;
			const outerHeight = outer.clientHeight;

			if (innerHeight > outerHeight) {
				outer.style.alignItems = "flex-start";
			} else {
				outer.style.alignItems = "center";
			}
		}

		document.getElementById('increase-no-of-sentences').addEventListener('click', () => {
		preserveFocusDuring(async () => {
			const inputs = Array.from(document.querySelectorAll('.question-input'));
			const anyNotEmpty = inputs.some(input => input.value.trim() !== '');
			if (!firstTimeChecking || anyNotEmpty) {
				messageToTheUser("Sakinių skaičių galima pakeisti tik prieš įrašant raides.");
				return;
			}
			if (questionsToDisplay < 5) {
				questionsToDisplay++;
				await displaySentences();
				document.getElementById('help-toggle').checked = false;
				adjustFieldForTexts();
				helpToggle();
			} else {
				focusFirstInput();
			}
		});
		});

		document.getElementById('decrease-no-of-sentences').addEventListener('click', () => {
		preserveFocusDuring(async () => {
			const inputs = Array.from(document.querySelectorAll('.question-input'));
			const anyNotEmpty = inputs.some(input => input.value.trim() !== '');
			if (!firstTimeChecking || anyNotEmpty) {
				messageToTheUser("Sakinių skaičių galima pakeisti tik prieš įrašant raides.");
				return;
			}
			if (questionsToDisplay > 1) {
				questionsToDisplay--;
				await displaySentences();
				document.getElementById('help-toggle').checked = false;
				adjustFieldForTexts();
				helpToggle();
			} else {
				focusFirstInput();
			}
		});
		});

async function restoresakiniaiAndAtsakymaiPosition(targetSentenceHTML, maxAttempts = 3) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const idx = sakiniaiAndAtsakymai.findIndex(
            entry => entry.sentenceHTML === targetSentenceHTML
        );

        if (idx !== -1) {
            // Found it! Restore position
            sakiniaiAndAtsakymai = sakiniaiAndAtsakymai.slice(idx);
            console.log(`Found sentence on attempt ${attempt + 1}, restored position`);
            return true;
        }
        
        // Not found, try next pass
        if (attempt < maxAttempts - 1) {
            console.log(`Sentence not found in pass ${controller.passNumber}, trying pass ${controller.passNumber + 1}`);
            controller.passNumber = (controller.passNumber || 0) + 1;
            
            // Clear and regenerate
            sakiniaiAndAtsakymai = [];
            categories.clear();
            items.clear();
            globalFormattedSentenceCounter = 0;
            
            await prepareSentencesWrapper(controller.sessionSeed, controller.passNumber);
        }
    }
    
    // After max attempts, start fresh
    console.log(`Could not find sentence after ${maxAttempts} attempts, starting fresh`);
    controller.randomSelection[0] = [];
    controller.randomSelection[1] = {};
    controller.passNumber = (controller.passNumber || 0) + 1;
    localStorage.setItem("controller", JSON.stringify(controller));
    
    sakiniaiAndAtsakymai = [];
    categories.clear();
    items.clear();
    globalFormattedSentenceCounter = 0;
    
    await prepareSentencesWrapper(controller.sessionSeed, controller.passNumber);
    return false;
}

async function displaySentences() {
    styleGrammarPage();
    document.getElementById('help-toggle').checked = true;
    allAnswersCorrect = false;
    currentAnswerAttempts = 0;
    document.getElementById('check-answers').disabled = false;
    document.getElementById('show-answers').style.visibility = "hidden";
    document.getElementById('field-for-final-message').innerHTML = '';

    sakiniai = [];
    atsakymai = {};

	const totalAvailable = sakiniaiAndAtsakymai.length + (controller.randomSelection[0]?.length || 0);


    // Check if we need to generate more sentences
	if (totalAvailable < 5) {
		// Generate seed if first time
		if (!currentSeed) {
			currentSeed = generateSessionSeed();
			currentPassNumber = 0;
		}
		
		// CLEAR EVERYTHING including controller.randomSelection
		sakiniaiAndAtsakymai = [];
		categories.clear();
		items.clear();
		globalFormattedSentenceCounter = 0;
		questionId = 1;
		
		// ← ADD THESE LINES:
		controller.randomSelection[0] = [];
		controller.randomSelection[1] = {};
		// Don't reset [2] as it tracks completed questions
		
		console.log(`Generating pass ${currentPassNumber} with seed ${currentSeed}`);
		
		// Regenerate with current pass number
		await prepareSentencesWrapper(currentSeed, currentPassNumber);
		
		// Increment pass number for next time
		currentPassNumber++;
	}

    if (controller.modeChoice4 === "C40") {
        if (!controller.randomSelection[2]) {
            controller.randomSelection[2] = 0;
        }
        if ((controller.questionNumber - controller.randomSelection[2]) < questionsToDisplay) {
            questionsToDisplay = controller.questionNumber - controller.randomSelection[2];
        }
    }

    // Initialize randomSelection if needed
    if (!controller.randomSelection[0]) {
        controller.randomSelection[0] = [];
    }
    if (!controller.randomSelection[1]) {
        controller.randomSelection[1] = {};
    }

    // Always ensure we have 5 sentences in randomSelection
    while (controller.randomSelection[0].length < 5 && sakiniaiAndAtsakymai.length > 0) {
        let sentenceAddition = sakiniaiAndAtsakymai.shift();
        
        controller.randomSelection[0].push(sentenceAddition.sentenceHTML);
        Object.assign(controller.randomSelection[1], sentenceAddition.answers);
    }
    
    sakiniai = controller.randomSelection[0] || [];
    atsakymai = controller.randomSelection[1] || {};
    
    localStorage.setItem("controller", JSON.stringify(controller));

    // Check if we have sentences to display
    if (sakiniai.length === 0) {
        console.error("No sentences to display!");
        document.getElementById("field-for-sentences").innerHTML = '<p>Nepavyko sugeneruoti sakinių. Pabandykite dar kartą.</p>';
        return;
    }

    document.getElementById("field-for-sentences").innerHTML = sakiniai.slice(0, questionsToDisplay).join('');

    document.querySelectorAll('.question-input').forEach(input => {
        input.addEventListener('input', function () {
            this.value = this.value.replace(/[^a-zA-ZąčęėįšųūžĄČĘĖĮŠŲŪŽ\s]/g, '');
        });
    });
    
    document.querySelectorAll('input, textarea').forEach(input => {
        input.setAttribute('spellcheck', 'false');
        input.addEventListener('input', () => resizeInput(input));
        resizeInput(input);
    });

    focusFirstInput();

    document.querySelectorAll('.question-input').forEach(input => {
        input.addEventListener('focus', () => {
            if (input.classList.contains('wrong-answer')) {
                input.value = '';
                resizeInput(input);
            }
            input.classList.remove('wrong-answer');
        });
    });

    setupDynamicListeners();
}

		function toggleHelpButton() {
			const helpToggle = document.getElementById("help-toggle");
			if (helpToggle.checked) {
				helpToggle.checked = false;
			} else {
				helpToggle.checked = true;
			}
	
			const pagalbaSpans = document.querySelectorAll(".pagalba-span");

			let isAnySpanNonEmpty = Array.from(pagalbaSpans).some(span => span.innerHTML.trim() !== "");

			helpToggle.style.disabled = isAnySpanNonEmpty ? "visible" : "hidden";
		}


async function initiateTheProgram() {
    if (!controller.questionsStopped) {
        // Generate seed for first time
        if (!currentSeed) {
            currentSeed = generateSessionSeed();
            currentPassNumber = 0;
        }
        
        // Generate initial sentences
        await prepareSentencesWrapper(currentSeed, currentPassNumber);

        await displaySentences();
        toggleHelpButton();
        helpToggle();

        if (!controller.questionsStopped) {
            if (controller.modeChoice4 === "C39") {
                countDown();
            } else if (controller.modeChoice4 === "C40") {
                startTimer();
            }
        }
    } else {
        formatFinalMessageForGrammar();
    }
}

		initiateTheProgram();

		function resizeInput(inputElement) {
			// Create a temporary span element to measure the width of the input text
			const span = document.createElement('span');
			const style = window.getComputedStyle(inputElement);

			// Set the span to match the input's styling (same font, padding, etc.)
			span.style.font = style.font;
			span.style.padding = style.padding;
			span.style.margin = style.margin;
			span.style.whiteSpace = 'nowrap'; // Make sure the text does not wrap

			// Set the span's text to the input's current value
			span.textContent = inputElement.value || inputElement.placeholder;

			// Append the span to the document (it will be invisible)
			document.body.appendChild(span);

			// Get the width of the span and update the input width
			const width = span.getBoundingClientRect().width;

			// Remove the temporary span from the document
			document.body.removeChild(span);

				
			if (inputElement.value === '') {
				inputElement.style.width = `1.5ch`; // Dynamic width based on placeholder
			} else {
				inputElement.style.width = `${width}px`;
			}

			alignTextareaVertically(inputElement)
	}

function alignTextareaVertically(inputElement) {
    // Reset transform first
    inputElement.style.transform = 'translateY(0)';
    
    // Force reflow
    void inputElement.offsetHeight;
    
    const parent = inputElement.closest('.question-word-span');
    if (!parent) return;
    
    // Create reference span for baseline alignment
    const testSpan = document.createElement('span');
    testSpan.textContent = 'X';
    testSpan.style.visibility = 'hidden';
    testSpan.style.display = 'inline';
    parent.appendChild(testSpan);
    
    // Measure and align
    const testRect = testSpan.getBoundingClientRect();
    const textareaRect = inputElement.getBoundingClientRect();
    const offset = testRect.bottom - textareaRect.bottom;
    
    if (Math.abs(offset) > 0.5) {
        inputElement.style.transform = `translateY(${offset}px)`;
    }
    
    testSpan.remove();
}

// Function to set up listeners for all inputs
function setupDynamicListeners() {
	const inputs = document.querySelectorAll('.question-input');
	const checkAnswersButton = document.getElementById('check-answers');

	inputs.forEach(input => {
		// --- Define handlers once per input ---
		const handleInput = () => {
			const wrongInputs = document.querySelectorAll('.wrong-answer');
			allModified = !(wrongInputs && wrongInputs.length > 0);
		};

		const handleParentClick = (e) => {
			if (e.target !== input) {
				const container = document.querySelector('#field-for-text-outer');
				focusWithKeyboardAdjustment(input, container);
			}
		};

		const handleMouseDown = (e) => {
			if (document.activeElement !== input) {
				e.preventDefault();
				const container = document.querySelector('#field-for-text-outer');
				focusWithKeyboardAdjustment(input, container);
			}
		};

		const handleTouchStart = (e) => {
			if (document.activeElement !== input) {
				e.preventDefault();
				const container = document.querySelector('#field-for-text-outer');
				focusWithKeyboardAdjustment(input, container);
			}
		};

		// --- Remove old listeners if they exist ---
		input.removeEventListener('input', input._handleInput);
		input.removeEventListener('mousedown', input._handleMouseDown);
		input.removeEventListener('touchstart', input._handleTouchStart);
		if (input.parentElement) {
			input.parentElement.removeEventListener('click', input._handleParentClick);
		}

		// --- Attach new listeners ---
		input.addEventListener('input', handleInput);
		input.addEventListener('mousedown', handleMouseDown);
		input.addEventListener('touchstart', handleTouchStart, { passive: false });
		if (input.parentElement) {
			input.parentElement.addEventListener('click', handleParentClick);
		}

		// --- Store handlers for future cleanup ---
		input._handleInput = handleInput;
		input._handleMouseDown = handleMouseDown;
		input._handleTouchStart = handleTouchStart;
		input._handleParentClick = handleParentClick;
	});
}

function getOffsetTopWithinContainer(el, container) {
	let offset = 0;
	while (el && el !== container) {
		offset += el.offsetTop;
		el = el.offsetParent;
	}
	return offset;
}

function focusWithKeyboardAdjustment(element, container) {
	if (!element || !container) return;

	const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
		|| ('ontouchstart' in window)
		|| (navigator.maxTouchPoints > 0);

	element.focus({ preventScroll: true });

	function centerElement() {
		const elementTop = getOffsetTopWithinContainer(element, container);
		const targetScrollTop = elementTop - (container.clientHeight / 2) + (element.offsetHeight / 2);

		container.scrollTo({
			top: targetScrollTop,
			behavior: 'smooth'
		});
	}

	requestAnimationFrame(centerElement);
	if (isMobile) {
		setTimeout(centerElement, 300);
		setTimeout(centerElement, 500);
	}
}



function recordGrammarMistakes (inputId, userInput) {
	const wordInfo = controller.randomSelection[1][inputId]
	if (!mistakeRecords[inputId]) {
		mistakeRecords[inputId] = {};
		mistakeRecords[inputId] = {
			"mistakesCounter": 0,
			"wrongAnswer": [],
			"wordWithAnswer": [wordInfo["klausimas"][0], wordInfo["atsakymas"][0][0], wordInfo["klausimas"][1]],
			"wordGrammarType": wordInfo["kl-grupe"].split('-')[0],
			"wordId": wordInfo["zodzio-id"]
		};
	}
	mistakeRecords[inputId]["mistakesCounter"]+=1
	if (mistakeRecords[inputId]["wrongAnswer"].length < 3) {
		mistakeRecords[inputId]["wrongAnswer"].push(userInput);
	}
}

function checkAnswers() {
    const inputs = document.querySelectorAll('.question-input');
    const NumberOfQuestionsInRound = inputs.length;
    const nextQuestionButton = document.getElementById('next-question');
    const checkAnswersButton = document.getElementById('check-answers');
    let answersCorrect = true;
    let allFilled = true; // Check if all fields are filled

	focusFirstInput();

    inputs.forEach(input => {
        let inputValue = input.value.trim().toLowerCase();
        if (inputValue === "") {
            allFilled = false; // Mark as not all filled
            return;
        }
    });

	if (!allFilled) {
		messageToTheUser("Įrašyk visas raides!");
		return
	}

	if (!allModified) {
		messageToTheUser("Pataisyk visas klaidas!")
		return
	}

	inputs.forEach(input => {
		const inputId = input.id;
		let inputValue = input.value.trim();

		// Strip input value of spaces before comparing with the dictionary
		inputValue = inputValue.replace(/\s+/g, '');

		// Compare the stripped value with the corresponding value from atsakymai
		if (atsakymai[inputId] && atsakymai[inputId]["atsakymas"] && atsakymai[inputId]["atsakymas"].some(answerArray => {
			return answerArray.some(answer => inputValue === answer.replace(/\s+/g, ''));
		})) {
			input.classList.add('correct-answer');
			input.classList.remove('wrong-answer');
			input.disabled = true;
			if (firstTimeChecking) {
				controller.correctAnswersTracker++;
			}
		} else {
			input.classList.add('wrong-answer');
			input.classList.remove('correct-answer');
			answersCorrect = false;
			controller.mistakesTracker++;
			localStorage.setItem("controller", JSON.stringify(controller));
			recordGrammarMistakes(input.id, inputValue);
		}


		// Show "Next Question" button only if all answers are correct
		nextQuestionButton.style.display = answersCorrect ? "flex" : "none";
		checkAnswersButton.style.display = answersCorrect ? "none" : "flex";
	});

	if (firstTimeChecking) {
		controller.answeredQuestionTracker += NumberOfQuestionsInRound;
		document.getElementById('mistake-tracker').innerHTML = `Teisingai: ${controller.correctAnswersTracker}/${controller.answeredQuestionTracker}`;
		localStorage.setItem('controller', JSON.stringify(controller));
	}

	if (answersCorrect) {
		allAnswersCorrect = true;

		controller.randomSelection[0].splice(0, questionsToDisplay);

		if (controller.randomSelection[2] === undefined || controller.randomSelection[2] === null) {
			controller.randomSelection[2] = 0;
		}

		controller.randomSelection[2] = controller.randomSelection[2] + questionsToDisplay;

		if (controller.modeChoice4 === "C40") {
			answerTrackerElement.innerHTML = `Atlikta: ${controller.randomSelection[2]}/${controller.questionNumber}`;
		}

		localStorage.setItem("controller", JSON.stringify(controller));

		var container = document.querySelector('.field-for-text-outer-holder');
		container.classList.add('pulse')
		setTimeout(function() {
			container.classList.remove('pulse');
		}, 800);
	} else {
		currentAnswerAttempts += 1;
		allModified = false;

		var container = document.querySelector('.field-for-text-outer-holder');
		container.classList.add('pulse-wrong')
		setTimeout(function() {
			container.classList.remove('pulse-wrong');
		}, 800);

		const wrongInput = document.querySelector(".wrong-answer")
		const wrongInputParent = wrongInput.parentElement;
		focusCentered(wrongInputParent);
		document.querySelectorAll('.current-focus-parent').forEach(el => {
			el.classList.remove('current-focus-parent');
		});
		wrongInputParent.classList.add('current-focus-parent');

		setTimeout(() => {
			hiddenInput.focus({ preventScroll: true });
			hiddenInput.dataset.currentId = wrongInput.id;
		}, 400);
	}

	document.querySelectorAll('.question-word-span textarea').forEach(textarea => {
        alignTextareaVertically(textarea);
    });

	firstTimeChecking = false;

	if (currentAnswerAttempts >= 3) {
		if (!answersCorrect) {
			document.getElementById('show-answers').style.visibility = "visible";
		} else {
			document.getElementById('show-answers').style.visibility = "hidden";
		}
	}
}

function showAnswers() {
  const inputs = document.querySelectorAll('.question-input');
  
  // Iterate over each input field
  inputs.forEach(input => {
    const inputId = input.id;
    
    // Ensure that the answer exists in the atsakymai object
    if (atsakymai[inputId]) {
      // Set the value of the input field to the correct answer, stripping spaces
      input.value = atsakymai[inputId]["atsakymas"][0][0].replace(/\s+/g, '');
      resizeInput(input);
    }
  });

  allModified = true;
  checkAnswers();
}

function helpToggle() {
	const elements = document.querySelectorAll('.pagalba-span');
    
    // Loop through each element and toggle the display property
    elements.forEach(element => {
        if (element.style.display === 'none') {
            element.style.display = 'inline-block'; // Set display to flex if it's none
        } else {
            element.style.display = 'none'; // Set display to none if it's not none
        }
    });
	adjustFieldForTexts();
	focusFirstInput();
}


			async function nextQuestion() {
				if (controller.modeChoice4 === "C40") {
					if (controller.randomSelection[2] === controller.questionNumber) {
						localStorage.setItem("elapsedTime", timerDisplay.textContent);
						controller.taskCompleted = true;
						await formatFinalMessageForGrammar();
						localStorage.setItem('controller', JSON.stringify(controller));
					}
				}
				
				if (!controller.questionsStopped) {
					await displaySentences()
					toggleHelpButton();
					document.getElementById('check-answers').style.display = "flex"
					nextQuestionButton.style.display = "none";
					document.querySelectorAll('.pagalba-span').forEach(element => {
					element.style.display = 'none';
					});
					firstTimeChecking = true;
				}
			}

			async function stopQuestions() {
				if (stopButtonSpanElement.innerHTML === "close") {
					showCustomConfirm("Ar tikrai nori sustabdyti užduotį?", stopQuestionsCloseActions);
				} else if (stopButtonSpanElement.innerHTML === "refresh") {
					stopButtonSpanElement.innerHTML = "close";
					controller.questionsStopped = false;
					if (localStorage.getItem("startTime")) {
					localStorage.removeItem("startTime");
					};
					if (localStorage.getItem("remainingTime")) {
					localStorage.removeItem("remainingTime");
					};
					document.getElementById('check-answers').disabled = false;
					document.getElementById('help-toggle').disabled = false;

					document.getElementById('check-answers').style.display = "inline-block";
					document.getElementById('check-answers').style.visibility = "visible";
					document.querySelector('.help-toggle-holder').style.visibility = "visible";

					document.querySelectorAll('.question-input').forEach(input => {
						input.disabled = false;
					});

					window.mistakeRecords = {};

					document.getElementById('mistake-tracker').innerHTML = `Teisingai: 0/0`;
					controller.randomSelection[2] = 0;
					if (controller.modeChoice4 === "C40") {
						answerTrackerElement.innerHTML = `Atlikta: ${controller.randomSelection[2]}/${controller.questionNumber}`;
					}
					firstTimeChecking = true;
					controller.randomSelection = [];
					controller.currentMistakes = [];
					controller.mistakesTracker = 0;
					controller.answeredQuestionTracker = 0;
					controller.correctAnswersTracker = 0;
					atsakymai = {};
					questionId = 1;
					resetMistakeButtonsElement.style.display = "none";

					controller.taskCompleted = false;
	    			controller.taskRecorded = false;

					restartPetOnWalkActions();

					localStorage.setItem('controller', JSON.stringify(controller));
					await initiateTheProgram();
					
					setTimeout(() => {
						adjustFieldForTexts();
					}, 100);
				}
			}

			function focusFirstInput() {
				const inputs = document.querySelectorAll('.question-input');
				for (const input of inputs) {
					if (input.value.trim() === '') {
						input.focus();
						return;
					}
				}
				hiddenInput.focus({ preventScroll: true });
			}

function enableEnterNavigation() {
    // Ensure the event listener is added only once
    document.removeEventListener('keydown', handleEnterKey);
    document.addEventListener('keydown', handleEnterKey);
	document.addEventListener('focusin', (event) => {
		const target = event.target;

		if (target.classList.contains('question-input')) {
			hiddenInput.dataset.currentId = "";
			hiddenInput.value = ''
		}
	});

	document.addEventListener('click', (event) => {
		if (!event.isTrusted) return;
		hiddenInput.dataset.currentId = "";
		hiddenInput.value = ''
		document.querySelectorAll('.current-focus-parent').forEach(el => {
			el.classList.remove('current-focus-parent');
		});
	});

	document.addEventListener('touchstart', (event) => {
		if (!event.isTrusted) return;
		hiddenInput.dataset.currentId = "";
		hiddenInput.value = ''
		document.querySelectorAll('.current-focus-parent').forEach(el => {
			el.classList.remove('current-focus-parent');
		});
	});
	
	hiddenInput.addEventListener('input', handleHiddenInputChange);
}

function handleEnterKey(event) {
    const letterPattern = /^[a-zA-ZąčęėįšųūžĄČĘĖĮŠŲŪŽ]$/;
    const inputs = Array.from(document.querySelectorAll('.question-input'));
    const wrongInput = inputs.find(input => input.classList.contains('wrong-answer'));

    const checkAnswersButton = document.getElementById('check-answers');
    const nextQuestionBtn = document.getElementById('next-question');

    // Handle letter keys (desktop only)
    if (letterPattern.test(event.key) && wrongInput && hiddenInput.dataset.currentId === wrongInput.id) {
        event.preventDefault();
        
        if (document.activeElement !== wrongInput) {
            hiddenInput.blur();
            wrongInput.focus();
        }
        
        wrongInput.value += event.key;
        wrongInput.dispatchEvent(new Event('input', { bubbles: true }));
        resizeInput(wrongInput);
        return;
    }

    // Handle Enter key only
    if (event.key !== 'Enter') return;
    event.preventDefault();

    if (!inputs.length) return;

    // Handle wrong answers
    if (wrongInput) {
        const parentDiv = wrongInput.parentElement;

        if (hiddenInput.dataset.currentId === wrongInput.id) {
            focusCentered(wrongInput);
        } else {
            focusCentered(parentDiv);
			document.querySelectorAll('.current-focus-parent').forEach(el => {
				el.classList.remove('current-focus-parent');
			});
			parentDiv.classList.add('current-focus-parent');
            setTimeout(() => {
				hiddenInput.focus({ preventScroll: true });
				hiddenInput.dataset.currentId = wrongInput.id;
			}, 400);
        }
        return;
    }

    // Focus first empty input if exists
    const emptyInput = inputs.find(input => !input.value.trim());
    if (emptyInput) {
        focusCentered(emptyInput);
        return;
    }

    // Check if all inputs are correct
    const allCorrect = inputs.every(input => input.classList.contains('correct-answer'));

    if (allCorrect) {
        nextQuestion();
    } else {
         checkAnswers();
    }
}


function handleHiddenInputChange(event) {
    const inputs = Array.from(document.querySelectorAll('.question-input'));
    const wrongInput = inputs.find(input => input.classList.contains('wrong-answer'));
    
    if (wrongInput && hiddenInput.dataset.currentId === wrongInput.id) {
        const newValue = hiddenInput.value;
        
        if (newValue) {
            // Transfer the input to wrong input
			wrongInput.focus();
            wrongInput.value += newValue;
            wrongInput.dispatchEvent(new Event('input', { bubbles: true }));
            resizeInput(wrongInput);
            
            // Clear hidden input
            hiddenInput.value = '';
        }
    }
}


function focusCentered(element) {
	if (!element) return;

	const container = document.querySelector('#field-for-text-outer');
	if (!container) return;

	// Detect if mobile device
	const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
	                ('ontouchstart' in window) ||
	                (navigator.maxTouchPoints > 0);

	// Determine if we're focusing a textarea or its parent
	const isTextarea = element.tagName.toLowerCase() === 'textarea';
	
	// Focus behavior: textareas focus without scroll
	if (isTextarea) {
		element.focus({ preventScroll: true });
	} else {
		// If focusing a parent div, position hidden input at where the element will be after scroll
		const rect = element.getBoundingClientRect();
		const containerRect = container.getBoundingClientRect();
		const targetScrollTop = container.scrollTop + rect.top - containerRect.top - (container.clientHeight / 2) + (element.offsetHeight / 2);
		
		// Position hidden input at the center of viewport (where element will be after scroll)
		hiddenInput.style.top = (targetScrollTop + container.clientHeight / 2) + 'px';
		hiddenInput.style.left = '50%';
	}

	// Function to perform the scroll
	function performScroll() {
		// Get fresh measurements
		const rect = element.getBoundingClientRect();
		const containerRect = container.getBoundingClientRect();

		// Current scroll position plus element offset within container
		const targetScrollTop = container.scrollTop + rect.top - containerRect.top - (container.clientHeight / 2) + (element.offsetHeight / 2);

		// Always try smooth scroll first
		const supportsSmooth = 'scrollBehavior' in document.documentElement.style;
		
		if (supportsSmooth) {
			container.scrollTo({
				top: targetScrollTop,
				behavior: 'smooth'
			});
		} else {
			// Fallback: instant scroll if smooth not supported
			container.scrollTop = targetScrollTop;
		}
	}

	// Use requestAnimationFrame to ensure layout is updated before scrolling
	requestAnimationFrame(() => {
		performScroll();
		
		// On mobile, perform a second scroll after keyboard settles
		if (isMobile && isTextarea) {
			setTimeout(performScroll, 100);
		}
	});
}

// Call the function after rendering the inputs and button
enableEnterNavigation();

// Add event listener to the button
nextQuestionButton = document.getElementById('next-question')

document.getElementById('check-answers').addEventListener('click', checkAnswers);
document.getElementById('next-question').addEventListener('click', nextQuestion);
document.getElementById('show-answers').addEventListener('click', showAnswers);
document.getElementById('help-toggle').addEventListener('change', helpToggle);

const stopButtonElement = document.querySelector('.stop-button');
stopButtonElement.addEventListener("click", stopQuestions)

if (controller.questionsStopped) {
	if (localStorage.getItem("elapsedTime") !== null) {
		timerDisplay.textContent = localStorage.getItem("elapsedTime");
	} else {
		timerDisplay.textContent = "00:00:00";
	}
}

document.getElementById('mistake-tracker').innerHTML = `Teisingai: ${controller.correctAnswersTracker}/${controller.answeredQuestionTracker}`;

const mistakesButtonElement = document.querySelector('.summary-button');
mistakesButtonElement.addEventListener("click", () => {
	localStorage.setItem("elapsedTime", timerDisplay.textContent);
})
mistakesButtonElement.addEventListener("click", displaylatestMistakes);


function displaylatestMistakes() {
	document.querySelector("#restart-reset-button-row").style.display = "none"
	document.querySelector("#field-for-final-message").style.display = "flex";
	document.querySelector("#field-for-final-message").style.height = "100%";
	document.querySelector("#field-for-final-message").innerHTML = `
		<div id="frequent-mistakes-container" style="flex-direction: column; justify-content: space-between;">
			<div id="mistakes-summary-math">
			<div class="summary-table-frequent-mistakes-outer-div">
				<div id="summary-table-outer-div" class="">
					<div class="table-container" id="table-container-math">
						<div id="summary-table-frequent-mistakes"></div>
					</div>
				</div>
				</div>
			</div>
		</div>
	`
	
	generateSummaryTable('current', null, null, "summary-table-frequent-mistakes");

	if (
		document.querySelector("#summary-table-frequent-mistakes") &&
		document.querySelector("#summary-table-frequent-mistakes").innerHTML === "Klaidų nėra!"
	) {
		document.getElementById('field-for-final-message').style.height = "auto";
		document.querySelector(".table-container").style.justifyContent = "center";
	} else {
		document.getElementById('field-for-final-message').style.height = "100%";
		document.querySelector(".table-container").style.justifyContent = "start";
	}

	document.querySelector("#restart-reset-button-row").style.display = "none";
}


function detectMobileKeyboard() {
  // Check if device is mobile
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0);
  
  if (!isMobile) {
    return; // Don't set up listeners on desktop
  }
  
  let isKeyboardOpen = false;
  let lastHeight = window.innerHeight;
  let lastVisualHeight = window.visualViewport?.height || window.innerHeight;
  let resizeTimeout = null;
  
  // Threshold: 150px works well for most devices
  // Mobile keyboards are typically 250-350px tall
  const THRESHOLD = 150;
  
  function handleVisualViewportResize() {
    clearTimeout(resizeTimeout);
    
    resizeTimeout = setTimeout(() => {
      const currentHeight = window.visualViewport.height;
      const heightDiff = lastVisualHeight - currentHeight;
      
      // Keyboard likely opened
      if (heightDiff > THRESHOLD && !isKeyboardOpen) {
        isKeyboardOpen = true;
        if (typeof onShow === 'function') {
          onShow({
            keyboardHeight: heightDiff,
            viewportHeight: currentHeight,
            method: 'visualViewport'
          });
        }
      }
      // Keyboard likely closed
      else if (heightDiff < -THRESHOLD && isKeyboardOpen) {
        isKeyboardOpen = false;
        if (typeof onHide === 'function') {
          onHide({
            viewportHeight: currentHeight,
            method: 'visualViewport'
          });
        }
      }
      
      lastVisualHeight = currentHeight;
    }, 100);
  }
  
  function handleWindowResize() {
    clearTimeout(resizeTimeout);
    
    resizeTimeout = setTimeout(() => {
      const currentHeight = window.innerHeight;
      const heightDiff = lastHeight - currentHeight;
      
      // Only trigger if Visual Viewport API is not available
      if (!window.visualViewport) {
        if (heightDiff > THRESHOLD && !isKeyboardOpen) {
          isKeyboardOpen = true;
          if (typeof onShow === 'function') {
            onShow({
              keyboardHeight: heightDiff,
              viewportHeight: currentHeight,
              method: 'windowResize'
            });
          }
        }
        else if (heightDiff < -THRESHOLD && isKeyboardOpen) {
          isKeyboardOpen = false;
          if (typeof onHide === 'function') {
            onHide({
              viewportHeight: currentHeight,
              method: 'windowResize'
            });
          }
        }
      }
      
      lastHeight = currentHeight;
    }, 100);
  }
  
  function detectKeyboardByViewport() {
    if (window.visualViewport) {
      const heightDiff = window.innerHeight - window.visualViewport.height;
      return heightDiff > THRESHOLD;
    }
    return false;
  }
  
  function handleFocusIn(e) {
    const target = e.target;
    const isInput = target.tagName === 'INPUT' || 
                    target.tagName === 'TEXTAREA' || 
                    target.isContentEditable;
    
    if (isInput) {
      // Give keyboard time to appear
      setTimeout(() => {
        if (!isKeyboardOpen && detectKeyboardByViewport()) {
          isKeyboardOpen = true;
          if (typeof onShow === 'function') {
            onShow({
              method: 'focusIn',
              element: target
            });
          }
        }
      }, 300);
    }
  }
  
  function handleFocusOut(e) {
    const target = e.target;
    const isInput = target.tagName === 'INPUT' || 
                    target.tagName === 'TEXTAREA' || 
                    target.isContentEditable;
    
    if (isInput) {
      // Give keyboard time to disappear
      setTimeout(() => {
        // Check if another input was focused
        const activeEl = document.activeElement;
        const stillFocused = activeEl.tagName === 'INPUT' || 
                           activeEl.tagName === 'TEXTAREA' || 
                           activeEl.isContentEditable;
        
        if (!stillFocused && isKeyboardOpen && !detectKeyboardByViewport()) {
          isKeyboardOpen = false;
          if (typeof onHide === 'function') {
            onHide({
              method: 'focusOut',
              element: target
            });
          }
        }
      }, 300);
    }
  }
  
  function handleOrientationChange() {
    // Reset height references on orientation change
    setTimeout(() => {
      lastHeight = window.innerHeight;
      lastVisualHeight = window.visualViewport?.height || window.innerHeight;
      isKeyboardOpen = false;
    }, 500);
  }
  
  // Set up listeners
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', handleVisualViewportResize);
  }
  
  window.addEventListener('resize', handleWindowResize);
  document.addEventListener('focusin', handleFocusIn);
  document.addEventListener('focusout', handleFocusOut);
  
  if (window.screen?.orientation) {
    window.screen.orientation.addEventListener('change', handleOrientationChange);
  }
  
  // Return cleanup function
  return function cleanup() {
    if (window.visualViewport) {
      window.visualViewport.removeEventListener('resize', handleVisualViewportResize);
    }
    window.removeEventListener('resize', handleWindowResize);
    document.removeEventListener('focusin', handleFocusIn);
    document.removeEventListener('focusout', handleFocusOut);
    if (window.screen?.orientation) {
      window.screen.orientation.removeEventListener('change', handleOrientationChange);
    }
    clearTimeout(resizeTimeout);
  };
}

// Usage:
// 1. Define your callback functions globally or in accessible scope:
function onShow(info) {
	const navbar = document.querySelector('#mainNavbar');
	const container = document.querySelector('.container');
	container.classList.add('keyboard-open');
	navbar.classList.add('keyboard-open');
}

function onHide(info) {
  	const navbar = document.querySelector('#mainNavbar');
	const container = document.querySelector('.container');
	container.classList.remove('keyboard-open');
    navbar.classList.remove('keyboard-open');
}

// 2. Initialize the detector (only runs on mobile devices):
const cleanup = detectMobileKeyboard();

// 3. Optional: cleanup when needed
// if (cleanup) cleanup();


	}).catch(error => {
		console.error('Error in fetching multiple JSON files:', error);
	});

	</script>
</body>

</html>