<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SUDEDU - augintiniai</title>
    <link rel="stylesheet" type="text/css" href="../index.css">
    <link rel="stylesheet" href="../main-nav-bar.css">
    <link rel="stylesheet" href="../pet-game-pets.css">
    <link rel="stylesheet" href="../pet-game-items.css">
    <script src="../refresh-token.js"></script>
    <!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-96Q83PW8XY"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag() { dataLayer.push(arguments); }
		gtag('js', new Date());
		gtag('config', 'G-96Q83PW8XY');
	</script>

    <style>

      @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Regular.otf") format("opentype");
        font-weight: 400;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-RegularItalic.otf") format("opentype");
        font-weight: 400;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Light.otf") format("opentype");
        font-weight: 300;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-LightItalic.otf") format("opentype");
        font-weight: 300;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Semibold.otf") format("opentype");
        font-weight: 600;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-SemiboldItalic.otf") format("opentype");
        font-weight: 600;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Bold.otf") format("opentype");
        font-weight: 700;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-BoldItalic.otf") format("opentype");
        font-weight: 700;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Heavy.otf") format("opentype");
        font-weight: 800;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-HeavyItalic.otf") format("opentype");
        font-weight: 800;
        font-style: italic;
        }

        * {
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        *:not(#shop-container *):not(#pet-asset-container *):not(#furniture-container *):not(#taxes-container *) {
            box-sizing: border-box;
        }

        html {
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: linear-gradient(to top, #ffbf9c, #ffbf92, #ffbf89, #ffbf7e, #ffc074);
            width: 100vw;
            height: 100svh;
            overflow: hidden;
            user-select: none;         /* Standard */
            -webkit-user-select: none; /* Chrome, Safari, Edge */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE/older Edge */
        }

        body {
            margin: 0;
            font-family: 'SFpro', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* Chrome, Edge, Safari */
        ::-webkit-scrollbar {
        width: 12px;
        }

        ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);  /* translucent track */
        backdrop-filter: blur(6px);            /* frosted blur effect */
        border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.4);  /* semi-transparent thumb */
        backdrop-filter: blur(6px);
        border-radius: 10px;

        /* inset effect */
        border: 3px solid rgba(255, 255, 255, 0.2); 
        background-clip: content-box;
        }

        ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.6);
        }

        /* Firefox (limited support) */
        * {
        scrollbar-width: thin;                         
        scrollbar-color: rgba(255,255,255,0.4) transparent;
        }

        select:focus,
        select:active {
            outline: none;
            border: none;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .room-grid {
            display: grid;
            gap: 0;
            position: relative;
        }

        .room-object {
            position: absolute;
            cursor: pointer;
            user-select: none;
            touch-action: none;    /* prevents browser scroll/zoom during drag */
        }

        .room-object-edit {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            transition: box-shadow 0.2s ease;
        }

        @media (hover: hover) and (pointer: fine) {
            .room-object-edit:not(.marked-for-deletion):hover {
                box-shadow: inset 0 0 10px 5px rgba(245, 39, 39, 0.65);
                transition: box-shadow 0.2s ease;
            }
        }

        .room-object-edit.wallpaper:hover {
            transform: scale(1);
        }

        .room-object-edit.flooring:hover {
            transform: scale(1);
        }

        .pet {
            width: var(--pet-size);
            height: var(--pet-size);
            position: absolute;
            cursor: pointer;
            user-select: none;
            z-index: 20;
            touch-action: none;    /* prevents browser scroll/zoom during drag */
        }

        .pet.dragging {
            z-index: 1000 !important;
        }

        .room-object-edit:not(.marked-for-deletion).dragging {
            z-index: 1000 !important;
            cursor: grabbing;
            box-shadow: inset 0 0 0 2px red;
            transition: box-shadow 0.2s ease;
        }

        .marked-for-deletion {
            box-shadow: inset 0 0 0 2px red;
            transition: box-shadow 0.2s ease;
        }

        .pet-left {
        transform: scaleX(1);
        }

        .pet-right {
        transform: scaleX(-1);
        }

        .pet.pet-right:hover {
            transform: scaleX(-1) scale(1.05);
        }

        .pet.pet-left:hover {
            transform: scaleX(1) scale(1.05);
        }

        .message {
            position: fixed;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #F5F5F7;
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .message.show {
            opacity: 1;
        }

        button {
            padding: 8px 16px;
            margin: 4px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
        }
        .edit { 
            background-color: #3b82f6; color: #F5F5F7; 
        }
        .save { 
            background-color: #16a34a; color: #F5F5F7; 
        }
        .cancel { 
            background-color: #9ca3af; color: #F5F5F7; 
        }

        .hidden { 
            display: none; 
        }

        #roomGridContainer,
        #petContainer,
        #roomObjectsContainer {
            position: absolute;
        }

        #gameContainer {
            flex: 1;
            height: calc(100% - 80px - (2*16px));
            width: calc(100% - (2*16px));
            display: flex;
            background: rgba(255, 255, 255, 0.08);
            margin: 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            transition:
                height 0.3s ease,
                z-index 0.3s ease,
                transform 0.3s ease,
                margin 0.3s ease,
                padding 0.3s ease;
        }

        #gameContainer.container-expanded {
            position: absolute;
            z-index: 9000;
            height: calc(100% - (2 * 16px));
        }

        #gameContainer[hidden] {
            display: none !important;
        }

        .game-navigation {
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            height: 100%;
            width: 300px;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.15);
            border-top-left-radius: 20px;
            border-bottom-left-radius: 20px;
        }


        
.game-navigation.mobile .nav-item {
    display: flex;
    flex-direction: column; /* stack icon above label */
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease; /* smooth movement for icon */
    min-width: 17vw;
    min-height: 64px;
    width: 17vw;
    gap: 0.25rem;
    padding: 8px;
}

.game-navigation.mobile .nav-item.active {
    max-width: none;
    max-height: none;
    width: auto;
}

.game-navigation.mobile .nav-item .nav-label {
    opacity: 0;          /* hide label */
    height: 0;           /* remove space */
    overflow: hidden;    
    transition: opacity 0.3s ease, height 0.3s ease; /* animate label */
}

.game-navigation.mobile .nav-item.active .nav-label {
    opacity: 1;          /* show label */
    height: auto;        /* expand to fit */
}

.game-navigation.mobile .nav-item.active .nav-icon {
    transition: transform 0.3s ease;
}



#toggle-edit-save-btn,
.pet-stats-selection-button.active,
.department-btn.active,
.pet-btn.active,
.pet-supply-tab.active,
.pay-tax-btn:not(.paid) {
    border: none;
    /*border: #286D8A 1px solid;*/
}

.use-btn,
.purchase-btn,
.treat-use-btn,
.food-use-btn,
.fill-water-bowl-btn {
    border: none;
    /*border: #32ac93 1px solid;*/
}

#toggle-edit-save-btn,
#cancel-edit-btn,
#end-preview-button,
#delete-selected-item-button,
.pet-stats-selection-button.active,
.pet-btn.active,
.department-btn.active,
.use-btn,
.pet-supply-tab.active,
.purchase-btn,
.item-requires,
.pay-tax-btn,
.pet-delete-btn:hover,
#customConfirmNo,
#customConfirmYes,
.treat-use-btn,
.food-use-btn,
.fill-water-bowl-btn,
.fill-bath-btn  {
  letter-spacing: 0.01em;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  /*box-shadow: 
        0 1px 2px rgba(0, 0, 0, 0.2),
        0 4px 12px rgba(50, 136, 172, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);*/
  position: relative; /* required for :before absolute positioning */
}

#toggle-edit-save-btn::before,
#cancel-edit-btn::before,
#end-preview-button::before,
#delete-selected-item-button::before,
.pet-stats-selection-button.active::before,
.pet-btn.active::before,
.department-btn.active::before,
.use-btn::before,
.pet-supply-tab.active::before,
.purchase-btn::before,
.item-requires::before,
.pay-tax-btn::before,
.pet-delete-btn:hover::before,
#customConfirmNo::before,
#customConfirmYes::before,
.treat-use-btn::before,
.food-use-btn::before,
.fill-water-bowl-btn::before,
.fill-bath-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 100%);
  border-radius: 20px;
  pointer-events: none;
  transition: background 0.3s ease;
}

#toggle-edit-save-btn::after,
#cancel-edit-btn::after,
#end-preview-button::after,
#delete-selected-item-button::after,
.pet-stats-selection-button.active::after,
.pet-btn.active::after,
.department-btn.active::after,
.use-btn::after,
.pet-supply-tab.active::after,
.purchase-btn::after,
.item-requires::after,
.pay-tax-btn::after,
.pet-delete-btn:hover::after,
#customConfirmNo::after,
#customConfirmYes::after,
.treat-use-btn::after,
.food-use-btn::after,
.fill-water-bowl-btn::after,
.fill-bath-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 20px;
  padding: 1px;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
}

#toggle-edit-save-btn:hover::before,
#cancel-edit-btn:hover::before,
#end-preview-button:hover::before,
#delete-selected-item-button:not(:disabled):hover::before,
.pet-stats-selection-button.active:hover::before,
.pet-btn.active:hover::before,
.use-btn:hover::before,
.purchase-btn:hover::before,
.item-requires:hover::before,
.pay-tax-btn:hover::before,
#customConfirmNo:hover::before,
#customConfirmYes:hover::before,
.treat-use-btn:hover::before,
.food-use-btn:hover::before,
.fill-water-bowl-btn:hover::before,
.fill-bath-btn:hover::before {
  background: rgba(255, 255, 255, 0.15);
}




        .nav-items {
            display: flex;
            padding: 16px;
            padding-top: 32px;
            flex-direction: column;
            gap: 0.75rem;
        }

        .nav-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 1rem 0.75rem;
            border: none;
            background: transparent;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            color: #4b5563;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            color: #212529;
            overflow: hidden;
        }

        .nav-item:focus {
            outline: none;
        }

        .nav-item.active {
            background: linear-gradient(135deg, #A0C58F, #32ac93) !important;
            color: #F5F5F7;
             /*box-shadow: 
                    0 1px 2px rgba(0, 0, 0, 0.2),
                    0 4px 12px rgba(50, 136, 172, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);*/
                        
        }

        .game-navigation:not(.mobile) .nav-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .game-navigation:not(.mobile) .nav-item:hover:before {
            left: 100%;
        }

        .game-navigation:not(.mobile) .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }

        .nav-icon {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            position: relative;
        }

        .nav-icon img {
            width: 24px; 
            height: 24px;
        }

        #game-content {
            flex: 1;
            overflow: auto;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 25px;
            margin-right: 10px;
        }
        
        #content-outer-container,
        #pet-room-container {
            height: 100%;
        }

        #pet-room-container {
            margin-top: auto;
            margin-bottom: auto;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #content-outer-container {
            display: flex;
            align-items: start;
            justify-content: center;
        }

        #game-panel {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        #room-container {
            position: relative;
        }

        #room-container.dark::after {
            content: "";
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* semi-transparent dark */
            z-index: 100; /* on top of room content */
            pointer-events: all; /* blocks clicks if needed */
        }

        .game-content-panel {
            display: none;
            width: 100%;
            min-height: 100%;
            box-sizing: border-box;
        }

        .game-content-panel.active {
            display: flex;
            flex-direction: column;
        }

        #gameContainer.mobile {
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .game-navigation.mobile {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            max-height: 80px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            z-index: 1000;
            border-radius: 0;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-right: 0;
            transition: max-height 0.3s ease; /* smooth transition */
        }

        .game-navigation.mobile.container-expanded {
            max-height: 0;
        }
        

        .game-navigation.mobile .nav-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 8px;
            flex-direction: row;
            gap: 0;
        }

        #game-content.mobile {
            overflow-y: scroll;
        }

        #button-container {
            margin-top: 1svh;
            display: flex;
            justify-content: space-between;
        }

        #toggle-edit-save-btn,
        #cancel-edit-btn,
        #delete-selected-item-button,
        #end-preview-button {
            align-items: center;
            gap: 0.5rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            border: none;
            /*border: 1px solid #32ac93;*/
            margin-left: 0;
            padding: 10px 16px
        }

        #toggle-edit-save-btn.edit {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            border: none;
            /*border: 1px solid #286D8A;*/
        }

        #cancel-edit-btn,
        #end-preview-button,
        #delete-selected-item-button {
            background: linear-gradient(135deg, #ff8073, #e74c3c);
            border: none;
            /*border: 1px solid #e74c3c;*/
        }

        #delete-selected-item-button:disabled {
            background: #9ca3af;
            opacity: 0.5;
            cursor: not-allowed;
        }

.shop-header {
    position: sticky;
    top: 0;
    z-index: 9999;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    margin-bottom: 30px;
    transition: all 0.3s ease;
}

.shop-header.compact .collapsible-content {
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    margin-bottom: 0;
}

.shop-header.compact .header-main {
    padding: 10px 15px;
}

.header-main {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    transition: padding 0.3s ease;
    cursor: pointer;
}

.header-left {
    display: flex;
    align-items: center;
}

.header-left h2 {
    margin: 0 !important;
}

.expand-toggle {
    background: transparent;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    padding: 0;
    margin: 0;
}

.expand-toggle svg {
    width: 20px;
    height: 20px;
    transition: transform 0.3s ease;
}

.shop-header.compact .expand-toggle svg {
    transform: rotate(180deg);
}

.collapsible-content {
    max-height: 500px;
    overflow: hidden;
    opacity: 1;
    transition: max-height 0.3s ease, opacity 0.3s ease, margin-bottom 0.3s ease;
    padding: 0 20px 20px;
}

        .shop-header h2 {
            color: #212529;
            margin: 0;
            font-size: 2rem;
            font-weight: 800;
            margin: 3px 0;
        }
        

        .coin-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            background: #ffc074;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 2px 8px 2px 4px;
            border-radius: 15px;
            font-weight: 600;
            color: #92400e;
        }

        .coin-display.main {
            background: transparent;
            transition:
                max-height 0.3s ease,
                opacity 0.3s ease;
        }

        .coin-display.main.container-expanded  {
            max-height: 0;
            opacity: 0;
        }

        .coin-display-delete-confirm {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 2px 8px 2px 4px;
            border-radius: 15px;
            font-weight: 600;
            color: #92400e;
        }

        .coin-icon {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .coin-icon img {
            width: 34px;
            height: 34px;
        }

        .owned-badge-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .owned-badge-icon img {
            width: 14px;
            height: 14px;
        }

        .item-price-coin-icon {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .item-price-coin-icon img {
            width: 24px;
            height: 24px;
        }

        .item-description-icon {
            height: 20px;
            width: 20px;
        }

        .tax-price img {
            width: 32px;
            height: 32px;
        }

        .shop-categories-dropdown select,
        #pet-category-select,
        #shop-category-select {
            padding: 12px 16px;
            font-size: 1rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 150px;
            text-align: center;
            cursor: pointer;
        }

        #object-sidebar-category-select {
            padding: 12px 16px;
            font-size: 1rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            text-align: center;
            cursor: pointer;
        }

        .shop-items:not(:empty),
        .object-assets:not(:empty),
        #pet-skins:not(:empty),
        #pet-supplies:not(:empty) {
            height: 100%;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            overflow-y: auto;
            padding-bottom: 30px;
        }

        .shop-items {
            height: 100%;
            overflow-y: auto;
            box-sizing: content-box !important;
        }
 
        .food-options-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .no-item-message,
        .no-supplies-message {
            font-style: italic;
        }

        .food-item {
            display: flex;
            flex-wrap: wrap; 
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 20px;
            border: 1px solid #e9ecef;
            justify-content: space-between;
        }

        .food-item-preview-holder {
        width: 40px;
        height: 40px;
        background: #dee2e6;
        border-radius: 6px;
        flex-shrink: 0;
        }

        .food-item-preview-text-holder {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 15px;
            align-items: center;
            line-height: 1;
        }

        .food-item-quant-btn-holder {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 15px;
            justify-content: end;
            align-items: center;
        }

        .food-item-name-description-holder {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .food-item-description {
            color: #6b7280;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            margin-top: 2px;
        }

        .food-item-name {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
            color: #212529;
        }

        .item-quantity {
            font-weight: 400;
            color: #666;
            font-size: 14px;
        }

        .food-quantity-input {
            width: 60px;
            height: 20px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 1);
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0px 1px 4px rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            transition: all 0.2s;
            align-items: center;
            justify-content: space-between;
            display: flex;
            flex-direction: column;
        }

        .purchase-btn,
        .use-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            color: #F5F5F7;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            width: 170px;
            height: 40px;
            min-height: 40px;
        }

        .object-sidebar-assets .use-btn {
            width: 150px;
        }

        .object-sidebar-assets .shop-item {
            padding-left: 15px;
            padding-right: 15px;
            box-shadow: none;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .object-sidebar-assets .shop-item.in-use {
            display: none;
        }

        .food-use-btn,
        .treat-use-btn {
            align-items: center;
            gap: 0.5rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            color: #F5F5F7;
            margin-left: 0;
            padding: 10px 16px;
        }

        .department-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .department-icon img {
            height: 24px;
            width: 24px;
        }

        .purchase-btn.owned,
        .use-btn.used,
        .use-btn.equipped,
        .pay-tax-btn.paid {
            background: #6b7280;
            color: #F5F5F7;
            cursor: not-allowed;
            transform: translateY(0px) !important;
            border: none;
            /*border: 1px solid #6b7280;*/
        }

        .purchase-btn.owned:hover::before,
        .use-btn.used:hover::before,
        .use-btn.equipped:hover::before,
        .pay-tax-btn.paid:hover::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 100%);
        }

        .pet-supply-use-quantity-holder {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }

        .item-requires {
            padding: 6px 12px;
            background: #10b981;
            background: #6b7280;
            color: #F5F5F7;
            cursor: not-allowed;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 30px;
            min-width: 60%;
            font-size: 1rem;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .owned-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            color: #F5F5F7;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            border: 2px solid #F5F5F7;
            z-index: 9999;
        }

        .item-preview-holder {
            position: relative;
            width: 125px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgb(210, 180, 140);
            padding: 10px;
            border-radius: 10px;
        }

        .food-item-preview-holder {
            position: relative;
            width: 62.5px;
            height: 37.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgb(210, 180, 140);
            padding: 2px;
            border-radius: 10px;
        }

        .item-preview {
            background-size: contain; /* or cover, depending on behavior */
            background-position: center;
            max-height: 100%;
            max-width: 100%;
        }

        .item-preview.pet {
            background-size: calc(var(--pet-size) * 16) calc(var(--pet-size)*26); /* 16 number of columns in iamge, 25 number of rows*/
            background-position: 0 0;
        }

        #furniture-container,
        #shop-container,
        #taxes-container,
        #pet-asset-container {
            padding: 30px 30px 0 30px;
            height: 100%;
            overflow: hidden;
        }

        .tax-section-inner-holder {
            height: 100%;
            overflow: auto;
        }

        .department-btn.active,
        .pet-supply-tab.active {
            background: linear-gradient(135deg, #3288AC, #286D8A) !important;
            border: none;
            /*border: 1px solid #286D8A;*/
            transform: translateY(0px) !important;
            color: #F5F5F7;
        }
        
        .item-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #1f2937;
            margin: 0 0 0.5rem 0;
            text-align: center;
        }

        .item-description {
            color: #6b7280;
            font-size: 0.9rem;
            margin: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .item-price {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            font-weight: bold;
            color: #92400e;
            text-align: center;
        }

        .item-price-and-quantity {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 12px;
        }

        @keyframes draw {
        0% {
            stroke-dashoffset: 1000;
        }
        100% {
            stroke-dashoffset: 0;
        }
        }

        .tick {
            fill: none;
            stroke: #F5F5F7;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 24;
            stroke-dashoffset: 24;
        }

        .tick.draw {
        animation: draw 0.5s ease forwards;
        }

        @keyframes draw {
        to {
            stroke-dashoffset: 0;
        }
        }

        .summary-card {
            background: #F5F5F7;
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            padding: 1.5rem;
        }

        .summary-card h3 {
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 6px;
        }

        .stat-value.owed {
            color: #ef4444;
        }

        .tax-records h3 {
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .info-card h4 {
            display: flex;
            align-items: center;
            margin-bottom: 0;
        }

        .info-card p {
            margin-top: 8px;
        }

        .records-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .tax-record {
            background: #F5F5F7;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 15px 25px 15px 20px;
            margin: 0;
            border: 1px solid #F5F5F7;
        }

        .record-info {
            flex: 1;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            color: #F5F5F7;
            background-color: #f59e0b;
        }

        .tax-record.pending {
            border-left: 4px solid #f59e0b;
            border-color: #f59e0b;
            background: #f7e5be;
        }

        .tax-record.paid {
            border-left: 4px solid #10b981;
            border-color: #10b981;
            background: #d1edd4;
        }

        .tax-record.overdue {
            border-left: 4px solid #ef4444;
            border-color: #ef4444;
            background: #f7dfda;
        }

        .record-actions {
            display: flex;
            justify-content: center;
        }

        .pay-tax-btn {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            color: #F5F5F7;
            border: none;
            padding: 12px 18px;
            border-radius: 20px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            min-width: 120px;
            margin: 0;
        }

        .pay-tax-btn:active {
            transform: translateY(0);
        }

        .record-type {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 8px;
        }

        .type-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 35px;
            height: 35px;
            border-radius: 20px;
            background-color: #dbeafe;
            flex-shrink: 0;
        }

        .type-name {
            font-weight: 600;
            font-size: 1.25rem;
            color: #1e293b;
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .tax-info {
            margin-top: 20px;
            margin-bottom: 30px;
        }

        #days-remaining-water,
        #days-remaining-electricity {
            color: #e74c3c;
            font-size: 1rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .record-details {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }

        .record-date {
            color: #64748b;
            font-size: 1rem;
        }

        .record-amount {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            font-size: 18px;
            color: #92400e;
        }

        .tax-status-and-pay-btn-holder {
            display: flex;
            flex-direction: row;
            justify-content: end;
            align-items: center;
            gap: 15px;
        }

        .record-status {
            display: flex;
            justify-content: center;
        }

        .shop-departments {
            display: flex;
            margin-bottom: 16px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .pet-asset-supply-tabs {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-wrap: wrap;
        }

        .pet-supplies-tabs {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-wrap: wrap;
        }

        .department-btn,
        .pet-supply-tab {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 12px 18px 12px 18px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background, transform 0.3s ease;
            margin: 0;
        }

        .pet-asset-supply-button,
        .pet-supply-tab {
            padding: 8px 14px 8px 12px;
        }

        .department-btn:hover,
        .pet-supply-tab:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .pet-btn {
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            transition: all 0.3s ease;
            margin: 0;
        }

        .pet-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .pet-btn.active {
                background: linear-gradient(135deg, #3288AC, #286D8A) !important;
        }

        #pet-list-shop,
        #pet-list-owned {
            flex: 1 1 auto;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        #pet-asset-buttons-departments-dropdown {
            display: flex;
            flex-direction: column;
            justify-content: end;
            align-items: start;
            flex: 0 0 auto;
        }

        /* Hide both checkboxes */
        #shop-not-owned-toggle,
        #object-usage-toggle,
        .pet-on-walk-toggle {
            height: 0;
            width: 0;
            visibility: hidden;
        }

        .item-description-icons {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
            gap: 4px;
        }

        .food-item .item-description-icons {
            justify-content: start;
        }

        /* Base switch style */
        #object-usage-toggle + span {
            cursor: pointer;
            width: 60px;
            height: 30px;
            background: grey;
            display: inline-block;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: 0.3s;
        }

        /* Knob */
        .pet-on-walk-toggle + span:after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: #F5F5F7;
            border-radius: 50%;
            transition: 0.3s;
        }

        #object-usage-toggle + span:after,
        #shop-not-owned-toggle + span:after {
            content: '';
            position: absolute;
            top: 3px;
            left: 4px;
            width: 29px;
            height: 29px;
            background: #F5F5F7;
            border-radius: 50%;
            transition: 0.3s;
        }

        .switch-slider,
        .shop-not-owned-toggle {
            margin-left: 0 !important;
        }

        .shop-not-owned-holder,
        .object-usage-toggle-holder {
            display: flex;
            align-items: center;
        }

        .shop-categories-dropdown select {
            width: 150px;
        }

        .pet-on-walk-toggle:checked + span:after {
            left: calc(100% - 3px);
            transform: translateX(-100%);
        }

        #object-usage-toggle:checked + span:after,
        #shop-not-owned-toggle:checked + span:after {
            left: calc(100% - 5px);
            transform: translateX(-100%);
        }

        /* Active animation */
        #shop-not-owned-toggle:active + span:after,
        #object-usage-toggle:active + span::after {
            width: 28px;
        }

        .pet-on-walk-toggle + span {
            cursor: pointer;
            width: 95px;
            height: 30px;
            background: rgba(33, 37, 41, 0.5);
            display: inline-block;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .shop-not-owned-toggle + span {
            cursor: pointer;
            width: 115px;
            height: 35px;
            background: rgba(33, 37, 41, 0.5);
            display: inline-block;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: width 0.3s ease, background 0.3s ease;
        }

        #object-usage-toggle + span {
            cursor: pointer;
            width: 118px;
            height: 35px;
            background: rgba(33, 37, 41, 0.5);
            display: flex;
            justify-content: end;
            align-items: center;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .shop-not-owned-toggle + .switch-slider {
            display: flex !important;
            justify-content: end;
            align-items: center;
        }

        .pet-on-walk-toggle + .switch-slider {
            display: flex !important;
            justify-content: end;
            align-items: center;
        }

        .switch-text {
            margin-right: 9px;
            color: #F5F5F7;
        }

        .switch,
        #pet-on-walk-checkbox-holder {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pet-on-walk-toggle:checked + span {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            width: 60px;
        }

        .shop-not-owned-toggle:checked + span {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            width: 70px;
        }

        #object-usage-toggle:checked + span {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            width: 70px;
        }

        .modern-popup {
            position: fixed;
            top: 10vh;
            right: 20px;
            z-index: 10000;
            width: 90vw;
            max-width: 400px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            background-color: #F5F5F7;
            animation: slideInRight 0.3s ease-out;
        }

        .modern-popup.error {
            background: linear-gradient(145deg, rgba(220, 38, 38, 0.95), rgba(185, 28, 28, 0.95));
            color: #F5F5F7;
        }

        .modern-popup.success {
            background: linear-gradient(145deg, rgba(34, 197, 94, 0.95), rgba(22, 163, 74, 0.95));
            color: #F5F5F7;
        }

        .popup-content {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            gap: 12px;
        }

        .popup-icon {
            flex-shrink: 0;
            opacity: 0.9;
        }

        .popup-message {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            line-height: 1.4;
        }

        .popup-close {
            background: none;
            border: none;
            color: currentColor;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .popup-close:hover {
            opacity: 1;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }



#tax-indicator {
    position: absolute;
    height: 10px;
    width: 10px;
    border-radius: 10px;
    right: 0;
    bottom: 0;
}

.stats-bar-outer {
    display: flex;
    align-items: center;
}

.stats-bar-icon {
    margin-right: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.stats-icon {
    height: 24px;
    width: 24px;
}

 .pet-stats-bars {
    width: 250px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin: 5px 0 2svh 0;
    overflow: hidden;
    max-height: 400px;
    opacity: 1;
    transition:
        max-height 0.3s ease,
        opacity 0.3s ease;
  }

  .pet-stats-bars.container-expanded  {
    max-height: 0;
    opacity: 0;
  }

  .stat-bar {
    display: flex;
    border: 2px solid #212529;
    border-radius: 20px;
    height: 20px;
    box-sizing: border-box;
    gap: 2px;
    overflow: hidden;
  }

  .segments {
    display: flex;
    flex-direction: row;
    margin: 0 -21px 0 0 ;
    width: 400px;
    justify-content: center;
    align-items: center;
  }

  .segment {
    flex: 1;
    background: transparent;
    border: 0.5px solid rgba(33, 37, 41, 0.5);
    height: 101%;    
  }


  .pet-stats-selection-button {
    background-color: transparent;
    border: rgba(33, 37, 41, 0.5) 1px solid;
  }

  .pet-stats-selection-button.active {
    background: linear-gradient(135deg, #3288AC, #286D8A);
    border: none;
    /*border: #286D8A 1px solid;*/
    color: #F5F5F7;
  }

  .pet-stats-selection-button-text {
    position: relative;
  }

  .pet-stats-selection-button-indicator {
    position: absolute;
    width: 7px;
    height: 7px;
    border-radius: 25px;
    background: linear-gradient(135deg, #ff8073, #e74c3c);
    right: -7px;
    top: -2px;
    display: none;
  }

  .modal {
  display: none; /* hidden by default */
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.5);
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  background: #F5F5F7;
  padding: 20px 30px;
  border-radius: 10px;
  text-align: center;
  width: 80%;
}

.modal-buttons {
  margin-top: 15px;
  display: flex;
  justify-content: space-around;
}

.btn-confirm {
  font-size: 1rem;
  background: linear-gradient(135deg, #ff8073, #e74c3c);
  color: #F5F5F7;border: none;
  /*border: 1px solid #e74c3c;*/
}

.btn-cancel {
  font-size: 1rem;
  background: linear-gradient(135deg, #95a5a6, #aeb4b5);
  color: #F5F5F7;
  border: none;
  /*border: 1px solid #95a5a6;*/
}

.item-delete-btn-holder {
    background: linear-gradient(135deg, #ff8073, #e74c3c);
    border-radius: 50%;
    z-index: 1000;
    position: absolute;
    top: -5px;
    right: -5px;
    width: 30px;
    height: 30px;
    display: flex;
    justify-content: center;
}

.item-delete-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 18px;
    padding: 0;
}

.pet-section-pet-button-container {
    display: flex;
    flex-direction: column;
    width: 90px;
}

.pet-name-field {
    background-color: #F5F5F7;
    font-size: 1.5rem;
    border: none;
    width: auto;
    min-width: 1ch;   /* at least 1 character wide */
    max-width: 10ch;  /* no wider than 10 characters */
}

.pet-name-field:focus,
.pet-name-field:active {
    border: none;
    outline: none;
}

.pet-delete-btn {
    width: 90px;
    background: transparent;
    border: rgba(33, 37, 41, 0.5) 1px solid;
    border-radius: 20px;
    margin: 0 0 5px 0;
    transition: all 0.2s;
}

.pet-delete-btn:hover,
.pet-delete-btn:active {
    background: linear-gradient(135deg, #ff8073, #e74c3c);
    border: 1px solid transparent;
    /*border: #e74c3c 1px solid;*/
    color: #F5F5F7;
}

.title-subtitle-inline-button-wrapper {
    display: flex;
    flex-direction: row;
    align-items: center;
}

.water-bowl-options-container,
.bath-options-container {
    display: flex;
    justify-content: end;
}

.fill-water-bowl-btn,
.fill-bath-btn {
    align-items: center;
    gap: 0.5rem;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 1rem;
    background: linear-gradient(135deg, #40c9a9, #32ac93);
    color: #F5F5F7;
    margin: 0;
    padding: 10px 16px;
}

.viewport-control-btn {
    background: transparent;
    padding: 8px;
}

#toggle-expand-btn span svg path {
    fill: #212529;
    width: 100%;
}

#toggle-expand-btn svg {
    width: 24px;
    height: 24px;
}

#toggle-zoom-lock-btn,
#toggle-expand-btn {
    padding-bottom: 0;
    margin-bottom: 0
}

.upper-controls-holder {
    margin-bottom: 2svh;
}

.upper-controls-inner-holder {
    display: flex;
    justify-content: center;
}

#toggle-zoom-lock-btn svg path {
    fill: #212529;
}

#toggle-zoom-lock-btn svg {
    width: 24px;
    height: 24px;
}

#toggle-expand-btn:active,
#toggle-expand-btn:focus,
#toggle-zoom-lock-btn:active,
#toggle-zoom-lock-btn:focus {
    outline: none;
}

#pet-asset-buttons,
#shop-buttons {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: flex-end;
  gap: 10px;
  margin-bottom: 16px;
}

.categories-dropdown-holder {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  gap: 10px;
}

#pet-buttons-outer {
    display: flex;
    width: 100%;
    flex-direction: row;
    justify-content: space-between;
    overflow: hidden;
    max-height: 200px; /* <- something larger than actual height */
    opacity: 1;
    transition:
        max-height 0.3s ease,
        opacity 0.3s ease;
}

#pet-buttons-outer.container-expanded {
    max-height: 0;
    opacity: 0;
}

.pet-on-walk-holder {
    display: flex;
    flex-direction: column;
}

.furniture-preview-button {
    border: 2px solid #F5F5F7;
    background: linear-gradient(135deg, #3288AC, #286D8A);
    padding: 0;
    width: 30px;
    height: 30px;
    position: absolute;
    top: -14px;
    right: -14px;
    z-index: 9000;
    display: flex;
    justify-content: center;
    align-items: center;
}

.furniture-preview-button svg {
    height: 20px;
    width: 20px;
    color: #F5F5F7
}

.item-info {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.purchase-quantity-holder {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 1);
}

.purchase-quantity,
.pet-supply-use-quantity,
.food-quantity-input {
    width: 26px;              /* fixed width */
    height: 30px;             /* fixed height */
    padding: 0;               /* remove internal padding */
    border: none;
    text-align: center;       /* horizontally center text */
    line-height: 30px;        /* vertically center text */
    font-size: 1rem;
    box-sizing: border-box;   /* include border in width/height */
    -moz-appearance: textfield;  /* remove spinner in Firefox */
}

.purchase-quantity:focus,
.pet-supply-use-quantity:focus,
.food-quantity-input:focus,
.purchase-quantity:active,
.pet-supply-use-quantity:active,
.food-quantity-input:active {
    outline: none;
}

.purchase-quantity::-webkit-outer-spin-button,
.purchase-quantity::-webkit-inner-spin-button,
.pet-supply-use-quantity::-webkit-outer-spin-button,
.pet-supply-use-quantity::-webkit-inner-spin-button,
.food-quantity-input::-webkit-outer-spin-button,
.food-quantity-input::-webkit-inner-spin-button {
    -webkit-appearance: none; /* remove spinner in Chrome/Safari */
    margin: 0;
}

.control-btn {
    height: 20px;
    width: 20px;
}

/* GIFT CSS START */

.preview-outer {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

.preview {
  width: 120px;
  height: 120px;
  position: relative;
  margin-top: 10px;
}

/* Gift box pop-out */
.gift-box {
  width: 100%;
  height: 100%;
  background-repeat: no-repeat;
  background-size: cover;
  border-radius: 8px;
  animation: fadeOut 0.3s forwards 1.2s;
  position: absolute;
  top: 0;
  left: 0;
}

@keyframes fadeOut {
  to { opacity: 0; transform: scale(0.8); }
}

/* Item preview pop-in */
.gift-preview-holder {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transform: scale(0.5);
  animation: revealPreview 0.6s ease-out forwards 1.3s;
  background-color: transparent !important;
  padding: 0 !important;
}

@keyframes revealPreview {
  0% { opacity: 0; transform: scale(0.5); }
  60% { opacity: 1; transform: scale(1.2); }
  80% { transform: scale(0.9); }
  100% { opacity: 1; transform: scale(1); }
}

.gift-preview {
  width: 100px;
  height: 100px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  text-align: center;
  font-size: 0.9rem;
}

/* GIFT CSS END */

.blinking-warning {
    animation: redYellowBlink 0.4s ease-in-out infinite;
}

@keyframes redYellowBlink {
    0%   { outline: 2px solid red; }
    50%  { outline: 2px solid yellow; }
    100% { outline: 2px solid red; }
}

#viewport-container {
    min-height: 0;
    flex: 1 1 auto;
    width: 100%;
    overflow: hidden;
    position: relative;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 20px;
    touch-action: none;
}

#room-transform-wrapper {
    position: absolute;
    transform-origin: 0 0;
    transition: none;
}

/* Visual indicator for pan mode */
.pan-mode-active {
    cursor: grab !important;
}

.pan-mode-active * {
    cursor: grab !important;
}

.panning {
    cursor: grabbing !important;
}

.panning * {
    cursor: grabbing !important;
}

#pan-mode-indicator {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(59, 130, 246, 0.9);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    z-index: 10000;
    display: none;
    pointer-events: none;
}

#pan-mode-indicator.active {
    display: block;
}

.stats-and-upper-controls-holder {
    display: flex;
    justify-content: space-between;
    align-items: end;
}

.stats-and-upper-controls-holder.container-expanded  {
    justify-content: end;
}

/* Sidebar wrapper */


/* Sidebar content */
.sidebar-wrapper {
    position: absolute;
    left: 0;
    top: 0;
    height: calc(100%);
    width: 300px;
    z-index: 100;
    transition: transform 0.3s ease;
    transform: translateX(-335px);
    padding-left: 0;
    z-index: 9000;
}

.sidebar {
    position: absolute;
    width: 100%;
    padding: 16px;
    height: 100%;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    background: rgba(255, 255, 255, 0.5);
    margin: 0;
    margin-top: 0;
    z-index: 10;
}

.sidebar-wrapper.open {
    transform: translateX(0) !important;
}

.sidebar-wrapper.open .toggle-tab svg {
    transform: rotate(180deg);
}

.sidebar-content {
    min-height: 100%;
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    height: 100%;
}

#dynamic-content,
.edit-mode-object-sidebar {
    height: 100%;
    overflow: hidden;
}

.edit-mode-object-sidebar {
    display: flex;
    flex-direction: column;
}

.object-sidebar-assets {
    flex: 1 1 auto;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.object-sidebar-categories-dropdown-holder {
    margin-bottom: 15px;
    flex: 0 1 auto;
}

/* Toggle tab - always visible */
.toggle-tab {
    position: absolute;
    right: -34px;
    top: 0;
    border: none;
    width: 34px;
    height: 62px;
    border-radius: 0 20px 20px 0;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    -webkit-backdrop-filter: blur(15px);
    backdrop-filter: blur(15px);
    background: rgba(255, 255, 255, 0.5);
    padding: 0;
    margin: 0;
}

.toggle-tab svg {
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
}

/* Overlay */
.overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 99;
}

.overlay.active {
    display: block;
}


.shop-header.compact .collapsible-content{
    padding-top: 0;
    padding-bottom: 0;
}

.purchase-btn-hold {
  --progress: #3288AC;
  --duration: 1600ms;

  padding: 12px 24px;
  border: 0;
  outline: none;
  user-select: none;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  border-radius: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  backface-visibility: hidden;
  transition: box-shadow 0.3s, transform 0.3s;
}

.purchase-btn-hold > span:first-child {
  position: relative;
  z-index: 3;
  backface-visibility: hidden;
  transition: transform 0.3s, opacity 0.2s;
}

/* Background layer for press effect */
.purchase-btn-hold::before {
  content: '';
  position: absolute;
  inset: 0;
  z-index: 2;
  border-radius: inherit;
  transition: transform 0.3s;
  background: var(--background, transparent);
}

/* SVG stroke - FIXED: Hide initially */
.purchase-btn-hold svg rect {
  stroke-dasharray: 0;
  stroke-dashoffset: 0;
  transition: none;
  opacity: 0; /* Hidden by default */
}

/* SVG stroke */
.purchase-btn-hold svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

/* Press effect */
.purchase-btn-hold:active:not(.success)::before {
  transform: scaleX(0.95) scaleY(0.84);
}

/* Process animation - FIXED: Show stroke and sync timing */
.purchase-btn-hold.process svg rect {
  opacity: 1;
  stroke-dashoffset: 0;
}

/* Custom Dropdown Styles */
.custom-dropdown-wrapper {
    margin: 8px 0;
}

.custom-dropdown {
    position: relative;
    width: 100%;
}

.custom-dropdown-selected {
    padding: 0 6px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 14px;
    min-height: 36px;
}

.custom-dropdown-icon {
    margin-left: 8px;
    font-size: 10px;
    color: #666;
}

/* Color circle styles */
.color-circle {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    margin-right: 8px;
    border: 1px solid #ddd;
    flex-shrink: 0;
}

.color-text {
    color: #666;
    font-size: 12px;
}

.custom-dropdown-selected .color-circle {
    width: 16px;
    height: 16px;
}

/* Variant dropdowns container */
.variant-dropdowns {
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 3px;
}

/* Modal Styles (used on all devices) */
.variant-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    padding: 20px;
}

.variant-modal {
    background: white;
    border-radius: 12px;
    width: 100%;
    max-width: 400px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.variant-modal-header {
    padding: 16px 20px;
    border-bottom: 1px solid #eee;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #f8f9fa;
}

.variant-modal-title {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: #333;
}

.variant-modal-close {
    background: none;
    border: none;
    font-size: 24px;
    color: #666;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.variant-modal-close:hover {
    background: #eee;
}

.variant-modal-options {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    max-height: 60vh;
}

.variant-modal-option {
    padding: 14px 16px;
    margin: 4px 0;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    font-size: 16px;
    border: 1px solid transparent;
    transition: all 0.2s ease;
}

.variant-modal-option:hover {
    background: #f5f5f5;
}

.variant-modal-option.selected {
    background: #e8f4ff;
    border-color: #32ac93;
    color: #32ac93;
}

/* Larger color circles for modal */
.color-circle-large {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid #ddd;
    margin-right: 12px;
    flex-shrink: 0;
}

.variant-modal-option.selected .color-circle-large {
    border-color: #32ac93;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .custom-dropdown-selected {
        padding: 0 10px;
        font-size: 16px;
        min-height: 44px;
    }
    
    .color-circle {
        width: 24px;
        height: 24px;
    }
    
    .variant-dropdowns {
        margin: 16px 0;
    }
}

@media (min-width: 769px) {
    .toggle-tab {
        display: none;
    }
}


/* Mobile: collapsible sidebar */
@media (max-width: 768px) {
    .sidebar-wrapper {
        top: 95px;
        height: calc(100% - 160px - 28px);
        width: calc(100vw - 35px - 5px);
        transform: translateX(calc(-100vw - 35px - 5px));
        border-bottom-right-radius: 8px;
        margin: 0;
        margin-top: 0;
    }

    .sidebar-wrapper.container-expanded {
        top: 5px;
        height: calc(100% - 20px);
        width: calc(100vw - 35px - 5px);
        transform: translateX(calc(-100vw - 35px - 5px));
        border-bottom-right-radius: 8px;
        margin: 0;
        margin-top: 0;
    }

    .sidebar {
        padding: 16px 16px 0 16px;
        height: 100%;
        border-bottom-right-radius: 8px;
        margin: 0;
        margin-top: 0;
    }

    #gameContainer.container-expanded {
        position: absolute;
        z-index: 9000;
        height: 100%;
    }
}

@media (max-width: 1024px) {
    .nav-item {
        font-size: 0.9rem;
    }
}


@media (max-width: 767px) {
    #gameContainer {
        margin: 0;
        width: 100%;
        border-radius: 0;
        background: none;
    }

    .main-navbar {
        box-shadow: none;
    }
    
    #game-content {
        margin-right: 0;
        border-radius: 0;
    }

    #content-outer-container {
        min-height: 0;
        height: calc(100% - 81px);
        overflow-y: scroll;
    }

    #content-outer-container.container-expanded {
        min-height: 0;
        height: 100%;
    }

    #pet-room-container {
        justify-content: start;
    }

    .game-content-panel.mobile {
        padding: 15px 15px 0 15px !important;
    }

    .game-content-panel.mobile.container-expanded  {
        padding: 15px 15px 2.5px 15px !important;
    }

    .shop-items:not(:empty), .object-assets:not(:empty), #pet-skins:not(:empty), #pet-supplies:not(:empty) {
        padding-bottom: 15px;
    }


    #game-panel {
        margin: 0;
    }

    .pet-stats-bars {
        width: 200px;
    }

    .stat-bar {
        height: 16px;
    }

    .segments {
        margin: 0 -16px 0 0;
    }

    .pet-supply-tab,
    .pet-asset-supply-button {
        padding: 8px 14px 8px 12px;
    }

    #pet-category-select,
    .shop-categories-dropdown select {
        padding: 8px 8px;
    }

     .shop-header.compact .header-main {
        padding: 10px 15px;
    }
    
    .header-main {
        padding: 10px 15px;
    }
    
    .collapsible-content {
        padding: 0 15px 10px 15px;
    }
    
    .expand-toggle {
        width: 32px;
        height: 32px;
    }
    
    .expand-toggle svg {
        width: 18px;
        height: 18px;
    }
}

@media (max-width: 578px) {
    .pet-section-pet-button-container,
    .pet-delete-btn {
        width: 85px;
    }

    #pet-list-owned {
        gap: 10px;
    }

    .pet-btn {
        width: 85px;
        height: 85px;
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 0 10px;
    }

    .pet-preview {
        position: static;
        height: 70px;
        width: 70px;
        background-size: calc(70px * 16) calc(70px * 26);
    }

    .shop-header h2 {
        font-size: 1.65rem;
    }

    .coin-display {
        gap: 3px;
        font-size: 0.9rem;
        padding: 4px 8px 4px 6px;
    }

    .item-price-coin-icon .coin-icon img {
        width: 28px;
        height: 28px;
    }

    .tax-record {
        padding: 10px 15px 10px 15px;
    }

    #days-remaining-water,
    #days-remaining-electricity  {
        font-size: 0.9rem;
    }

    .record-type {
        margin-bottom: 12px;
    }

    .type-name {
        font-size: 1.15rem;
    }

    .record-date {
        font-size: 0.9rem;
    }

    .status-badge {
        font-size: 0.85rem;
        padding: 5px 9px;
    }

    .record-amount {
        font-size: 1rem;
    }

    .record-details {
        margin-bottom: 20px;
    }

    .pay-tax-btn {
        padding: 8px 16px 8px 16px;
        min-width: 100px;
    }

    .pet-stats-bars {
    margin-left: 8px;
  }

  #button-container {
    padding-left: 8px;
  }

  #pet-buttons {
    margin-left: 4px;
  }

    .expand-toggle {
        width: 20px;
        height: 32px;
    }
}


@media (min-device-width: 768px) and (max-device-width: 1200px) and (orientation: portrait)  {
    .toggle-tab {
        display: flex;
        right: -38px;
        width: 38px;
        height: 80px;
    }

    .sidebar-wrapper {
        top: 16px;
        height: calc(100% - 116px - 32px);
        width: calc(100vw - 38px - 5px);
        max-width: 500px;
        transform: translateX(calc(-100vw - 38px - 5px));
        border-bottom-right-radius: 8px;
        margin: 0;
        margin-top: 0;
    }

    .sidebar {
        border-bottom-right-radius: 16px;
    }

    #toggle-zoom-lock-btn svg {
    width: 36px;
    height: 36px;
}

#toggle-expand-btn svg {
    width: 32px;
    height: 32px;
}


    .game-navigation {
    min-height: 116px;
}

.game-navigation .nav-item {
    display: flex;
    flex-direction: column; /* stack icon above label */
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease; /* smooth movement for icon */
    min-width: 17vw;
    min-height: 100px;
    width: 17vw;
    gap: 0.25rem;
    padding: 8px;
}

.game-navigation img {
    width: 42px;
    height: 42px;
}

.game-navigation .nav-item.active {
    max-width: none;
    max-height: none;
    width: auto;
}

.game-navigation .nav-item .nav-label {
    opacity: 0;          /* hide label */
    height: 0;           /* remove space */
    overflow: hidden;    
    transition: opacity 0.3s ease, height 0.3s ease; /* animate label */
}

.game-navigation .nav-item.active .nav-label {
    font-size: 1.5rem;
    opacity: 1;          /* show label */
    height: auto;        /* expand to fit */
}

.game-navigation .nav-item.active .nav-icon {
    transition: transform 0.3s ease;
}

 .game-navigation:not() .nav-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .game-navigation:not() .nav-item:hover:before {
            left: 100%;
        }

        .game-navigation:not() .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }
 #gameContainer {
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .game-navigation {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            z-index: 1000;
            border-radius: 0;
            background: #ffbf9c;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-right: 0;
        }

        .game-navigation .nav-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 8px;
            flex-direction: row;
            gap: 0;
        }

        #game-content {
            overflow-y: scroll;
        }
  .game-content-panel {
        padding: 35px !important;
    }

  #gameContainer {
        margin: 0;
        width: 100%;
        border-radius: 0;
        background: none;
    }

    #game-content {
        margin-right: 0;
        border-radius: 0;
    }

    #content-outer-container {
        min-height: 0;
        height: calc(100% - 116px);
        overflow-y: scroll;
    }

    #pet-room-container {
        height: calc(100% - 116px);
    }

    .game-content-panel.mobile {
        padding: 20px 15px !important;
    }

    .shop-header h2 {
        font-size: 2.75rem;
    }

    .coin-display {
        gap: 6px;
        font-size: 1.5rem;
        padding: 8px 16px 8px 12px;
    }

    .coin-icon img {
        width: 48px;
        height: 48px;
    }

    #pet-list-owned {
        gap: 10px;
    }

    .pet-section-pet-button-container {
        width: auto;
    }

    .pet-btn {
        width: 110px;
        height: 110px;
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 0 10px;
    }

    .pet-preview {
        position: static;
        height: 90px;
        width: 90px;
        background-size: calc(90px * 16) calc(90px * 26);
    }

    .pet-delete-btn {
        width: 110px;
        font-size: 1.25rem;
        padding: 8px 0;
    }

    .modal-content {
        max-width: 500px;
        font-size: 1.5rem;
    }
    
    .btn-confirm,
    .btn-cancel {
        font-size: 1.5rem;
    }

    .department-btn {
        font-size: 1.5rem;
    }

    #pet-category-select {
        font-size: 1.5rem;
    }

    .item-name {
        font-size: 1.65rem;
    }

    .item-description,
    .pet-supply-use-quantity-label,
    .item-price span {
        font-size: 1.35rem;
    }

    .use-btn,
    .purchase-btn {
        font-size: 1.25rem;
        height: 50px;
    }

    #game-panel {
        margin: 0;
    }

    .pet-stats-selection-button,
    #toggle-edit-save-btn, 
    #cancel-edit-btn,
    #end-preview-button,
    #delete-selected-item-button {
        font-size: 1.5rem;
    }

    .stats-icon {
        height: 32px;
        width: 32px;
    }

    .stat-bar {
        height: 25px;
    }

    .pet-stats-bars {
        width: 300px;
    }

  .segments {
    margin: 0 -25px 0 0 ;
    width: 400px;
  }

  .pet-on-walk-toggle + span {
    height: 40px;
    width: 120px;
  }

  #shop-not-owned-toggle + span {
    height: 48px;
    width: 150px;
  }

  #object-usage-toggle + span {
    height: 48px;
    width: 150px;
  }

  #object-usage-toggle:checked + span {
    width: 100px;
  }

  #shop-not-owned-toggle:checked + span {
    width: 100px;
  }

  .pet-on-walk-toggle + span:after {
    top: 4px;
    left: 5px;
    width: 32px;
    height: 32px;
  }

    #object-usage-toggle + span:after, 
    #shop-not-owned-toggle + span:after {
        top: 4px;
        left: 6px;
        width: 40px;
        height: 40px;
    }

  .pet-on-walk-toggle:checked + span {
    width: 80px;
  }

  .switch-text {
    font-size: 1.25rem;
  }

  :root {
    --unit-size: 30px;
    --original-unit-size: 30px;
    }

    .pet-supply-tab,
    #shop-category-select,
    #object-category-select,
    #object-sidebar-category-select {
        font-size: 1.5rem;
    }

    .no-matching-supplies-message {
        font-size: 1.5rem;
    }

    .tax-records h3 {
        font-size: 2rem;
    }

    .type-icon {
        width: 45px;
        height: 45px;
    }

    .department-icon img {
        height: 32px;
        width: 32px;
    }

    .type-name {
        font-size: 1.75rem;
    }

    #days-remaining-water, 
    #days-remaining-electricity {
        font-size: 1.25rem;
    }

    .record-date {
        font-size: 1.35rem;
    }

    .status-badge {
        font-size: 1.15rem;
    }

    .pay-tax-btn  {
        font-size: 1.5rem;
        min-width: 150px;
    }

    .record-amount {
        font-size: 1.5rem;
    }

    .tax-info {
        font-size: 1.5rem;
    }

    .food-item-preview-holder {
        width: 120px;
        height: 65px;
    }

    .food-item-name-description-holder {
        min-width: 60%;
    }

    .food-item-name  {
        font-size: 1.35rem;
    }

    .item-quantity {
        font-size: 1.25rem;
    }

    .food-item-description {
        font-size: 1.15rem;
    }

    .food-quantity-input {
        height: 25px;
        font-size: 1.25rem;
    }

    .food-use-btn,
    .fill-water-bowl-btn,
    .fill-bath-btn
    .treat-use-btn {
        font-size: 1.25rem;
    }
}


    </style>
</head>
<body>
    <svg xmlns="http://www.w3.org/2000/svg" style="display:none;">

    <!-- water -->
    <symbol id="icon-water" viewBox="0 0 96 96">
        <g id="#64b5f6ff">
        <path fill="#64b5f6" opacity="1.00" d=" M 31.99 30.18 C 37.16 20.67 42.35 11.12 48.76 2.36 C 57.73 16.77 66.41 31.44 73.22 47.02 C 75.73 53.04 78.30 59.36 77.93 66.02 C 77.36 80.86 63.97 94.12 49.01 94.00 C 34.73 94.56 21.39 82.98 19.35 68.95 C 18.54 64.10 19.31 59.13 20.90 54.51 C 23.77 46.05 27.87 38.08 31.99 30.18 M 32.58 60.24 C 30.46 61.20 30.05 63.76 30.31 65.83 C 31.20 73.29 36.80 80.25 44.24 81.99 C 46.29 82.46 48.53 82.66 50.54 81.85 C 52.86 81.00 53.70 77.84 52.41 75.83 C 49.30 73.28 45.05 72.63 42.00 70.02 C 39.91 67.10 39.05 63.50 37.13 60.48 C 35.89 59.36 33.97 59.48 32.58 60.24 Z" />
        </g>
        <g id="#bbdefbff">
        <path fill="#bbdefb" opacity="1.00" d=" M 32.58 60.24 C 33.97 59.48 35.89 59.36 37.13 60.48 C 39.05 63.50 39.91 67.10 42.00 70.02 C 45.05 72.63 49.30 73.28 52.41 75.83 C 53.70 77.84 52.86 81.00 50.54 81.85 C 48.53 82.66 46.29 82.46 44.24 81.99 C 36.80 80.25 31.20 73.29 30.31 65.83 C 30.05 63.76 30.46 61.20 32.58 60.24 Z" />
        </g>
    </symbol>

    <!-- food -->
    <symbol id="icon-food" viewBox="0 0 96 96">
        <g id="#b95e29ff">
        <path fill="#b95e29" opacity="1.00" d=" M 52.26 5.24 C 60.21 1.07 69.72 -1.22 78.52 1.52 C 85.55 3.39 92.19 8.38 94.59 15.43 C 97.03 25.48 93.41 36.16 87.02 44.01 C 83.41 48.23 78.29 50.69 73.61 53.52 C 67.92 56.90 61.47 58.51 55.17 60.30 C 48.91 62.03 43.24 65.32 37.85 68.87 C 36.70 68.31 35.55 67.76 34.42 67.17 C 32.25 65.27 30.12 63.32 27.95 61.42 C 27.06 60.35 25.35 59.53 25.31 58.02 C 26.15 55.78 27.65 53.89 28.77 51.80 C 30.61 48.53 31.36 44.80 32.30 41.20 C 33.38 36.80 34.71 32.46 36.18 28.17 C 36.39 27.79 36.83 27.03 37.05 26.65 L 36.71 25.85 C 39.46 17.56 44.39 9.52 52.26 5.24 M 51.60 15.61 C 47.99 18.30 46.40 22.69 45.04 26.80 C 46.51 28.16 48.47 29.54 50.57 28.73 C 53.60 25.93 54.66 21.50 58.10 19.08 C 61.44 16.66 65.73 16.64 69.54 15.41 C 71.41 14.18 70.50 11.74 69.86 10.08 C 63.28 9.13 56.83 11.78 51.60 15.61 Z" />
        </g>
        <g id="#db824dff">
        <path fill="#db824d" opacity="1.00" d=" M 51.60 15.61 C 56.83 11.78 63.28 9.13 69.86 10.08 C 70.50 11.74 71.41 14.18 69.54 15.41 C 65.73 16.64 61.44 16.66 58.10 19.08 C 54.66 21.50 53.60 25.93 50.57 28.73 C 48.47 29.54 46.51 28.16 45.04 26.80 C 46.40 22.69 47.99 18.30 51.60 15.61 Z" />
        </g>
        <g id="#6a54477e">
        <path fill="#6a5447" opacity="0.49" d=" M 35.85 27.38 C 36.06 27.00 36.49 26.23 36.71 25.85 L 37.05 26.65 C 36.83 27.03 36.39 27.79 36.18 28.17 L 35.85 27.38 Z" />
        </g>
        <g id="#e3d3c3ff">
        <path fill="#e3d3c3" opacity="1.00" d=" M 19.32 69.28 C 22.64 67.18 25.11 64.06 27.95 61.42 C 30.12 63.32 32.25 65.27 34.42 67.17 C 31.71 70.05 28.14 72.47 26.64 76.26 C 26.68 79.79 28.09 83.20 27.80 86.75 C 27.44 89.96 26.23 92.98 25.15 96.00 L 18.13 96.00 C 15.37 93.87 13.83 90.68 12.34 87.62 C 9.99 87.05 7.63 86.45 5.37 85.59 C 1.86 84.46 -0.26 79.99 1.42 76.63 C 3.28 73.44 6.47 70.79 10.23 70.34 C 13.24 69.85 16.41 70.27 19.32 69.28 Z" />
        </g>
    </symbol>

    <!-- love -->
    <symbol id="icon-love" viewBox="0 0 96 96">
        <g id="#f44336ff">
        <path fill="#f44336" opacity="1.00" d=" M 1.83 30.69 C 4.28 21.68 12.15 14.48 21.25 12.55 C 26.95 11.50 33.09 12.04 38.23 14.85 C 42.07 16.91 45.09 20.13 48.01 23.30 C 50.41 20.65 52.83 17.94 55.85 15.97 C 60.32 13.06 65.75 11.81 71.04 12.10 C 80.83 12.50 89.88 19.30 93.43 28.34 C 96.19 35.79 95.26 44.38 91.31 51.22 C 83.77 64.63 71.19 74.09 58.79 82.71 C 55.34 84.91 52.02 87.65 47.98 88.65 C 45.38 88.09 43.15 86.53 40.91 85.16 C 30.80 78.49 20.89 71.27 12.76 62.22 C 8.68 57.68 4.92 52.71 2.73 46.97 C 0.74 41.82 0.49 36.04 1.83 30.69 M 25.25 19.50 C 17.30 20.01 9.63 26.54 9.30 34.77 C 10.25 36.16 11.84 37.42 13.63 37.03 C 16.21 34.83 17.92 31.79 20.53 29.61 C 23.35 27.48 26.86 26.50 29.68 24.36 C 31.03 21.44 28.02 19.08 25.25 19.50 Z" />
        </g>
        <g id="#f76b60ff">
        <path fill="#f76b60" opacity="1.00" d=" M 25.25 19.50 C 28.02 19.08 31.03 21.44 29.68 24.36 C 26.86 26.50 23.35 27.48 20.53 29.61 C 17.92 31.79 16.21 34.83 13.63 37.03 C 11.84 37.42 10.25 36.16 9.30 34.77 C 9.63 26.54 17.30 20.01 25.25 19.50 Z" />
        </g>
    </symbol>
</svg>


    
    <div id="customConfirmModal" class="modal">
    <div class="modal-content">
        <p id="customModalText"></p>
        <div class="modal-buttons">
        <button id="customConfirmYes" class="btn btn-confirm">Taip</button>
        <button id="customConfirmNo" class="btn btn-cancel">Ne</button>
        </div>
    </div>
    </div>

    <div id="object-popup" class="object-popup-overlay" style="display:none;">
    <div class="object-popup-panel">
        <button class="object-popup-close">&times;</button>
        <div class="title-subtitle-inline-button-wrapper">
        <div class="object-popup-title-subtitle-wrapper">
        <div class="object-popup-title" id="object-popup-title"></div>
        <div class="object-popup-subtitle" id="object-popup-subtitle"></div>
        </div>
        </div>
        <div class="object-popup-content" id="object-popup-content">
        <!-- Dynamic content goes here -->
        </div>
    </div>
    </div>

     <nav class="main-navbar" id="mainNavbar">
        <div class="main-nav-container">
            <!-- Logo -->
            <a href="#" class="main-nav-logo">
                <div class="main-nav-logo-icon">
                 <img id="sudedu-main-nav-bar-logo" src="../images/sudedu_logo.png" alt="sudEdu">
                </div>
            </a>

            <!-- Desktop Navigation -->
            <div class="main-nav-links invisible">
                <a href="index.html" class="main-nav-link">Praktika</a>
                <a href="uzduotys.html" class="main-nav-link">Uduotys</a>
                <a href="klase.html" class="main-nav-link">Klas</a>
                <a href="augintiniai.html" class="main-nav-link main-nav-link-active">Augintiniai</a>
                <a href="apie.html" class="main-nav-link">Apie Sudedu</a>
                
                <div class="main-nav-language-dropdown" id="languageDropdown">
                    <button class="main-nav-language-btn" id="languageBtn">
                        <span id="currentLanguage">LT</span>
                        <span class="main-nav-language-arrow"></span>
                    </button>
                    <div class="main-nav-language-menu">
                        <button class="main-nav-language-option selected" data-lang="LT">LT</button>
                        <button class="main-nav-language-option" data-lang="EN">EN</button>
                    </div>
                </div>
                
                
                <div class="main-nav-connect-wrapper">
                    <div class="main-nav-connect-glow"></div>
                    <button class="main-nav-log-out-btn">
                        <span class="main-nav-connect-text">Atsijungti</span>
                    </button>

                    <button class="main-nav-log-in-btn">
                        <span class="main-nav-connect-text">Prisijungti</span>
                    </button>
                </div>
            </div>

            <!-- Mobile Button -->
            <button class="main-nav-mobile-btn" id="mainNavMobileBtn">
                <span class="main-nav-hamburger"></span>
                <span class="main-nav-hamburger"></span>
                <span class="main-nav-hamburger"></span>
            </button>

            <!-- Mobile Menu -->
            <div class="main-nav-mobile-menu" id="mainNavMobileMenu">
                <a href="index.html" class="main-nav-mobile-link">Praktika</a>
                <a href="uzduotys.html" class="main-nav-mobile-link">Uduotys</a>
                <a href="klase.html" class="main-nav-mobile-link">Klas</a>
                <a href="augintiniai.html" class="main-nav-mobile-link active">Augintiniai</a>
                <a href="apie.html" class="main-nav-mobile-link">Apie Sudedu</a>
                
                <div class="main-nav-mobile-language">
                    <button class="language-option language-option-LT selected" onclick="setLanguage('LT')">LT</button>
                    <span class="language-separator">/</span>
                    <button class="language-option language-option-EN" onclick="setLanguage('EN')">EN</button>
                </div>
                
                <button class="main-nav-mobile-log-out-btn">
                    <span class="main-nav-connect-text">Atsijungti</span>
                </button>
                <button class="main-nav-mobile-log-in-btn">
                    <span class="main-nav-connect-text">Prisijungti</span>
                </button>
            </div>
        </div>
    </nav>

    <div id="gameContainer" class="" hidden>
    <nav class="game-navigation">
        <div class="nav-items">
            <button class="nav-item active" id="pet-room-button" data-target="pet-room-container">
                <span class="nav-icon">
                <img src="../images/icons/icon-home.svg">
                </span>
            <span class="nav-label">Namai</span>
            </button>
            <button class="nav-item" data-target="pet-asset-container"><span class="nav-icon">
                <span class="nav-icon">
                <img src="../images/icons/icon-pets.svg">
                </span>
            </span><span class="nav-label">Augintiniai</span></button>
            <button class="nav-item" data-target="furniture-container">
                <span class="nav-icon">
                <img src="../images/icons/icon-furniture.svg">
                </span>
            <span class="nav-label">Baldai</span></button>
            <button class="nav-item" data-target="shop-container">
                <span class="nav-icon">
                <img src="../images/icons/icon-shop.svg">
                </span>
            <span class="nav-label">Parduotuv</span></button>
            <button class="nav-item taxes" data-target="taxes-container">
                <span class="nav-icon taxes-nav-icon">
                <img src="../images/icons/icon-taxes.svg">
                </span>
            <span class="nav-label">Mokesiai</span></button>
        </div>
    </nav>

    <!-- Sidebar Wrapper Structure -->
    <div class="sidebar-wrapper" id="sidebarWrapper">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content" id="sidebarContent">
                <!-- YOUR CONTENT GOES HERE -->
                <div id="dynamic-content">
                    <div class="edit-mode-object-sidebar">
                        <div class="object-sidebar-categories-dropdown-holder">
                            <select id="object-sidebar-category-select"></select>
                        </div>
                        <div class="object-sidebar-assets">
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <button class="toggle-tab" id="toggleTab" aria-label="Toggle sidebar">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M9 18l6-6-6-6"/>
            </svg>
        </button>
    </div>

    <div id="game-content" class="">
        <div id="content-outer-container" class="hide-scrollbar">
            <div id="pet-room-container" class="game-content-panel active">

            <div id="game-panel">
            <div class="pet-buttons-and-stats-holder">
            <div id="pet-buttons-outer">
            <div id="pet-buttons-outer">
                <div id="pet-buttons"></div>
                <div id="pet-on-walk-checkbox-holder"></div>
            </div>
        
            </div>
            <div class="stats-and-upper-controls-holder">
            <div class="pet-stats-bars">
                <div class="stats-bar-outer">
                    <div class="stats-bar-icon">
                        <svg class="stats-icon">
                            <use href="#icon-food"></use>
                        </svg>
                        </div>
                    <div class="stat-bar" id="food-bar" role="progressbar" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
                        <div class="segments"></div>
                    </div>
                </div>

                <div class="stats-bar-outer">
                    <div class="stats-bar-icon">
                        <svg class="stats-icon">
                            <use href="#icon-water"></use>
                        </svg>
                    </div>
                    <div class="stat-bar" id="water-bar" role="progressbar" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
                        <div class="segments"></div>
                    </div>
                </div>

                <div class="stats-bar-outer">
                    <div class="stats-bar-icon">
                        <svg class="stats-icon">
                            <use href="#icon-love"></use>
                        </svg>
                    </div>
                    <div class="stat-bar" id="love-bar" role="progressbar" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
                        <div class="segments"></div>
                    </div>
                </div>
            </div>

            <div class="upper-controls-holder">
                <div class="main-coin-display-holder">
                    <div class="coin-display main">
                        <span class="coin-icon">
                            <img src="../images/icons/icon-sudedu-coin.png">
                        </span>
                        <span class="coin-amount"></span>
                    </div>
                </div>
                <div class="upper-controls-inner-holder">
                    <button id="toggle-zoom-lock-btn" class="viewport-control-btn">
                        <span>
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                                <path d="M240-160h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Zm0 80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h280v-80q0-83 58.5-141.5T720-920q83 0 141.5 58.5T920-720h-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80h120q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Z"/>
                            </svg>
                        </span>
                    </button>
                    <button id="toggle-expand-btn" class="viewport-control-btn" onclick="toggleRoomExpansion()">
                        <span>
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                                <path d="M120-120v-320h80v184l504-504H520v-80h320v320h-80v-184L256-200h184v80H120Z"/>
                            </svg>
                        </span>
                    </button>
                </div>
            </div>
            </div>


            </div>

                <div id="viewport-container">
                    <div id="scale-wrapper" style="transform-origin: 0 0;">
                        <div id="room-transform-wrapper">
                            <div id="room-container">
                        <div id="roomGridContainer">
                            <div id="" style="width: 504px; height: 420px;">
                                <canvas id="roomGrid" style="user-select: none; display: block;"></canvas>
                            </div>

                        </div>
                        <div id="roomObjectsContainer"></div>
                        <div id="petContainer"></div>
                    </div>
                    </div>
                </div>
            </div>
            <div id="button-container">
                <div>
                <button id="toggle-edit-save-btn" class="edit">Perstatyti</button>
                <button id="cancel-edit-btn" class="cancel hidden">Ataukti</button>
                <button id="end-preview-button" class="cancel hidden">Baigti perir</button>
                </div>

                <div>
                <button id="delete-selected-item-button" class="cancel hidden" disabled>Trinti</button>
                </div>
            </div>
            </div>
            </div>

      <div id="shop-container" class="game-content-panel">
    <div class="shop-header" id="shopHeader">
        <div class="header-main">
            <div class="header-left">
                <button class="expand-toggle" id="expandToggle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 15l-6-6-6 6"/>
                    </svg>
                </button>
                <h2>Parduotuv</h2>
            </div>
            <div class="coin-display">
                <span class="coin-icon">
                    <img src="../images/icons/icon-sudedu-coin.png">
                </span>
                <span class="coin-amount"></span>
            </div>
        </div>
        
        <div class="collapsible-content" id="collapsibleContent">
            <div class="shop-departments">
                <button class="department-btn">
                    <span class="department-icon">
                        <span class="department-icon">
                            <img src="../images/icons/icon-pet-supplies.svg">
                        </span>
                    </span>
                    <span class="department-label">Reikmenys</span>
                </button>
                
                <button class="department-btn">
                    <span class="department-icon">
                        <span class="nav-icon">
                            <img src="../images/icons/icon-furniture.svg">
                        </span>
                    </span>
                    <span class="department-label">Baldai</span>
                </button>
                <button class="department-btn">
                    <span class="department-icon">
                        <span class="nav-icon">
                            <img src="../images/icons/icon-animals.svg">
                        </span>
                    </span>
                    <span class="department-label">Gyvnliai</span>
                </button>
            </div>

            <div id="shop-buttons">
                <!-- Pet list (only shown for Maistas) -->
                <div id="pet-list-shop" class="pet-list hidden"></div>

                <!-- Maistas tabs (only shown for Maistas) -->
                <div id="pet-supplies-tabs" class="pet-supplies-tabs hidden">
                    <button class="pet-supply-tab active" data-type="supplies">
                        <span class="department-icon">
                            <img src="../images/icons/icon-pet-food.svg">
                        </span>
                        <span class="tab-label">Maistas</span>
                    </button>
                    <button class="pet-supply-tab" data-type="skins">
                        <span class="department-icon">
                            <img src="../images/icons/icon-pet-skins.svg">
                        </span>
                        <span class="tab-label">Ivaizda</span>
                    </button>
                </div>
            </div>

            <div class="categories-dropdown-holder">
                <select id="shop-category-select"></select>
            
                <div class="shop-not-owned-holder">
                    <label class="switch"><input type="checkbox" id="shop-not-owned-toggle" class="shop-not-owned-toggle">
                        <span class="switch-slider">
                            <span class="switch-text switch-text-shop">
                                NETURIU
                            </span>
                        </span>
                    </label>
                </div>
            </div>
        </div>
    </div>
    
    <div class="shop-items" id="shop-items"></div>
</div>

    <div id="pet-asset-container" class="game-content-panel">
    <div class="shop-header" id="petAssetHeader">
        <div class="header-main">
            <div class="header-left">
                <button class="expand-toggle" id="petAssetExpandToggle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 15l-6-6-6 6"/>
                    </svg>
                </button>
                <h2>Augintiniai</h2>
            </div>
            <div class="coin-display">
                <span class="coin-icon">
                    <img src="../images/icons/icon-sudedu-coin.png">
                </span>
                <span class="coin-amount"></span>
            </div>
        </div>
        
        <div class="collapsible-content" id="petAssetCollapsibleContent">
                

                <div id="pet-asset-buttons">
                <div id="pet-list-owned"></div>
                <div id="pet-asset-buttons-departments-dropdown">
                <div class="pet-asset-supply-tabs">
                <button class="department-btn pet-asset-supply-button active">
                    <span class="department-icon">
                        <img src="../images/icons/icon-pet-food.svg">
                    </span>
                    <span class="department-label">Maistas</span>
                </button>
                <button class="department-btn pet-asset-supply-button">
                    <span class="department-icon">
                        <img src="../images/icons/icon-pet-skins.svg">
                    </span>
                    <span class="department-label">Ivaizda</span>
                </button>
                </div>
                    </div>
                </div>
                <div class="categories-dropdown-holder">
                        <select id="pet-category-select" style="display: none;"></select>
                </div>
                    </div>
                </div>
                <div id="pet-skins"></div>
                <div id="pet-supplies">
                    <div id="pet-supplies-items"></div>
                </div>
                <div class="pet-categories-dropdown"></div>
        </div> 
    

            <div id="taxes-container" class="game-content-panel">
            
            <div class="shop-header" id="taxesHeader">
                <div class="header-main">
                    <div class="header-left">
                        <h2>Mokesiai</h2>
                    </div>
                    <div class="coin-display">
                        <span class="coin-icon">
                            <img src="../images/icons/icon-sudedu-coin.png">
                        </span>
                        <span class="coin-amount"></span>
                    </div>
                </div>
            
                </div>
                <div class="tax-section-inner-holder hide-scrollbar">
                <div class="tax-records">
                    <h3>Mokesi sraas</h3>
                    <div class="records-list">
                        <div class="tax-record">
                            <div class="record-info water-tax">
                                <div class="record-type"><span class="type-icon">
                                <span class="department-icon">
                                    <img src="../images/icons/icon-tax-water.svg">
                                </span>
                                </span><span class="type-name">Vandens mokestis</span><span id="days-remaining-water"></span></div>
                                <div class="record-details"><span class="record-date"></span><span class="record-amount" id="water-tax-cost"></span></div>
                            </div>
                            <div class="tax-status-and-pay-btn-holder">
                            <div class="record-status"><span class="status-badge"></span></div>
                            <div class="record-actions">
                                <button class="pay-tax-btn water"></button>
                            </div>
                            </div>
                        </div>
                        <div class="tax-record">
                            <div class="record-info electricity-tax">
                                <div class="record-type"><span class="type-icon">
                                <span class="department-icon">
                                    <img src="../images/icons/icon-tax-electricity.svg">
                                </span>
                                </span><span class="type-name">Elektros mokestis</span><span id="days-remaining-electricity"></span></div>
                                <div class="record-details"><span class="record-date"></span><span class="record-amount" id="electricity-tax-cost"></span></div>
                            </div>
                            <div class="tax-status-and-pay-btn-holder">
                            <div class="record-status"><span class="status-badge"></span></div>
                            <div class="record-actions">
                                <button class="pay-tax-btn electricity"></button>
                            </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="tax-info">
                    <h3>Mokesi informacija</h3>
                    <div class="info-cards">
                        <div class="info-card">
                            <h4><span class="department-icon">
                                    <img src="../images/icons/icon-tax-water.svg">
                                </span> Vandens mokestis</h4>
                            <p>Vanduo reikalingas augintinams girdyti ir prausti.</p>
                        </div>
                        <div class="info-card">
                            <h4><span class="department-icon">
                                    <img src="../images/icons/icon-tax-electricity.svg">
                                </span> Elektros mokestis</h4>
                            <p>Elektra reikalinga viesai ir elektros prietaisams.</p>
                        </div>
                    </div>
                </div>
                </div>


            </div>

            <div id="furniture-container" class="game-content-panel">
            <div class="shop-header" id="furnitureHeader">
                <div class="header-main">
                    <div class="header-left">
                        <button class="expand-toggle" id="furnitureExpandToggle">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 15l-6-6-6 6"/>
                            </svg>
                        </button>
                        <h2>Baldai</h2>
                    </div>
                    <div class="coin-display">
                        <span class="coin-icon">
                            <img src="../images/icons/icon-sudedu-coin.png">
                        </span>
                        <span class="coin-amount"></span>
                    </div>
                </div>
                
                <div class="collapsible-content" id="furnitureCollapsibleContent">
                <div class="shop-categories-dropdown">
                    <div class="categories-dropdown-holder">
                        <select id="object-category-select"></select>
                            <div class="object-usage-toggle-holder">
                            <label class="switch"><input type="checkbox" id="object-usage-toggle" class="object-usage-toggle">
                                <span class="switch-slider">
                                    <span class="switch-text switch-text-object">
                                        NENAUD.
                                    </span>
                                </span>
                            </label>
                        </div>
                    </div>
                    </div>
                    </div>
                    </div>
                    <div class="object-assets">

                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../mental-arithmetic.js"></script>
    <script src="../main-nav-bar.js"></script>
    <script>
        
        // ITEMS THAT ARE IGNORED WHEN DETERMINED PLACEMENT / ITEM REMOVAL etc. (such as flooring, carpets, wallpapers)
        const PLACING_INDEXES_TO_BE_IGNORED = new Set([5, 6, 9, 10, 14]);
        const COST_MULTIPLIER = 1

        const topHalfClickBlockedItemClasses = ["bath-1"]
        const clickPassesTroughClasses = ["christmas-tree-1"];

        if (!userData || userData?.accType === "teacher") {
            window.location.href = './';
        }

        let viewportState = {
            scale: 1,
            x: 10,
            y: 10,
            minScale: 0.5,
            maxScale: 1,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            spacePressed: false,
            lastMouseX: 0,
            lastMouseY: 0,
            zoomLocked: false,
            closestTile: [0, 0]
        };

        // Set different zoom limits based on device
        const width = window.innerWidth;
        const isTabletPortrait = width >= 768 && width <= 1200 && 
                                window.matchMedia('(orientation: portrait)').matches;

        if (width <= 767) {  // Mobile phones
            viewportState.maxScale = 1.5
        } else if (isTabletPortrait) {  // Tablets in portrait mode
            viewportState.scale = 0.58
            viewportState.maxScale = 0.68
        }

        let unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
        let gameAssetIndex = {};
        let roomLayoutNumber;
        let roomLayout;
        let userPetAssets = {};
        let userMoney = 0;
        let selectedConsumable = [];
        let pendingPetActions = {};
        let petControllers = {};
        let petStatsList = '';
        let taxesData = {}
        let globalWalkabilityMap;
        const taxPaymentPeriod = 14 //days
        const taxGracePeriod = 2 //days;
        const taxPrice = {
            "waterTax": 18 * COST_MULTIPLIER,
            "electricityTax": 18 * COST_MULTIPLIER
        }
        let petOnWalk = "";
        const speciesTranslationDict = {
            "cat": "kat"
        }
        const receivedMessages = [];
        let multiTouchActive = false;

        function convertUserPetAssetsDictToCompactList(data) {
            let pets = Object.entries(data.pets).map(([p, v]) => [
                p,
                [
                    v.name, // real pet name
                    Object.entries(v.skins).map(([s, d]) => [s, d.assetIndex, d.equiped])
                ]
            ]);
            let supplies = Object.values(data.supplies).map(s => [s.assetIndex, s.quantity]);
            return [pets, supplies];
        }

        function renderPets() {
            const petContainer = document.getElementById("petContainer");

            if (!petContainer) return;
            petContainer.innerHTML = ''; // clear existing content

            const pets = userPetAssets.pets;

            let itemsInUse = [];

            globalWalkabilityMap = generateWalkabilityMap();

            for (const petNumber in pets) {
                const petDict = pets[petNumber];
                const skins = petDict.skins;
                let petCoords = getObjectCoordinates(petDict.id);
                let petStaringPosTop;
                let petStartingPosLeft;
                
                
                const petSpecies = petNumber.split('-')[0]
                const matchingBeds = Array.from(roomObjectsContainer.querySelectorAll("*")).filter(el => {
                    const classStr = el.className; // full class string
                    return classStr.includes("bed") && classStr.includes(petSpecies) && !classStr.includes("furniture-preview") && !itemsInUse.includes(el.id);
                });

                let equippedSkin = Object.values(skins).find(skin => skin.equiped);
                
                if (!equippedSkin) {
                    const firstSkinKey = Object.keys(skins)[0];
                    equippedSkin = skins[firstSkinKey];
                    equippedSkin.equiped = true;
                    sendPetAssetsUpdateToDatabase();
                }

                const petDiv = document.createElement('div');
                const petClasses = gameAssetIndex[equippedSkin.assetIndex]["css-class"];
                petDiv.id = petClasses.split(' ')[0];
                petDiv.className = petClasses;
                petContainer.appendChild(petDiv);
                
                if (matchingBeds.length > 0) {
                    const randomIndex = Math.floor(Math.random() * matchingBeds.length);
                    object = matchingBeds[randomIndex];
                    itemsInUse.push(object.id);
                    
                    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]?.assetIndex]?.["interactive-spot"];

                    let objectCoords = getObjectCoordinates(object.id);

                    [petStartingPosLeft, petStaringPosTop] = [...objectCoords]; // base coordinates

                    if (Array.isArray(objectInteractivePart) && objectInteractivePart.length >= 2) {
                        petStartingPosLeft += objectInteractivePart[0];
                        petStaringPosTop  -= objectInteractivePart[1];
                    }

                } else {
                    const pet = document.getElementById(petNumber);
                    const validCoords = findValidPlacements(globalWalkabilityMap, pet);

                    if (validCoords.length === 0) {
                        return;
                    }

                    // Pick a random coordinate
                    const randomIndex = Math.floor(Math.random() * validCoords.length);
                    const randomCoord = validCoords[randomIndex];
                    const petPos = getObjectCoordinates(pet.id)

                    petStartingPosLeft = randomCoord[0];
                    petStaringPosTop = randomCoord[1];
                }


                petDiv.style.top = `calc((${petStaringPosTop} * var(--unit-size)) - (var(--pet-size) - var(--unit-size)))`;
                petDiv.style.left = `calc(${petStartingPosLeft} * var(--unit-size))`;

                setPetZIndex(petDiv);

                setObjectAnimation(petDiv, `${petNumber}-sleeps`)
            }

            Object.entries(petStatsList).forEach(([petId, stats]) => {
            if (userPetAssets.pets?.[petId]) {
                const petSpecies = petId.split("-")[0];
                const bonusStats = bonusFromDailySupplyItems();
                const el = document.getElementById(petId);
                if (!el) {
                    console.warn(`Pet element not found in DOM: ${petId}`);
                    return;
                }

                const currentTime = Math.floor(Date.now() / 1000 / 60);
                const timeElapsed = currentTime - stats[3];
                const statDecrease = Math.floor(timeElapsed * PET_STATS_EXPIRATION);

                const food = Math.max(bonusStats[petSpecies]?.food ?? 0, stats[0] - statDecrease);
                const water = Math.max(bonusStats[petSpecies]?.water ?? 0, stats[1] - statDecrease);
                const love = Math.max(bonusStats[petSpecies]?.love ?? 0, stats[2] - statDecrease);
                const date = currentTime;

                el._stats = {
                    food: food,
                    water: water,
                    love: love,
                    date: currentTime,
                    foodNew: food,
                    waterNew: water,
                    loveNew: love,
                    };
                }
            });

        
            // Create default stats for any pets that exist but don't have stats yet
            Object.keys(userPetAssets.pets || {}).forEach(petId => {
                if (!document.getElementById(petId)._stats) {
                    document.getElementById(petId)._stats = {
                        "food": 10,
                        "water": 10,
                        "love": 10,
                        "date": Math.floor(Date.now() / 1000 / 60),
                        "foodNew": 10,
                        "waterNew": 10,
                        "loveNew": 10,
                    }

                    sendPetStatsUpdateToDatabase(petId);
                }
            });

            createPetButtons();
            
            const allPets = document.querySelectorAll("#petContainer .pet");
            if (allPets[0]) {
                displayPetStats(allPets[0].id);
            }
        }

        let userObjectAssets = {};

        // 1.0 - floor
        // 2.0 - wall
        // 3.0 - boundary between wall and floor, 
        // 4.1 - horizontal edge, 4.2 - vertical edge, 
        // 4.31 - top left corner, 4.32 - top right corner, 4.33 - bottom right corner, 4.34 - bottom left corner, 
        // 4.41 - T junction top, 4.42 - T junction right, 4.43 - T junction bottom, 4.44 - T junction left, 
        // 4.51 - downward-facing wall end, 4.52 - left-facing wall end, 4.53 - upward-facing wall end, 4.54 - right-facing wall end
        // 5.0 - threshold
        // 6.0 - stairs
        // 7.0 - void


        //[4.3, ...Array(20).fill(4.1),4.4] - border with edges and horizontal line filled to set number (20)
        //...Array(6).fill([4.2, ...Array(20).fill(2.0), 4.2]) - multiple rows of wall tiles with edges at the end 6 rows of 20 wall tiles and 2 borders at ends
        
        /*
        const roomLayout = [
          [4.31, ...Array(40).fill(4.1), 4.32],
          ...Array(12).fill([4.2, ...Array(40).fill(2.0), 4.2]),
          [4.2, ...Array(40).fill(3.0), 4.2],
          ...Array(20).fill([4.2, ...Array(40).fill(1.0), 4.2]),
          [4.34, ...Array(40).fill(4.1), 4.33],
        ];
        */

        const roomLayoutLibrary = {
            1: [
                [4.31, ...Array(40).fill(4.1), 4.32],
                ...Array(12).fill([4.2, ...Array(40).fill(2.0), 4.2]),
                [4.2, ...Array(40).fill(3.0), 4.2],
                ...Array(20).fill([4.2, ...Array(40).fill(1.0), 4.2]),
                [4.34, ...Array(40).fill(4.1), 4.33],
            ],
            2: [
                // Top part of floor 2
                [4.31, ...Array(40).fill(4.1), 4.41, ...Array(40).fill(4.1), 4.32],
                ...Array(12).fill([4.2, ...Array(40).fill(2.0), 4.2, ...Array(40).fill(2.0), 4.2]),
                [4.2, ...Array(40).fill(3.0), 4.2, ...Array(40).fill(3.0), 4.2],
                ...Array(2).fill([4.2, ...Array(40).fill(1.0), 4.2, ...Array(40).fill(1.0), 4.2]),

                // Part at the door of floor 2
                ...Array(1).fill([4.2, ...Array(40).fill(1.0), 4.51, ...Array(40).fill(1.0), 4.2]),
                ...Array(6).fill([4.2, ...Array(40).fill(1.0), 5.0, ...Array(40).fill(1.0), 4.2]),
                ...Array(1).fill([4.2, ...Array(40).fill(1.0), 4.53, ...Array(40).fill(1.0), 4.2]),

                // Lower part of floor 2
                ...Array(10).fill([4.2, ...Array(40).fill(1.0), 4.2, ...Array(40).fill(1.0), 4.2]),

                // Entrance to stairs floor 2
                [4.34, ...Array(24).fill(4.1), 4.32, ...Array(6).fill(6.0), 4.31, ...Array(8).fill(4.1), 4.43, ...Array(40).fill(4.1), 4.33],
                
                // Stairs and void
                ...Array(8).fill([...Array(25).fill(7.0), 4.2, ...Array(6).fill(6.0), 4.2, ...Array(8).fill(7.0), ...Array(42).fill(7.0)]),

                // Stairs and wall of floor 1
                [4.31, ...Array(24).fill(4.1), 4.42, ...Array(6).fill(6.0), 4.44, ...Array(8).fill(4.1), 4.41, ...Array(40).fill(4.1), 4.32],

                // Top part of floor 1, stairs and wall
                ...Array(12).fill([4.2, ...Array(24).fill(2.0), 4.2, ...Array(6).fill(6.0), 4.2, ...Array(8).fill(2.0), 4.2, ...Array(40).fill(2.0), 4.2]),
                
                // Top part of floor 1, stairs and boundary
                [4.2, ...Array(24).fill(3.0), 4.2, ...Array(6).fill(6.0), 4.2, ...Array(8).fill(3.0), 4.2, ...Array(40).fill(3.0), 4.2],

                // Part at the door of floor 1
                ...Array(1).fill([4.2, ...Array(40).fill(1.0), 4.51, ...Array(40).fill(1.0), 4.2]),
                ...Array(5).fill([4.2, ...Array(40).fill(1.0), 5.0, ...Array(40).fill(1.0), 4.2]),
                ...Array(1).fill([4.2, ...Array(40).fill(1.0), 4.53, ...Array(40).fill(1.0), 4.2]),

                // Bottom part of floor 1
                ...Array(13).fill([4.2, ...Array(40).fill(1.0), 4.2, ...Array(40).fill(1.0), 4.2]),
                [4.34, ...Array(40).fill(4.1), 4.43, ...Array(40).fill(4.1), 4.33],
            ]
        }

        const roomGrid = document.getElementById('roomGrid');
        const ctx = roomGrid.getContext('2d');
        const tileSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

        async function renderRoomGrid(offsetX = 0, offsetY = 0, scale = 1) {
            if (!roomLayoutNumber) return
            roomLayout = roomLayoutLibrary[roomLayoutNumber];

            resizeCanvas();

            const canvas = document.getElementById('roomGrid');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const cols = roomLayout[0].length;
            const rows = roomLayout.length;
            const tileSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

            // Set canvas size based on grid
            canvas.width = cols * tileSize;
            canvas.height = rows * tileSize;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const type = roomLayout[row][col];
                    const x = col * tileSize;
                    const y = row * tileSize;

                    // Fill color
                    let fillColor;
                    switch(type) {
                        case 1.0: fillColor = '#DEB887'; break; // floor
                        case 2.0: fillColor = '#F0EAD6'; break; // wall
                        case 3.0: fillColor = '#B37B50'; break; // boundary
                        case 4.1: case 4.2: 
                        case 4.31: case 4.32:case 4.33: case 4.34: 
                        case 4.41: case 4.42: case 4.43: case 4.44: 
                        case 4.51: case 4.52: case 4.53: case 4.54: 
                            fillColor = '#A77851'; break; // edges
                        case 5.0: fillColor = '#b8966c'; break;
                        case 6.0: fillColor = "#5C4033"; break
                        case 7.0: fillColor = "transparent"; break
                        default: fillColor = '#fff';
                    }
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(x, y, tileSize, tileSize);

                    // Define borders per tile type
                    let sides = [false, false, false, false]; // [top, right, bottom, left]
                    let strokeColor = '#000';
                    let lineWidth = 1;

                    switch(type) {
                        case 1.0: // floor
                            sides = [true, true, true, true];
                            strokeColor = 'grey';
                            lineWidth = 0.2;
                            break;
                        case 2.0: // wall - full thick border
                            sides = [true, true, true, true];
                            strokeColor = 'grey';
                            lineWidth = 0.2;
                            break;
                        case 3.0: // boundary
                            sides = [true, true, true, true];
                            strokeColor = 'grey';
                            lineWidth = 0.2;
                            break;
                        case 4.1: // horizontal edge
                            sides = [true, false, true, false]; // top & bottom
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.2: // vertical edge
                            sides = [false, true, false, true]; // left & right
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.31: // top-left corner
                            sides = [true, false, false, true];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.32: // top-right corner
                            sides = [true, true, false, false];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.33: // bottom-right corner
                            sides = [false, true, true, false];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.34: // bottom-left corner
                            sides = [false, false, true, true];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.41: // T junction top
                            sides = [true, false, false, false];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.42: // T junction right
                            sides = [false, true, false, false];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.43: // T junction bottom
                            sides = [false, false, true, false];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.44: // T junction left
                            sides = [false, false, false, true];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.51: // downward-facing end
                            sides = [false, true, true, true];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.52: // left-facing wall end
                            sides = [true, false, true, true];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.53: // upward-facing wall end
                            sides = [true, true, false, true];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 4.54: // right-facing wall end
                            sides = [true, true, true, false];
                            strokeColor = '#000';
                            lineWidth = 1;
                            break;
                        case 5.0: // floor / threshold
                            sides = [true, true, true, true];
                            strokeColor = 'black';
                            lineWidth = 0.2;
                            break;
                        case 6.0: // right-facing wall end
                            sides = [false, false, true, false];
                            strokeColor = 'black';
                            lineWidth = 1;
                            break;
                    }

                    // Draw borders manually
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    if (sides[0]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + tileSize, y); ctx.stroke(); } // top
                    if (sides[1]) { ctx.beginPath(); ctx.moveTo(x + tileSize, y); ctx.lineTo(x + tileSize, y + tileSize); ctx.stroke(); } // right
                    if (sides[2]) { ctx.beginPath(); ctx.moveTo(x, y + tileSize); ctx.lineTo(x + tileSize, y + tileSize); ctx.stroke(); } // bottom
                    if (sides[3]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + tileSize); ctx.stroke(); } // left
                }
            }

            ctx.restore();
        }


function resizeCanvas() {
    const canvas = document.getElementById('roomGrid');
    const container = canvas.parentElement;

    // Calculate room dimensions
    const cols = roomLayout[0].length;
    const rows = roomLayout.length;
    const tileSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    
    // Set canvas to room size (not container size)
    canvas.width = cols * tileSize;
    canvas.height = rows * tileSize;
}

// Call on window resize
window.addEventListener('resize', resizeCanvas);

        async function setPetAndObjectContainersToGridDimentions() {
            const roomGrid = document.getElementById('roomGrid');

            const width = roomGrid.offsetWidth;
            const height = roomGrid.offsetHeight;

            const roomContainer = document.getElementById('room-container');
            const petContainer = document.getElementById('petContainer');
            const roomObjectsContainer = document.getElementById('roomObjectsContainer');

            // Add 'px' to make it valid CSS
            roomContainer.style.width = width + "px";
            roomContainer.style.height = height + "px";
            
            petContainer.style.width = width + "px";
            petContainer.style.height = height + "px";

            roomObjectsContainer.style.width = width + "px";
            roomObjectsContainer.style.height = height + "px";
        }

// Function to render assets into the container
function renderRoomObjects() {
    const roomObjectsContainer = document.querySelector("#roomObjectsContainer");
    roomObjectsContainer.innerHTML = '';

    Object.entries(userObjectAssets).forEach(([key, asset]) => {
        if (asset.position.length !== 0) {
            const [x, y] = asset.position;
            const div = document.createElement("div");
            roomObjectsContainer.appendChild(div);
            div.className = `room-object ${gameAssetIndex[asset.assetIndex]["css-class"]}`;
            div.id = key;
            div.style.left = `calc(${x} * var(--unit-size))`;
            div.style.top = `calc((${y + 1} * var(--unit-size)) - ${div.offsetHeight}px)`;
        }
    });

    if (furniturePreviewDict["furniture-preview"].assetIndex) {
        if (furniturePreviewDict["furniture-preview"].position.length !== 0) {
            const [x, y] = furniturePreviewDict["furniture-preview"].position;
            const div = document.createElement("div");
            roomObjectsContainer.appendChild(div);
            div.className = `room-object furniture-preview ${gameAssetIndex[furniturePreviewDict["furniture-preview"].assetIndex]["css-class"]}`;
            div.id = 'furniture-preview';
            div.style.left = `calc(${x} * var(--unit-size))`;
            div.style.top = `calc((${y + 1} * var(--unit-size)) - ${div.offsetHeight}px)`;
        }
    }
    
    disableObjectDragging();
}

function toggleRoomDarknessBasedOnElectricityTax() {
    const room = document.getElementById("room-container");
    if (!taxesData.electricityTax.paid) {
        room.classList.add("dark");
        messageToTheUser("Nra viesos! Sumokk elektros mokest.")
    } else {
        // only remove if it exists
        if (room.classList.contains("dark")) {
            room.classList.remove("dark");
        }
    }
}

async function initGame() {
    adjustUnitSizeForSmallScreens();
    await new Promise(resolve => requestAnimationFrame(resolve));
    await renderRoomGrid();
    
    // ADD: Extra safety delay for canvas rendering
    await new Promise(resolve => setTimeout(resolve, 50));
    
    await setPetAndObjectContainersToGridDimentions();
    
    // ADD: Validate room loaded before proceeding
    if (!roomLayout || roomLayout.length === 0) {
        throw new Error("Room layout not initialized");
    }
    
    renderRoomObjects();
    blockTopHalfOfSelectedDivsClickEvents();
    makeSelectedClickThrough();
    
    // NO VALIDATION HERE - let placement logic run first
    
    renderPets();
    enablePetDragging();
    updateCoinAmounts(userMoney);
    taxesNavChoiceIndicator();
    bonusFromDailySupplyItems();
    toggleRoomDarknessBasedOnElectricityTax();

    initializeRoomZIndexes();

    initViewportControls();

    const shopEl = document.querySelector(".switch-text-shop");
    if (shopEl) shopEl.textContent = "NETURIU";

    const objEl = document.querySelector(".switch-text-object");
    if (objEl) objEl.textContent = "NENAUD.";

    petControllers = {};
    pendingPetActions = {};

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        managePetActions(pet);
    });
}

async function validateAndFixObjectPositions() {
    const roomObjectsContainer = document.getElementById('roomObjectsContainer');
    if (!roomObjectsContainer) return false;
    
    const objects = roomObjectsContainer.querySelectorAll('.room-object:not(.furniture-preview)');
    const invalidObjects = [];
    
    objects.forEach(obj => {
        const coords = getObjectCoordinates(obj.id);
        
        // Check if coordinates exist and are valid
        if (!coords || coords.length !== 2) {
            console.warn(`Invalid coordinates for ${obj.id}`);
            invalidObjects.push(obj.id);
            return;
        }
        
        const [x, y] = coords;
        
        // Check if within room bounds
        if (x < 0 || y < 0 || y >= roomLayout.length || x >= roomLayout[0].length) {
            console.warn(`Object ${obj.id} outside bounds: [${x}, ${y}]`);
            invalidObjects.push(obj.id);
            return;
        }
        
        // Check if on valid tile type
        const tileType = roomLayout[y]?.[x];
        if (tileType === undefined) {
            console.warn(`Object ${obj.id} on undefined tile at [${x}, ${y}]`);
            invalidObjects.push(obj.id);
            return;
        }
        
        const type = tileType?.type ?? tileType;
        const validTypes = [1.0, 2.0, 3.0, 5.0, 6.0];
        
        if (!validTypes.includes(type)) {
            console.warn(`Object ${obj.id} on invalid tile type ${type} at [${x}, ${y}]`);
            invalidObjects.push(obj.id);
        }
    });
    
    // If invalid objects found, trigger reload
    if (invalidObjects.length > 0) {
        console.warn(`Found ${invalidObjects.length} invalid object positions`);
        return false;
    }
    
    return true;
}

let initAttempts = 0;
const maxAttempts = 3;

async function attemptGameInit() {
    showRoomLoading();
    
    try {
        initAttempts++;
        console.log(`Init attempt ${initAttempts}/${maxAttempts}`);
        
        await initGame();
        
        // Give placement logic time to position new objects
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Validate object positions are on valid tiles
        const objectsValid = await validateAndFixObjectPositions();
        if (!objectsValid) {
            throw new Error("Object positions invalid after placement");
        }
        
        // NEW: Wait for any final rendering/layout to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // NEW: Verify rendered positions match saved data
        const positionsMatch = await verifyObjectPositionsMatchData();
        if (!positionsMatch) {
            console.log("Position discrepancies detected and corrected");
        }
        
        // Validate pet positions
        await validatePetPositions();
        
        initAttempts = 0;
        console.log("Game initialized successfully");
        
        hideRoomLoading();
        
    } catch (error) {
        console.log(`Init attempt ${initAttempts} failed:`, error);
        
        if (initAttempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 500));
            console.log("Retrying initialization...");
            await attemptGameInit();
        } else {
            console.error("Max attempts reached, removing invalid objects");
            await removeInvalidObjectsAndSave();
            await initGame();
            hideRoomLoading();
        }
    }
}

async function verifyObjectPositionsMatchData() {
    const roomObjectsContainer = document.getElementById('roomObjectsContainer');
    if (!roomObjectsContainer) return true;
    
    const objects = roomObjectsContainer.querySelectorAll('.room-object:not(.furniture-preview)');
    let discrepanciesFound = false;
    
    for (const obj of objects) {
        const renderedCoords = getObjectCoordinates(obj.id);
        const savedPosition = userObjectAssets[obj.id]?.position;
        
        if (!savedPosition || savedPosition.length !== 2) {
            console.warn(`${obj.id}: No valid saved position`);
            continue;
        }
        
        const [savedX, savedY] = savedPosition;
        
        if (!renderedCoords || renderedCoords.length !== 2) {
            console.error(`${obj.id}: Invalid rendered coordinates`);
            discrepanciesFound = true;
            continue;
        }
        
        const [renderedX, renderedY] = renderedCoords;
        
        // Allow 1-tile tolerance for rounding differences
        const xDiff = Math.abs(renderedX - savedX);
        const yDiff = Math.abs(renderedY - savedY);
        
        if (xDiff > 1 || yDiff > 1) {
            console.error(`Position mismatch for ${obj.id}:`, {
                saved: [savedX, savedY],
                rendered: [renderedX, renderedY],
                difference: [xDiff, yDiff]
            });
            discrepanciesFound = true;
            
            // Force correct position
            const leftPx = savedX * unitSize;
            const bottomPx = (savedY + 1) * unitSize;
            const topPx = bottomPx - obj.offsetHeight;
            
            obj.style.left = `${leftPx}px`;
            obj.style.top = `${topPx}px`;
            
            console.log(`Corrected ${obj.id} to saved position`);
        }
    }
    
    return !discrepanciesFound;
}

function showRoomLoading() {
    const roomContainer = document.getElementById('room-container');
    const viewport = document.getElementById('viewport-container');
    
    if (roomContainer) {
        roomContainer.style.opacity = '0';
        roomContainer.style.pointerEvents = 'none';
    }
    if (viewport) {
        viewport.style.pointerEvents = 'none';
    }
}

function hideRoomLoading() {
    const roomContainer = document.getElementById('room-container');
    const viewport = document.getElementById('viewport-container');
    
    if (roomContainer) {
        roomContainer.style.opacity = '1';
        roomContainer.style.pointerEvents = 'auto';
    }
    if (viewport) {
        viewport.style.pointerEvents = 'auto';
    }
}

async function validatePetPositions() {
    const petContainer = document.getElementById('petContainer');
    if (!petContainer) return false;
    
    const pets = petContainer.querySelectorAll('.pet');
    let anyInvalid = false;
    
    pets.forEach(pet => {
        const coords = getObjectCoordinates(pet.id);
        
        if (!coords || coords.length !== 2) {
            console.warn(`Invalid pet coordinates for ${pet.id}`);
            anyInvalid = true;
            return;
        }
        
        const [x, y] = coords;
        const petWidth = Math.ceil(pet.offsetWidth / unitSize);
        const petHeight = Math.ceil(pet.offsetHeight / unitSize);
        const bottomRow = y;
        
        // Check if bottom row is walkable
        if (!isBottomRowWalkable(globalWalkabilityMap, bottomRow, x, petWidth)) {
            console.warn(`Pet ${pet.id} on invalid position: [${x}, ${y}]`);
            anyInvalid = true;
        }
    });
    
    if (anyInvalid) {
        console.warn("Invalid pet positions detected, reloading pets");
        updateStatsBeforeRerunningInitGameAndRenderPets();
        renderPets();
        enablePetDragging();
    }
    
    return true;
}

async function removeInvalidObjectsAndSave() {
    const roomObjectsContainer = document.getElementById('roomObjectsContainer');
    if (!roomObjectsContainer) return;
    
    const objects = roomObjectsContainer.querySelectorAll('.room-object:not(.furniture-preview)');
    let removedAny = false;
    
    objects.forEach(obj => {
        const coords = getObjectCoordinates(obj.id);
        
        if (!coords || coords.length !== 2) {
            console.warn(`Removing ${obj.id}: invalid coordinates`);
            obj.remove();
            if (userObjectAssets[obj.id]) {
                userObjectAssets[obj.id].position = [];
                removedAny = true;
            }
            return;
        }
        
        const [x, y] = coords;
        
        if (x < 0 || y < 0 || y >= roomLayout.length || x >= roomLayout[0].length) {
            console.warn(`Removing ${obj.id}: out of bounds`);
            obj.remove();
            if (userObjectAssets[obj.id]) {
                userObjectAssets[obj.id].position = [];
                removedAny = true;
            }
            return;
        }
        
        const tileType = roomLayout[y]?.[x];
        if (tileType === undefined) {
            console.warn(`Removing ${obj.id}: undefined tile`);
            obj.remove();
            if (userObjectAssets[obj.id]) {
                userObjectAssets[obj.id].position = [];
                removedAny = true;
            }
            return;
        }
        
        const type = tileType?.type ?? tileType;
        const validTypes = [1.0, 2.0, 3.0, 5.0, 6.0];
        
        if (!validTypes.includes(type)) {
            console.warn(`Removing ${obj.id}: invalid tile type ${type}`);
            obj.remove();
            if (userObjectAssets[obj.id]) {
                userObjectAssets[obj.id].position = [];
                removedAny = true;
            }
        }
    });
    
    if (removedAny) {
        console.log("Saving cleaned object list to database");
        await sendObjectAssetsUpdateToDatabase();
    }
}


fetch("gameAssetIndex.json")
    .then(response => response.json())
    .then(data => {
        gameAssetIndex = data;      // assign JSON result
        return fetchGameData();     // call your function next
    })
    .then(async () => {
        await attemptGameInit();
        fetchMessageGiftsFromServer();
    })
    .catch(error => {
        console.error("Error loading gameAssetIndex.json or fetching game data:", error);
    });

function parseGameData(dataFromServer) {
    userObjectAssets = formatObjectAssets(dataFromServer.objectAssets);
    userPetAssets = parseUserPetAssets(dataFromServer.petAssets);
    userMoney = Number(dataFromServer.money);
    petOnWalk = dataFromServer.petOnWalk;
    roomLayoutNumber = dataFromServer.roomLayout
    formatTaxesData(dataFromServer.taxes) 
    
    // Parse pet stats from the new format
    petStatsList = JSON.parse(dataFromServer.petStats);

    function formatTaxesData(taxesDataFromTheServer) {
        if (typeof taxesDataFromTheServer === "string") {
            taxesDataFromTheServer = JSON.parse(taxesDataFromTheServer);
        }

        // Current time in days
        const currentTimeInDays = Date.now() / 1000 / 60 / 60 / 24;

        // taxPaymentPeriod and taxGracePeriod are already in days
        if (!taxesDataFromTheServer || taxesDataFromTheServer.length === 0) {
            taxesData = {
                "waterTax": {
                    date: Math.floor(Date.now() / 1000 / 60),
                    paid: true
                },
                "electricityTax": {
                    date: Math.floor(Date.now() / 1000 / 60),
                    paid: true
                }
            }
            sendTaxUpdate([taxesData.waterTax.date, taxesData.electricityTax.date])
            return
        }

        const [waterTaxDateInMinutes, electricityTaxDateInMinutes] = taxesDataFromTheServer;

        // Convert server-provided dates from minutes to days
        const waterTaxDate = waterTaxDateInMinutes / 60 / 24;
        const electricityTaxDate = electricityTaxDateInMinutes / 60 / 24;

        // Calculate due dates and grace periods in days
        const waterTaxDueDate = waterTaxDate + taxPaymentPeriod;
        const electricityTaxDueDate = electricityTaxDate + taxPaymentPeriod;
        const graceEndWater = waterTaxDueDate + taxGracePeriod;
        const graceEndElectricity = electricityTaxDueDate + taxGracePeriod;

        // Determine if paid
        const waterPaid = currentTimeInDays <= graceEndWater;
        const electricityPaid = currentTimeInDays <= graceEndElectricity;

        taxesData = {
            "waterTax": {
                date: waterTaxDateInMinutes,
                paid: waterPaid
            },
            "electricityTax": {
                date: electricityTaxDateInMinutes,
                paid: electricityPaid
            }
        };
    }


    function formatObjectAssets(objectAssetsDataFromServer) {
        let formatteddataFromServer = {};
        objectAssetsDataFromServer = JSON.parse(objectAssetsDataFromServer);

        objectAssetsDataFromServer.forEach((entry, index) => {
            formatteddataFromServer[`O${index + 1}`] = {
                assetIndex: entry[0],
                position: entry[1]
            };
        });

        return formatteddataFromServer;
    }


    function parseUserPetAssets(petAssets) {
        // If server sends a JSON string, parse it
        if (typeof petAssets === "string") {
            petAssets = JSON.parse(petAssets);
        }

        let petObj = {};
        let supObj = {};
        
        if (petAssets.length > 1) {
            const [pets, supplies] = petAssets;

            for (let [petId, [petName, skins]] of pets) {
                petObj[petId] = { 
                    skins: {},
                    name: petName
                };
                for (let [skinName, assetIndex, equipped] of skins) {
                    petObj[petId].skins[skinName] = {
                        assetIndex: assetIndex,
                        equiped: equipped
                    };
                }
            }

            supplies.forEach(([assetIndex, quantity], idx) => {
                supObj[`S${idx + 1}`] = {
                    assetIndex: assetIndex,
                    quantity: quantity
                };
            });
        }

        return { pets: petObj, supplies: supObj };
    }


}

async function fetchGameData() {
    let showMessageTimeout;
    let closer;
    
    // Schedule showing the message after 500ms
    showMessageTimeout = setTimeout(() => {
        closer = messageToTheUser("Duomenys iekomi duomen bazje. Procesas gali utrukti kelias minutes.", false, true);
    }, 500);

    const gameContainer = document.getElementById("gameContainer");
    Array.from(gameContainer.children).forEach(child => {
        child.style.pointerEvents = "none";
        child.style.opacity = "0.5";
    });
    
    try {
        //  Get fresh userData right before making the request
        const userData = JSON.parse(localStorage.getItem('userData'));
        
        if (!userData?.userId) {
            throw new Error('No user data found');
        }

        const response = await apiFetch(apiBase + 'petGame/gameData', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId })
        });

        if (!response) {
            throw new Error('No response from server');
        }

        if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();

        parseGameData(result);

    } catch (error) {
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.error("Error fetching game data:", error);
    } finally {
        //  Re-enable container (moved to finally to always execute)
        Array.from(gameContainer.children).forEach(child => {
            child.style.pointerEvents = "auto";
            child.style.opacity = "1";
        });
        
        clearTimeout(showMessageTimeout);
        
        if (closer) {
            setTimeout(() => closer(), 0);
        }
    }
}

    
const roomContainer = document.getElementById('room-container');
let isDragging = false;
let currentObject = null;
let holdTimer = null;
let holdStartTime = 0;
let offsetX = 0;
let offsetY = 0;

// Object interactions
const objectInteractions = {
    'pet': (obj) => displayPetTreatOptions(obj),
    'food-bowl': (obj) => displayFoodOptions(obj),
    'water-bowl': (obj) => displayWaterBowlFillingOptions(obj),
    'music-player': (obj) => toggleMusicPlayer(obj),
    'bath': (obj) => displayBathFillingOption (obj)

};

function toggleMusicPlayer(obj) {
    const musicPlayerAutoOff = 4000; // milliseconds
    const pets = document.querySelectorAll('.pet');

    // Helper to stop pets from dancing and manage actions
    const stopPetsDancing = () => {
        pets.forEach((pet) => {
            const firstAction = pendingPetActions[pet.id]?.[0];
            const dancingIsFirstItem = firstAction && firstAction[0] === petDances;

            pendingPetActions[pet.id] = (pendingPetActions[pet.id] || []).filter(
                ([fn, args]) => fn !== petDances
            );

            if (dancingIsFirstItem) {
                managePetActions(pet);
            }
        });
    };

    if (!obj.objectOn) {
        // Turn ON
        obj.objectOn = true;
        setObjectAnimation(obj, "musicPlayerOn");
        initUserTriggeredAction("music", obj);

        // Cancel any existing auto-off timer
        if (obj._autoOffTimer) {
            clearTimeout(obj._autoOffTimer);
        }

        // Automatically turn off after delay
        obj._autoOffTimer = setTimeout(() => {
            obj._autoOffTimer = null;

            if (!obj.objectOn) return; // Already turned off manually

            obj.objectOn = false;
            setObjectAnimation(obj, "musicPlayerOff");

            // Pet handling (same as original)
            stopPetsDancing();

        }, musicPlayerAutoOff);

    } else {
        // Turn OFF manually
        obj.objectOn = false;
        setObjectAnimation(obj, "musicPlayerOff");

        // Cancel pending auto-off
        if (obj._autoOffTimer) {
            clearTimeout(obj._autoOffTimer);
            obj._autoOffTimer = null;
        }

        // Pet handling (same as original)
        stopPetsDancing();
    }
}


// Disable right-click context menu and image highlighting in room container
roomContainer.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

roomContainer.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

roomContainer.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Add CSS to prevent highlighting
roomContainer.style.userSelect = 'none';
roomContainer.style.webkitUserSelect = 'none';
roomContainer.style.mozUserSelect = 'none';

function startDragging(e) {
    if (e.pointerType === "mouse" && e.button !== 0) return;
    if (viewportState.isDragging || viewportState.spacePressed) return;

    isDragging = true;
    currentObject.classList.add('dragging');

    // Get the object's current screen position
    const objRect = currentObject.getBoundingClientRect();
    
    // Store offset in screen pixels
    offsetX = e.clientX - objRect.left;
    offsetY = e.clientY - objRect.top;
}

// Global pointer move handler
document.addEventListener('pointermove', function(e) {
    if (viewportState.isDragging) {
        handleViewportPanMove(e);
        return;
    }
    
    if (isDragging && currentObject) {
        e.preventDefault();
        
        // Get the translate wrapper (not scale wrapper!)
        const translateWrapper = document.getElementById('room-transform-wrapper');
        const translateRect = translateWrapper.getBoundingClientRect();
        
        // Calculate new position in the translated coordinate system
        // The key: translateRect already accounts for scale
        const newLeft = (e.clientX - translateRect.left - offsetX);
        const newTop = (e.clientY - translateRect.top - offsetY);
        
        currentObject.style.left = newLeft + 'px';
        currentObject.style.top = newTop + 'px';
    }
});

function enablePetDragging() {
    const pets = document.querySelectorAll('.pet');
    pets.forEach(pet => {
        // Prevent default browser drag on image/text
        pet.setAttribute('draggable', 'false');
        pet.style.userSelect = 'none';
        pet.style.touchAction = 'none';
        
        let startX, startY;
        let hasMoved = false;
        const moveThreshold = 5; // pixels to distinguish drag from click
        
        pet.addEventListener('pointerdown', function(e) {
            // FIX: Ignore if multi-touch is active
            if (multiTouchActive) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            
            if (e.touches?.length >= 2) return;
            // Only allow left mouse or touch
            if (e.pointerType === "mouse" && e.button !== 0) return;

            cancelMovement(this.id);
            e.preventDefault();
            
            currentObject = this;
            holdStartTime = Date.now();
            startX = e.clientX;
            startY = e.clientY;
            hasMoved = false;

            if (pet.actionTimer) {
                clearTimeout(pet.actionTimer);
                pet.actionTimer = null;
            }

            if (petControllers[pet.id]) {
                petControllers[pet.id].abort();
            }
            
            holdTimer = setInterval(() => {
                const elapsed = Date.now() - holdStartTime;
                
                if (elapsed >= 100 && hasMoved) {
                    clearInterval(holdTimer);
                    pet.classList.add('dragging');
                    setObjectAnimation(pet, `${pet.id}-dragged`);
                    startDragging(e);
                }
            }, 10);
        });
        
        // Track pointer movement
        pet.addEventListener('pointermove', function(e) {
            if (multiTouchActive || !holdTimer) return;
            
            const deltaX = Math.abs(e.clientX - startX);
            const deltaY = Math.abs(e.clientY - startY);
            
            if (deltaX > moveThreshold || deltaY > moveThreshold) {
                hasMoved = true;
            }
        });
        
        // Cancel hold if pointer is released early
        pet.addEventListener('pointerup', function(e) {
            // FIX: Ignore if multi-touch was recently active
            if (multiTouchActive) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            
            pet.classList.remove('dragging');
            if (holdTimer) {
                clearInterval(holdTimer);
                holdTimer = null;
            }
            
            // If it was just a click (no movement, quick release)
            if (!hasMoved && (Date.now() - holdStartTime) < 100) {
                // Handle as click - you can add click behavior here if needed
                console.log('Pet clicked:', pet.id);
            }
            
            setObjectAnimation(pet, `${pet.id}-stands-idle`);
            pet.actionTimer = setTimeout(() => {
                managePetActions(pet);
                pet.actionTimer = null;
            }, 1000);
        });
    });
}

function removeAllDeleteItemHighlights() {
    document.querySelectorAll('.marked-for-deletion').forEach(element => {
        element.classList.remove('marked-for-deletion'); // remove the class
    });
    
    document.querySelector("#delete-selected-item-button").disabled = true;
}

function showDeleteIcon(element) {
    if (!element) return;

    // prevent marking anything if preview is active
    if (furniturePreviewDict["furniture-preview"].assetIndex) {
        return;
    }

    // toggle the class
    if (element.classList.contains("marked-for-deletion")) {
        element.classList.remove("marked-for-deletion");
    } else {
        element.classList.add("marked-for-deletion");
    }

    // enable/disable button based on how many are selected
    const anySelected = document.querySelectorAll(".marked-for-deletion").length > 0;
    document.querySelector("#delete-selected-item-button").disabled = !anySelected;
}


function removeObjectsMarkedForRemoval() {
    const deletedIds = []; //  store deleted object IDs

    const objectsToRemove = document.querySelectorAll(".marked-for-deletion");
    if (objectsToRemove.length === 0) return deletedIds;

    const needsSecondCheck = [];

    // 1 FIRST PASS  DELETE WHAT CAN BE DELETED NOW
    for (const obj of objectsToRemove) {
        const assetData = userObjectAssets[obj.id];
        if (!assetData) continue;

        const placingIndex = gameAssetIndex[assetData.assetIndex].placingIndex;

        const isExempt = PLACING_INDEXES_TO_BE_IGNORED.has(placingIndex);

        if (hasBlockingObjects(obj) && !isExempt) {
            // can't delete yet  save for second check
            needsSecondCheck.push(obj);
        } else {
            // delete immediately
            const el = document.getElementById(obj.id);
            if (el) el.remove();
            userObjectAssets[obj.id].position = [];
            deletedIds.push(obj.id);
        }
    }

    // 2 Remove highlights from ALL objects
    removeAllDeleteItemHighlights();

    // 3 SECOND PASS  RECHECK BLOCKED OBJECTS
    for (const obj of needsSecondCheck) {
        const assetData = userObjectAssets[obj.id];
        if (!assetData) continue;

        const placingIndex = gameAssetIndex[assetData.assetIndex].placingIndex;

        const isExempt = PLACING_INDEXES_TO_BE_IGNORED.has(placingIndex);

        if (hasBlockingObjects(obj) && !isExempt) {
            // still blocked  warn + blink
            messageToTheUser("iuos daiktus galsi ineti tik nukls nuo j kitus!");
            obj.classList.add("blinking-warning");
            setTimeout(() => obj.classList.remove("blinking-warning"), 6000);
        } else {
            // becomes free  delete now
            const el = document.getElementById(obj.id);
            if (el) el.remove();
            userObjectAssets[obj.id].position = [];
            deletedIds.push(obj.id); //  track deleted ID
        }
    }

    deletedIds.forEach(id => {
        let isStackable = gameAssetIndex[userObjectAssets[id].assetIndex].stackable

        if (!isStackable) {
            const itemCard = document.querySelector(`#${id}-item-card`)
            if (itemCard) {
            
            itemCard.classList.remove("in-use");
            const useBtn = itemCard.querySelector(`#${id}-use-btn`)
            
            if (useBtn) {
                useBtn.innerHTML = 'Naudoti';
                useBtn.disabled = false;
                useBtn.className = 'use-btn';
            }
        }
        }
    });

    rerenderObjectAssetListIfNoItemsInSelectedCategory(sidebar=true)
}




document.querySelector("#delete-selected-item-button").addEventListener("click", () => {
    removeObjectsMarkedForRemoval()
    clearPlacementHighlights();
});;

function hasBlockingObjects(target) {
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const targetCoords = getObjectCoordinates(target.id);
    if (!targetCoords) return false;

    const [baseX, baseY] = targetCoords;

    const targetWidth = Math.ceil(target.offsetWidth / unitSize);
    const targetHeight = Math.ceil(target.offsetHeight / unitSize);
    const targetZ = parseInt(window.getComputedStyle(target).zIndex) || 0;

    // Collect all tiles covered by this object
    const targetTiles = [];
    for (let dx = 0; dx < targetWidth; dx++) {
        for (let dy = 0; dy < targetHeight; dy++) {
            targetTiles.push([baseX + dx, baseY - dy]);
        }
    }

    // Compare against all other objects
    const allObjects = document.querySelectorAll('.room-object');
    for (let other of allObjects) {
        if (other === target) continue;

        const otherCoords = getObjectCoordinates(other.id);
        if (!otherCoords) continue;

        const [ox, oy] = otherCoords;
        const otherWidth = Math.ceil(other.offsetWidth / unitSize);
        const otherHeight = Math.ceil(other.offsetHeight / unitSize);
        const otherZ = parseInt(window.getComputedStyle(other).zIndex) || 0;

        const otherTiles = [];
        for (let dx = 0; dx < otherWidth; dx++) {
            for (let dy = 0; dy < otherHeight; dy++) {
                otherTiles.push([ox + dx, oy - dy]);
            }
        }

        //  Check if any tile overlaps
        for (let t of targetTiles) {
            for (let o of otherTiles) {
                if (t[0] === o[0] && t[1] === o[1] && otherZ > targetZ) {
                    return true;
                }
            }
        }
    }
    return false;
}


function enableObjectDragging() {
    const objects = document.querySelectorAll('.room-object');
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    objects.forEach(obj => {
        obj.classList.add('room-object-edit');
        
        // Make sure it's NOT draggable (remove native drag)
        obj.setAttribute('draggable', 'false');
        
        // Remove old listeners
        obj.removeEventListener('pointerdown', obj._normalModeHandler);
        obj.removeEventListener('pointerdown', obj._editModeHandler);
        obj.removeEventListener('contextmenu', obj._contextMenuHandler);
        
        // Mobile: use contextmenu for long press
// Around line 3847, replace the mobile touch handler:
if (isTouchDevice) {
    obj._pointerDownHandler = function(e) {
        //  CHECK IMMEDIATELY at the very start
        if (multiTouchActive || e.touches?.length >= 2) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        const startX = e.clientX;
        const startY = e.clientY;
        const startTime = Date.now();
        let longPressFired = false;

        // Start long-press timer
        obj._longPressTimeout = setTimeout(() => {
            //  CHECK AGAIN before starting drag
            if (multiTouchActive || document.querySelectorAll('touch').length >= 2) {
                cleanup();
                return;
            }

            longPressFired = true;
            
            // Long press detected - START DRAGGING
            if (navigator.vibrate) navigator.vibrate(30);

            const objPlacingOrder = gameAssetIndex[userObjectAssets[obj.id]?.assetIndex]?.placingIndex || 
                                gameAssetIndex[furniturePreviewDict[obj.id]?.assetIndex]?.placingIndex;

            if (hasBlockingObjects(obj) && !PLACING_INDEXES_TO_BE_IGNORED.has(objPlacingOrder)) {
                messageToTheUser(" daikta galsi pajudinti tik nums nuo jo kitus!");
                cleanup();
                return;
            }

            const placementMap = generatePlacementMap(obj.id);
            obj._placementMap = placementMap;
            obj._originalCoords = getObjectCoordinates(obj.id);
            obj._readyToDrag = true;

            determineAndHighlightValidTiles(placementMap);
            obj.classList.add("dragging");

            obj._editModeHandler({
                clientX: e.clientX,
                clientY: e.clientY,
                pointerType: "touch",
                button: 0,
                preventDefault: () => {},
                stopPropagation: () => {}
            });
        }, 100);

        // Cancel on significant movement
        const onMove = (ev) => {
            //  CHECK during movement
            if (multiTouchActive || ev.touches?.length >= 2) {
                clearTimeout(obj._longPressTimeout);
                cleanup();
                return;
            }

            const dx = Math.abs(ev.clientX - startX);
            const dy = Math.abs(ev.clientY - startY);
            if (dx > 5 || dy > 5) {
                clearTimeout(obj._longPressTimeout);
                cleanup();
            }
        };

        const onUp = (ev) => {
            //  CHECK on touch end
            if (multiTouchActive) {
                cleanup();
                return;
            }

            clearTimeout(obj._longPressTimeout);
            
            // Check if this was a quick tap (not a long press)
            const duration = Date.now() - startTime;
            const dx = Math.abs(ev.clientX - startX);
            const dy = Math.abs(ev.clientY - startY);
            
            if (!longPressFired && duration < 300 && dx < 10 && dy < 10) {
                // QUICK TAP - MARK FOR DELETION
                if (navigator.vibrate) navigator.vibrate(20);
            
                showDeleteIcon(obj)
            }
            
            cleanup();
        };

        const cleanup = () => {
            document.removeEventListener('pointermove', onMove);
            document.removeEventListener('pointerup', onUp);
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onUp);
        };

        document.addEventListener('pointermove', onMove, { passive: false });
        document.addEventListener('pointerup', onUp);
        document.addEventListener('touchmove', onMove, { passive: false });
        document.addEventListener('touchend', onUp);
    };

    obj.addEventListener('pointerdown', obj._pointerDownHandler);
}

        
        obj._editModeHandler = function(e) {
            // IMMEDIATELY check for multi-touch
            if (multiTouchActive) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            
            if (e.touches?.length >= 2) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            
            if (e.pointerType === "mouse" && e.button !== 0) return;

            e.preventDefault();
            e.stopPropagation();

            if (!isTouchDevice) {
                const placementMap = generatePlacementMap(obj.id);
                highlightTimeout = setTimeout(() => {
                    determineAndHighlightValidTiles(placementMap);
                }, 100);
                obj._placementMap = placementMap;
            }
            
            const startX = e.clientX;
            const startY = e.clientY;
            let dragStarted = false;
            
            // Mobile: Check if object is ready to drag (from contextmenu)
            if (isTouchDevice && !obj._readyToDrag) {
                return;
            }
            
            const moveHandler = (moveEvent) => {
                if (multiTouchActive) {
                    cancelDrag();
                    return;
                }
                
                
                const DRAG_THRESHOLD = 5; // pixels

                const dx = Math.abs(moveEvent.clientX - startX);
                const dy = Math.abs(moveEvent.clientY - startY);

                // Only start dragging if movement exceeds threshold
                if (!dragStarted && (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD)) {
                    dragStarted = true;
                    
                    // Desktop: check blocking and show placement map
                    if (!isTouchDevice) {
                        const objPlacingOrder = gameAssetIndex[userObjectAssets[obj.id]?.assetIndex]?.placingIndex || 
                                            gameAssetIndex[furniturePreviewDict[obj.id]?.assetIndex]?.placingIndex;
                        
                        if (hasBlockingObjects(obj) && !PLACING_INDEXES_TO_BE_IGNORED.has(objPlacingOrder)) {
                            messageToTheUser(" daikt galsi pajudinti tik nums nuo jo kitus!");
                            clearPlacementHighlights();
                            cancelDrag();
                            return;
                        }

                        if (isTouchDevice) {
                            const placementMap = generatePlacementMap(obj.id);
                            determineAndHighlightValidTiles(placementMap);
                            obj._placementMap = placementMap;
                        }
                        obj._originalCoords = getObjectCoordinates(obj.id);
                    }
                    
                    currentObject = obj;
                    document.removeEventListener('pointermove', moveHandler);
                    
                    const syntheticEvent = {
                        clientX: startX,
                        clientY: startY,
                        pointerType: e.pointerType,
                        button: e.button
                    };
                    startDragging(syntheticEvent);
                }
            };
            
            const upHandler = (upEvent) => {
                updateSingleItemZIndex(obj.id);
                if (multiTouchActive) {
                    cancelDrag();
                    return;
                }

                clearPlacementHighlights();
                
                document.removeEventListener('pointermove', moveHandler);
                document.removeEventListener('pointerup', upHandler);
                
                // Mobile: clear ready flag when touch ends
                if (isTouchDevice) {
                    obj._readyToDrag = false;
                    obj.classList.remove("dragging");
                }
                
                // Desktop: show delete icon on click without drag
                if (!dragStarted && !isTouchDevice) {
                    showDeleteIcon(obj);
                }
                
                if (!isDragging) {
                    currentObject = null;
                }
            };

            const cancelDrag = () => {
                document.removeEventListener('pointermove', moveHandler);
                document.removeEventListener('pointerup', upHandler);
                currentObject = null;
                if (isTouchDevice) {
                    obj._readyToDrag = false;
                    clearPlacementHighlights();
                }
            };
            
            document.addEventListener('pointermove', moveHandler);
            document.addEventListener('pointerup', upHandler);
        };
        
        obj.addEventListener('pointerdown', obj._editModeHandler);
    });
}

let highlightTimeout = null;

function disableObjectDragging() {
    // Remove all delete icons when exiting edit mode
    removeAllDeleteItemHighlights();
    
    // Target both room objects AND pets
    const objects = document.querySelectorAll('.room-object, .pet');
    objects.forEach(obj => {
        obj.classList.remove('room-object-edit');
        
        //  CRITICAL FIX: Remove ALL edit mode handlers
        if (obj._editModeHandler) {
            obj.removeEventListener('pointerdown', obj._editModeHandler);
            delete obj._editModeHandler; // Clean up the reference
        }
        
        //  ADD: Remove touch-specific handlers for mobile
        if (obj._pointerDownHandler) {
            obj.removeEventListener('pointerdown', obj._pointerDownHandler);
            delete obj._pointerDownHandler;
        }
        
        //  ADD: Clear any pending long-press timeouts
        if (obj._longPressTimeout) {
            clearTimeout(obj._longPressTimeout);
            delete obj._longPressTimeout;
        }
        
        //  ADD: Clear ready-to-drag flag
        delete obj._readyToDrag;
        
        // Remove any existing normal mode handler first
        if (obj._normalModeHandler) {
            obj.removeEventListener('pointerdown', obj._normalModeHandler);
        }
        if (obj._normalModeUpHandler) {
            obj.removeEventListener('pointerup', obj._normalModeUpHandler);
        }
        
        let clickStartTime = 0;
        let wasLongHold = false;
        
        // Add normal mode handler (click for interaction only)
        obj._normalModeHandler = function(e) {
            if (e.pointerType === "mouse" && e.button !== 0) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            clickStartTime = Date.now();
            wasLongHold = false;
            
            // Check if this becomes a long hold (like your existing hold timer logic)
            const holdTimer = setTimeout(() => {
                wasLongHold = true;
            }, 1000); // Same 1 second threshold as your drag logic
            
            // Store timer reference to clear it later
            obj._holdTimer = holdTimer;
        };
        
        obj._normalModeUpHandler = function(e) {
            if (e.pointerType === "mouse" && e.button !== 0) return;
            
            // Clear the hold timer
            if (obj._holdTimer) {
                clearTimeout(obj._holdTimer);
                obj._holdTimer = null;
            }
            
            // Only trigger interaction if it was a quick click, not a long hold
            if (!wasLongHold && !isDragging && !editing && !multiTouchActive) {
                for (const cls of this.classList) {
                    if (objectInteractions[cls]) {
                        objectInteractions[cls](obj);
                        break; // stop after the first match
                    }
                }
            }
            
            // Reset flags
            wasLongHold = false;
        };
        
        obj.addEventListener('pointerdown', obj._normalModeHandler);
        obj.addEventListener('pointerup', obj._normalModeUpHandler);
    });
}

// Global pointer move handler - REVERTED TO DIRECT CALCULATION
document.addEventListener('pointermove', function(e) {
    // Handle viewport panning first
    if (viewportState.isDragging) {
        handleViewportPanMove(e);
        return;
    }
    
    // Handle object dragging - direct calculation, no RAF
    if (isDragging && currentObject) {
        e.preventDefault();
        
        const scaleWrapper = document.getElementById('scale-wrapper');
        const scaleRect = scaleWrapper.getBoundingClientRect();
        
        // --- CORRECTED COORDINATE LOGIC (Direct Update) ---

        // 1. Calculate the new *screen* position of the object's top-left based on the mouse
        //    (offsetX/Y were stored as screen pixels in startDragging)
        const newObjScreenX = e.clientX - offsetX;
        const newObjScreenY = e.clientY - offsetY;

        // 2. Calculate the *screen* position of the panned/scaled origin
        //    (i.e., the 0,0 point of the room-transform-wrapper)
        const originScreenX = scaleRect.left + (viewportState.x * viewportState.scale);
        const originScreenY = scaleRect.top + (viewportState.y * viewportState.scale);

        // 3. Find the object's new position *relative* to that origin, still in *screen* pixels
        const newObjRelScreenX = newObjScreenX - originScreenX;
        const newObjRelScreenY = newObjScreenY - originScreenY;

        // 4. Convert this relative screen position back to *local* coordinates
        //    by dividing by the scale. This is the value style.left/top expects.
        const newLocalX = newObjRelScreenX / viewportState.scale;
        const newLocalY = newObjRelScreenY / viewportState.scale;
        
        // 5. Set the style.left/top using the calculated local coordinates
        currentObject.style.left = newLocalX + 'px';
        currentObject.style.top = newLocalY + 'px';
    }
});

function checkPlacement(obj, placementMap, unitSize) {
    const startRow = Math.floor(obj.offsetTop / unitSize);
    const startCol = Math.floor(obj.offsetLeft / unitSize);

    const rows = Math.ceil(obj.offsetHeight / unitSize);
    const cols = Math.ceil(obj.offsetWidth / unitSize);

    // Check bottom row - must be in canPlace tiles
    const bottomRow = startRow + rows - 1;
    for (let c = 0; c < cols; c++) {
        const mapCol = startCol + c;
        
        if (!placementMap[bottomRow] || 
            !placementMap[bottomRow][mapCol] || 
            !placementMap[bottomRow][mapCol].canPlace) {
            return false;
        }
    }

    // Check upper rows - can be in either canPlace OR canOccupy tiles
    for (let r = 0; r < rows - 1; r++) {
        for (let c = 0; c < cols; c++) {
            const mapRow = startRow + r;
            const mapCol = startCol + c;

            if (!placementMap[mapRow] || 
                !placementMap[mapRow][mapCol] || 
                (!placementMap[mapRow][mapCol].canPlace && !placementMap[mapRow][mapCol].canOccupy)) {
                return false;
            }
        }
    }
    
    return true;
}

function isBottomRowWalkable(walkMap, startRow, startCol, width) {
    // Check if row is inside walkMap
    if (startRow < 0 || startRow >= walkMap.length) return false;

    for (let col = startCol; col < startCol + width; col++) {
        // Check if column is inside walkMap
        if (col < 0 || col >= walkMap[0].length) return false;

        if (!walkMap[startRow][col]?.walkable) {
            return false;
        }
    }
    return true;
}


function findClosestWalkablePosition(walkMap, startRow, startCol, petWidth) {
    let minDist = Infinity;
    let closest = null;

    for (let row = 0; row < walkMap.length; row++) {
        for (let col = 0; col <= walkMap[0].length - petWidth; col++) {
            if (isBottomRowWalkable(walkMap, row, col, petWidth)) {
                const dist = Math.abs(startRow - row) + Math.abs(startCol - col);
                if (dist < minDist) {
                    minDist = dist;
                    closest = { row, col };
                }
            }
        }
    }
    return closest;
}

function validateAndResetPosition(object) {
    const left = parseInt(object.style.left);
    const top = parseInt(object.style.top);

    const snappedLeft = Math.round(left / unitSize) * unitSize;
    const snappedTop = Math.round((top + object.offsetHeight) / unitSize) * unitSize - object.offsetHeight;

    object.style.left = snappedLeft + 'px';
    object.style.top = snappedTop + 'px';
    object.classList.remove('dragging');

    // Check if it's a pet
    if ([...object.classList].some(cls => cls.includes("pet"))) {
        const petWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
        const petHeightInTiles = Math.ceil(object.offsetHeight / unitSize);

        let tileX = Math.round(parseInt(object.style.left) / unitSize);
        let tileY = Math.round(parseInt(object.style.top) / unitSize);
        let bottomRow = tileY + petHeightInTiles - 1;

        if (!isBottomRowWalkable(globalWalkabilityMap, bottomRow, tileX, petWidthInTiles)) {
            const closest = findClosestWalkablePosition(globalWalkabilityMap, bottomRow, tileX, petWidthInTiles);
            if (closest) {
                object.style.left = closest.col * unitSize + 'px';
                object.style.top = (closest.row - petHeightInTiles + 1) * unitSize + 'px';
            } else {
                messageToTheUser("Augintiniui nra vietos vaikioti!");
            }
        }
        setPetZIndex(object);
    }

    clearPlacementHighlights();

    //  IMPROVED: Always validate placement for objects in edit mode
    if (editing && object._placementMap && object._originalCoords) {
        const canPlace = checkPlacement(object, object._placementMap, unitSize);
        if (!canPlace) {
            // Revert to original position
            object.style.left = `calc(${object._originalCoords[0]} * var(--unit-size))`;
            object.style.top = `calc((${object._originalCoords[1] + 1} * var(--unit-size)) - ${object.offsetHeight}px)`;
        }
    }

    // Reset dragging states
    isDragging = false;
    currentObject = null;
}

// Global pointer up handler
document.addEventListener('pointerup', function(e) {
    if (e.pointerType === "mouse" && e.button !== 0) return;
    
    // ADD THIS CHECK AT THE VERY TOP
    if (multiTouchActive) {
        if (isDragging && currentObject) {
            validateAndResetPosition(currentObject);
        }
        e.preventDefault();
        e.stopPropagation();
        return;
    }
    
    // Clear any hold timer
    if (holdTimer) {
        clearInterval(holdTimer);
    }
    
    if (isDragging && currentObject) {
    const left = parseInt(currentObject.style.left);
    const top = parseInt(currentObject.style.top);

    const snappedLeft = Math.round(left / unitSize) * unitSize;
    const snappedTop = Math.round((top + currentObject.offsetHeight) / unitSize) * unitSize - currentObject.offsetHeight;

    currentObject.style.left = snappedLeft + 'px';
    currentObject.style.top = snappedTop + 'px';
    currentObject.classList.remove('dragging');

    if ([...currentObject.classList].some(cls => /^pet$|^-pet$|^pet-$|^-pet-$/.test(cls))) {
        const petWidthInTiles = Math.ceil(currentObject.offsetWidth / unitSize);
        const petHeightInTiles = Math.ceil(currentObject.offsetHeight / unitSize);

        // Current tile coordinates (top-left of pet)
        let tileX = Math.round(parseInt(currentObject.style.left) / unitSize);
        let tileY = Math.round(parseInt(currentObject.style.top) / unitSize);

        // The bottom row of the pet in tile coordinates
        let bottomRow = tileY + petHeightInTiles - 1;

        // If bottom row not walkable, find closest position where **entire bottom row** is walkable
        if (!isBottomRowWalkable(globalWalkabilityMap, bottomRow, tileX, petWidthInTiles)) {
            const closest = findClosestWalkablePosition(globalWalkabilityMap, bottomRow, tileX, petWidthInTiles);
            if (closest) {
                // Align pet so **bottom row** sits on walkable tiles
                currentObject.style.left = closest.col * unitSize + 'px';
                currentObject.style.top = (closest.row - petHeightInTiles + 1) * unitSize + 'px';
            } else {
                messageToTheUser("Augintiniui nra vietos vaikioti!");
            }
        }
        setPetZIndex(currentObject);

    }

    clearPlacementHighlights();

    if (editing && currentObject._placementMap) {
        const canPlace = checkPlacement(currentObject, currentObject._placementMap, unitSize);
        if (!canPlace) {
            currentObject.style.left = `calc(${currentObject._originalCoords[0]} * var(--unit-size))`;
            currentObject.style.top = `calc((${currentObject._originalCoords[1] + 1} * var(--unit-size)) - ${currentObject.offsetHeight}px)`;
        }
    }

    isDragging = false;
    currentObject = null;
    } else if (currentObject && !editing && !multiTouchActive) {
        // Only trigger interactions in normal mode and if we have a current object
        for (const cls of currentObject.classList) {
            if (objectInteractions[cls]) {
                objectInteractions[cls](currentObject);
                break; // stop after first match
            }
        }
        currentObject = null;
    }
});


function movePetToTile(pet, startCoord, endCoord) {
    if (!pet) return Promise.resolve();
    
    const [startCol, startRow] = startCoord;
    const [endCol, endRow] = endCoord;
    
    const path = findPath(startCol, startRow, endCol, endRow, pet.id);
    
    if (!path || path.length === 0) {
        return Promise.resolve();
    }

    if (startCoord.length === endCoord.length && startCoord.every((val, i) => val === endCoord[i])) {
        return Promise.resolve();
    }
    
    return new Promise((resolve) => {
        moveObjectAlongPath(pet.id, path, resolve);
    });
}

// Helper: only bottom row must be walkable
function canPlaceObjectAt(x, y, width, height, walkabilityMap) {
    width = Math.ceil(width / unitSize);
    height = Math.ceil(height / unitSize);
    
    const topRow = y - (height - 1);

    // Check bounds first (entire object must fit in map vertically & horizontally)
    if (topRow < 0 || y >= walkabilityMap.length ||
        x < 0 || x + width - 1 >= walkabilityMap[0].length) {
        return false;
    }

    //  Only check bottom row for walkability
    for (let c = x; c < x + width; c++) {
        if (!walkabilityMap[y][c] || !walkabilityMap[y][c].walkable) {
            return false;
        }
    }

    // Upper rows don't need to be walkable
    return true;
}

// Pathfinding function with bottom-left reference - FIXED
function findPath(startCol, startRow, endCol, endRow, objectId) {
    // Get object size in tiles
    const object = document.getElementById(objectId);
    if (!object) {
        console.error("Object not found:", objectId);
        return null;
    }

    const objWidth = object.offsetWidth;
    const objHeight = object.offsetHeight;
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const widthInTiles = Math.ceil(objWidth / unitSize);

    // Generate walkability map
    const walkabilityMap = globalWalkabilityMap;
    
    // Add safety check
    if (!walkabilityMap || walkabilityMap.length === 0) {
        console.error("Failed to generate walkability map");
        return null;
    }

    // Validate start & end
    if (!canPlaceObjectAt(startCol, startRow, objWidth, objHeight, walkabilityMap)) {
        console.log("Start position is not valid for object bottom");
        return null;
    }
    if (!canPlaceObjectAt(endCol, endRow, objWidth, objHeight, walkabilityMap)) {
        console.log(endCol, endRow)
        console.log("End position is not valid for object bottom");
        return null;
    }

    // Helper function to check if movement is allowed for the entire object
    function canMoveInDirection(fromCol, fromRow, dirIndex) {
        // For each tile the object occupies at the current position
        for (let c = fromCol; c < fromCol + widthInTiles; c++) {
            if (c >= walkabilityMap[0].length || 
                !walkabilityMap[fromRow] || 
                !walkabilityMap[fromRow][c] || 
                !walkabilityMap[fromRow][c].allowedDirections || 
                !walkabilityMap[fromRow][c].allowedDirections[dirIndex]) {
                return false;
            }
        }
        return true;
    }

    // Directions: up, right, down, left
    const directions = [
        [0, -1], // up (col, row - 1)
        [1, 0],  // right (col + 1, row)
        [0, 1],  // down (col, row + 1)
        [-1, 0]  // left (col - 1, row)
    ];

    // Track visited states for bottom-left corner
    const visited = Array(walkabilityMap.length).fill().map(
        () => Array(walkabilityMap[0].length).fill(false)
    );

    const queue = [[startCol, startRow, []]];
    visited[startRow][startCol] = true;

    while (queue.length > 0) {
        const [col, row, path] = queue.shift();

        for (let dirIndex = 0; dirIndex < directions.length; dirIndex++) {
            const [dc, dr] = directions[dirIndex];
            
            // CHECK DIRECTIONAL MOVEMENT FIRST, before calculating new position
            if (!canMoveInDirection(col, row, dirIndex)) {
                continue;
            }
            
            const newCol = col + dc;
            const newRow = row + dr;

            // Destination reached?
            if (newCol === endCol && newRow === endRow) {
                return [...path, [newCol, newRow]];
            }

            // Rest of your checks...
            if (newRow < 0 || newRow >= walkabilityMap.length ||
                newCol < 0 || newCol >= walkabilityMap[0].length ||
                visited[newRow][newCol]) {
                continue;
            }

            if (!canPlaceObjectAt(newCol, newRow, objWidth, objHeight, walkabilityMap)) {
                continue;
            }

            // Valid move
            visited[newRow][newCol] = true;
            queue.push([newCol, newRow, [...path, [newCol, newRow]]]);
        }
    }

    console.log("No path found after BFS search");
    return null;
}

// Global variable to track active movements
const activeMovements = new Map();

// Function to move an object along a path
function moveObjectAlongPath(objectId, path, onComplete) {
    const speed = 150
    const object = document.getElementById(objectId);
    if (!object || !path?.length) {
        onComplete?.();
        return;
    }

    cancelMovement(objectId); // Cancel any existing movement

    let currentStep = 0;
    const movementId = Date.now() + Math.random(); // Unique ID for this movement
    activeMovements.set(objectId, { 
        id: movementId, 
        interval: null,
        cleanupTimeout: null  // Track cleanup timeout too
    });

    function moveToNextStep() {
    const movement = activeMovements.get(objectId);
    if (!movement || movement.id !== movementId) return;

    if (currentStep >= path.length) {
        object.style.transition = '';
        activeMovements.delete(objectId);
        onComplete?.();
        return;
    }

    const [col, row] = path[currentStep];
    const [prevCol, prevRow] = currentStep > 0 ? path[currentStep - 1] : getObjectCoordinates(objectId);
    const deltaCol = col - prevCol;
    const deltaRow = row - prevRow;

    // Animation logic
    if (deltaRow > 0) {
        setObjectAnimation(object, `${objectId}-walks-downwards`);
    } else if (deltaRow < 0) {
        setObjectAnimation(object, `${objectId}-walks-upwards`);
    } else if (deltaCol !== 0) {
        setObjectAnimation(object, `${objectId}-walks-sideways`);
        
        if (deltaCol < 0) {
            object.classList.remove("pet-right");
            object.classList.add("pet-left");
        } else {
            object.classList.remove("pet-left");
            object.classList.add("pet-right");
        }
    }

    //  FIX: Update position FIRST, then set z-index based on NEW position
    requestAnimationFrame(() => {
        object.style.transition = `top ${speed}ms linear, left ${speed}ms linear`;
        object.style.top = `calc((${row} * var(--unit-size)) - (var(--pet-size) - var(--unit-size)))`;
        object.style.left = `calc(${col} * var(--unit-size))`;
        
        //  Now set z-index AFTER position is updated
        setPetZIndex(object);
    });

    currentStep++;
    movement.interval = setTimeout(moveToNextStep, speed);

    // Handle final step adjustments
    if (currentStep === path.length) {
        setTimeout(() => {
            if (activeMovements.has(objectId) && activeMovements.get(objectId).id === movementId) {
                object.style.transition = '';
                activeMovements.delete(objectId);
                setPetZIndex(object); //  Final z-index update
                setObjectAnimation(object, `${objectId}-stands-idle`);
                onComplete?.();
            }
        }, speed);
    }
}

    moveToNextStep();
}

function generateRowZIndexMap(roomLayout) {
    const rows = roomLayout.length;
    const cols = roomLayout[0].length;
    const zIndexMap = Array(rows).fill(null).map(() => Array(cols).fill(null));
    
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const tileType = roomLayout[row][col];
            const type = tileType?.type ?? tileType;
            
            // Only floor (1.0) and boundary (3.0) tiles get row-based z-index
            if (type === 1.0) {
                zIndexMap[row][col] = row + 1;
            }
        }
    }
    
    return zIndexMap;
}

// Set z-indexes for all room objects (call once after room loads)
function setRoomObjectZIndexes() {
    const itemsInFrontOfPetClasses = ['food-bowl', 'water-bowl'];

    const rowZIndexMap = generateRowZIndexMap(roomLayout);
    
    // Get all room objects
    const allObjects = document.querySelectorAll('.room-object');
    
    // First pass: categorize and set basic z-indexes
    const wallOnlyItems = [];
    const floorItems = [];
    const walkOnItems = [];
    
    allObjects.forEach(obj => {
        const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
        if (!assetSource || assetSource.assetIndex == null) return;
        
        const asset = gameAssetIndex[assetSource.assetIndex];
        if (!asset) return;
        
        const coords = getObjectCoordinates(obj.id);
        if (!coords) return;
        
        const [x, y] = coords;
        const width = Math.ceil(obj.offsetWidth / unitSize);
        const height = Math.ceil(obj.offsetHeight / unitSize);
        const bottomRow = y;
        

        //SETTING Z-INDEX OF FLOOR-PLACED ITEMS ALWAYS AT THE BOTTOM

        // FLOORING
        if (asset.placingIndex === 5) {
            obj.style.zIndex = 1;
            return;
        }

        // CARPETS
        if (asset.placingIndex === 6) {
            obj.style.zIndex = 2;
            return;
        }

        // WALK-ON ITEMS (CAN STEP ALL OVER)
        if (asset.walkOn) {
            obj.style.zIndex = 3;
            walkOnItems.push(obj.id);
            return;
        }
        
        // Get all tiles occupied by this object
        const occupiedTiles = getTilesOccupiedByObject(coords, width, height);
        
        // Check if entirely on wall tiles
        let isWallOnly = true;
        
        occupiedTiles.forEach(([tileX, tileY]) => {
            if (tileY >= 0 && tileY < roomLayout.length && 
                tileX >= 0 && tileX < roomLayout[0].length) {
                const tileType = roomLayout[tileY][tileX];
                const type = tileType?.type ?? tileType;
                
                if (type === 1.0) {
                    isWallOnly = false;
                    return
                }
            }
        });
        
        if (isWallOnly) {
            // Keep original z-index for wall-only items
            wallOnlyItems.push(obj.id);
            obj.style.zIndex = '';
        } else {
            // Floor/boundary items: use bottom row z-index
            floorItems.push(obj.id);
            const zIndex = rowZIndexMap[bottomRow]?.[x];
            if (zIndex) {
                obj.style.zIndex = zIndex;
                if (itemsInFrontOfPetClasses.some(cls => obj.classList.contains(cls))) {
                    obj.style.zIndex = Number(obj.style.zIndex) + 1;
                }
            }
        }
    });

    const overlappingItemPairs = findClusters();
    
    overlappingItemPairs.forEach(([itemA, itemB]) => {
        const assetA = getAsset(itemA);
        const assetB = getAsset(itemB);

        let placed;
        let surface;
        
        if (!assetA || !assetB) return;
        
        const aCanBeOnB = assetA.canBePlacedOn.includes(assetB.placingIndex);
        const bCanBeOnA = assetB.canBePlacedOn.includes(assetA.placingIndex);
        
        if (aCanBeOnB) {
            placed = itemA,    // Object being placed
            surface = itemB    // Object it's placed on
        }
        
        if (bCanBeOnA) {
            placed = itemB,
            surface = itemA
        }
        
        if (aCanBeOnB || bCanBeOnA) {
            if (!wallOnlyItems.includes(surface)) {
                const placedCoords = getObjectCoordinates(placed.id);
                const placedWidth = Math.ceil(placed.offsetWidth / unitSize);
                const placedHeight = Math.ceil(placed.offsetHeight / unitSize);
                const placedTiles = getTilesOccupiedByObject(placedCoords, placedWidth, placedHeight)
                const maxY = Math.max(...placedTiles.map(c => c[1]));
                const placedBottomRowTiles = placedTiles.filter(c => c[1] === maxY);

                const placedObjectIsInSurfacesAllowedTiles = areAllBottomRowTilesOnSurfaceAllowedTiles(generatePlacementMap(placed.id), placedBottomRowTiles, surface.id)
                if (placedObjectIsInSurfacesAllowedTiles) {
                    const z = window.getComputedStyle(surface).zIndex;
                    const surfaceZindex = z === 'auto' ? 0 : parseInt(z, 10);
                    placed.style.zIndex = surfaceZindex + 1;
                }
            }
        }
    });

    function areAllBottomRowTilesOnSurfaceAllowedTiles(placementMap, placedBottomRowTiles, expectedSurfaceId) {
        // Check each tile in placedBottomRowTiles
        for (const tile of placedBottomRowTiles) {
            const [row, col] = tile;
            
            // Ensure coordinates are within bounds
            if (col >= placementMap.length || row >= placementMap[0].length) {
                console.log(`Tile at [${col}, ${row}] is out of bounds`);
                return false;
            }
            
            const placementTile = placementMap[col][row];
            const surfaceArray = placementTile.surface;
            
            // Check if this tile's surface array contains the expected surface ID
            if (!surfaceArray.includes(expectedSurfaceId)) {
                return false;
            }
        }
        
        return true;
    }

    function getAsset(obj) {
        const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
        if (!assetSource || assetSource.assetIndex == null) return null;
        return gameAssetIndex[assetSource.assetIndex];
    }
    
    function findClusters() {
        function overlaps(a, b) {
            const rectA = a.getBoundingClientRect();
            const rectB = b.getBoundingClientRect();
            
            return !(rectA.right <= rectB.left || 
                    rectA.left >= rectB.right || 
                    rectA.bottom <= rectB.top || 
                    rectA.top >= rectB.bottom);
        }

        const allObjects = document.querySelectorAll('.room-object');
        
        // Fast lookup set for ignored placing indexes
        const ignoredIndexes = new Set([5, 6, 9, 10, 15]);
        
        // Filter objects and get their assets upfront
        const validObjects = [];
        allObjects.forEach(obj => {
            const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
            if (!assetSource || assetSource.assetIndex == null) return;
            
            const asset = gameAssetIndex[assetSource.assetIndex];
            if (!asset || ignoredIndexes.has(asset.placingIndex)) return;
            
            validObjects.push(obj);
        });
        
        const grid = new Map();
        const itemCells = new Map();
        
        // Hash items into grid cells (including cells they span)
        validObjects.forEach(item => {
            const bounds = item.getBoundingClientRect();
            const minCellX = Math.floor(bounds.left / tileSize);
            const maxCellX = Math.floor(bounds.right / tileSize);
            const minCellY = Math.floor(bounds.top / tileSize);
            const maxCellY = Math.floor(bounds.bottom / tileSize);
            
            itemCells.set(item, []);
            
            // Add item to all cells it spans
            for (let cx = minCellX; cx <= maxCellX; cx++) {
                for (let cy = minCellY; cy <= maxCellY; cy++) {
                    const key = `${cx},${cy}`;
                    if (!grid.has(key)) grid.set(key, []);
                    grid.get(key).push(item);
                    itemCells.get(item).push(key);
                }
            }
        });
        
        // Find all overlapping pairs
        const visited = new Set();
        const pairs = [];
        
        validObjects.forEach(item => {
            const cells = itemCells.get(item);
            const candidates = new Set();
            
            // Get all items in the same cells
            cells.forEach(cellKey => {
                grid.get(cellKey).forEach(other => {
                    if (other !== item) candidates.add(other);
                });
            });
            
            // Check actual overlaps
            candidates.forEach(other => {
                const pairKey = [item.id, other.id].sort().join('-');
                if (!visited.has(pairKey) && overlaps(item, other)) {
                    visited.add(pairKey);
                    pairs.push([item, other]);
                }
            });
        });
        
        return pairs;
    } 
    
    document.querySelectorAll('.room-object').forEach(obj => {
        updateOverlapCache(obj.id);
    });
}

// Helper functions
function findOverlappingItems(targetItem) {
    const overlapping = [];
    const targetRect = targetItem.getBoundingClientRect();
    
    const allObjects = document.querySelectorAll('.room-object');
    const ignoredIndexes = new Set([5, 6, 9, 10, 15]);
    
    allObjects.forEach(obj => {
        if (obj.id === targetItem.id) return;
        
        const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
        if (!assetSource || assetSource.assetIndex == null) return;
        
        const asset = gameAssetIndex[assetSource.assetIndex];
        if (!asset || ignoredIndexes.has(asset.placingIndex)) return;
        
        const objRect = obj.getBoundingClientRect();
        
        if (!(targetRect.right <= objRect.left || 
                targetRect.left >= objRect.right || 
                targetRect.bottom <= objRect.top || 
                targetRect.top >= objRect.bottom)) {
            overlapping.push(obj);
        }
    });
    
    return overlapping;
}

// Store previous overlaps for each item (call this once on initialization or after full z-index update)
const itemOverlapCache = new Map();

function updateOverlapCache(itemId) {
    const item = document.getElementById(itemId);
    if (!item) return;
    
    const overlaps = findOverlappingItems(item);
    itemOverlapCache.set(itemId, new Set(overlaps.map(obj => obj.id)));
}

// Update z-index for a single item (call after moving or adding an item)
function updateSingleItemZIndex(itemId) {
    const itemsInFrontOfPetClasses = ['food-bowl', 'water-bowl'];
    const item = document.getElementById(itemId);
    if (!item) return;
    
    const rowZIndexMap = generateRowZIndexMap(roomLayout);
    
    // Get previous overlaps from cache
    const previousOverlaps = itemOverlapCache.get(itemId) || new Set();
    
    // Find current overlaps
    const currentOverlaps = findOverlappingItems(item);
    const currentOverlapIds = new Set(currentOverlaps.map(obj => obj.id));
    
    // Items that need z-index recalculation:
    // 1. The moved item itself
    // 2. Items that were previously overlapped but aren't anymore
    // 3. Items that are newly overlapped
    const affectedItemIds = new Set([itemId]);
    
    // Add previously overlapped items
    previousOverlaps.forEach(id => affectedItemIds.add(id));
    
    // Add currently overlapped items
    currentOverlapIds.forEach(id => affectedItemIds.add(id));
    
    // Update cache for moved item
    itemOverlapCache.set(itemId, currentOverlapIds);
    
    // Recalculate z-index for all affected items using same logic as main function
    affectedItemIds.forEach(id => {
        const obj = document.getElementById(id);
        if (!obj) return;
        
        const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
        if (!assetSource || assetSource.assetIndex == null) return;
        
        const asset = gameAssetIndex[assetSource.assetIndex];
        if (!asset) return;
        
        const coords = getObjectCoordinates(obj.id);
        if (!coords) return;
        
        const [x, y] = coords;
        const width = Math.ceil(obj.offsetWidth / unitSize);
        const height = Math.ceil(obj.offsetHeight / unitSize);
        const bottomRow = y;
        
        // FLOORING
        if (asset.placingIndex === 5) {
            obj.style.zIndex = 1;
            return;
        }
        
        // CARPETS
        if (asset.placingIndex === 6) {
            obj.style.zIndex = 2;
            return;
        }
        
        // WALK-ON ITEMS
        if (asset.walkOn) {
            obj.style.zIndex = 3;
            return;
        }
        
        // Get all tiles occupied by this object
        const occupiedTiles = getTilesOccupiedByObject(coords, width, height);
        
        // Check if entirely on wall tiles
        let isWallOnly = true;
        
        occupiedTiles.forEach(([tileX, tileY]) => {
            if (tileY >= 0 && tileY < roomLayout.length && 
                tileX >= 0 && tileX < roomLayout[0].length) {
                const tileType = roomLayout[tileY][tileX];
                const type = tileType?.type ?? tileType;
                
                if (type === 1.0) {
                    isWallOnly = false;
                    return;
                }
            }
        });
        
        if (isWallOnly) {
            // Keep original z-index for wall-only items
            obj.style.zIndex = '';
        } else {
            // Floor/boundary items: use bottom row z-index
            const zIndex = rowZIndexMap[bottomRow]?.[x];
            if (zIndex) {
                obj.style.zIndex = zIndex;
                if (itemsInFrontOfPetClasses.some(cls => obj.classList.contains(cls))) {
                    obj.style.zIndex = Number(obj.style.zIndex) + 1;
                }
            }
        }
    });
    
    // Handle placement relationships among affected items
    const affectedPairs = findOverlappingPairsAmongItems(Array.from(affectedItemIds));
    
    affectedPairs.forEach(([itemA, itemB]) => {
        const assetA = getAsset(itemA);
        const assetB = getAsset(itemB);
        
        let placed;
        let surface;
        
        if (!assetA || !assetB) return;
        
        const aCanBeOnB = assetA.canBePlacedOn.includes(assetB.placingIndex);
        const bCanBeOnA = assetB.canBePlacedOn.includes(assetA.placingIndex);
        
        if (aCanBeOnB) {
            placed = itemA;    // Object being placed
            surface = itemB;   // Object it's placed on
        }
        
        if (bCanBeOnA) {
            placed = itemB;
            surface = itemA;
        }
        
        if (aCanBeOnB || bCanBeOnA) {
            const wallOnlyItems = checkIfWallOnly(surface);
            
            if (!wallOnlyItems) {
                const placedCoords = getObjectCoordinates(placed.id);
                const placedWidth = Math.ceil(placed.offsetWidth / unitSize);
                const placedHeight = Math.ceil(placed.offsetHeight / unitSize);
                const placedTiles = getTilesOccupiedByObject(placedCoords, placedWidth, placedHeight);
                const maxY = Math.max(...placedTiles.map(c => c[1]));
                const placedBottomRowTiles = placedTiles.filter(c => c[1] === maxY);
                
                const placedObjectIsInSurfacesAllowedTiles = areAllBottomRowTilesOnSurfaceAllowedTiles(
                    generatePlacementMap(placed.id), 
                    placedBottomRowTiles, 
                    surface.id
                );
                
                if (placedObjectIsInSurfacesAllowedTiles) {
                    const z = window.getComputedStyle(surface).zIndex;
                    const surfaceZindex = z === 'auto' ? 0 : parseInt(z, 10);
                    placed.style.zIndex = surfaceZindex + 1;
                }
            }
        }
    });
    
    function findOverlappingPairsAmongItems(itemIds) {
        const pairs = [];
        const items = itemIds.map(id => document.getElementById(id)).filter(Boolean);
        
        for (let i = 0; i < items.length; i++) {
            for (let j = i + 1; j < items.length; j++) {
                const itemA = items[i];
                const itemB = items[j];
                
                const rectA = itemA.getBoundingClientRect();
                const rectB = itemB.getBoundingClientRect();
                
                if (!(rectA.right <= rectB.left || 
                      rectA.left >= rectB.right || 
                      rectA.bottom <= rectB.top || 
                      rectA.top >= rectB.bottom)) {
                    pairs.push([itemA, itemB]);
                }
            }
        }
        
        return pairs;
    }
    
    function checkIfWallOnly(obj) {
        const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
        if (!assetSource || assetSource.assetIndex == null) return false;
        
        const asset = gameAssetIndex[assetSource.assetIndex];
        if (!asset) return false;
        
        const coords = getObjectCoordinates(obj.id);
        if (!coords) return false;
        
        const [x, y] = coords;
        const width = Math.ceil(obj.offsetWidth / unitSize);
        const height = Math.ceil(obj.offsetHeight / unitSize);
        
        const occupiedTiles = getTilesOccupiedByObject([x, y], width, height);
        
        let isWallOnly = true;
        occupiedTiles.forEach(([tileX, tileY]) => {
            if (tileY >= 0 && tileY < roomLayout.length && 
                tileX >= 0 && tileX < roomLayout[0].length) {
                const tileType = roomLayout[tileY][tileX];
                const type = tileType?.type ?? tileType;
                
                if (type === 1.0) {
                    isWallOnly = false;
                }
            }
        });
        
        return isWallOnly;
    }
    
    function areAllBottomRowTilesOnSurfaceAllowedTiles(placementMap, placedBottomRowTiles, expectedSurfaceId) {
        for (const tile of placedBottomRowTiles) {
            const [row, col] = tile;
            
            if (col >= placementMap.length || row  >= placementMap[0].length) {
                return false;
            }
            
            const placementTile = placementMap[col][row];
            const surfaceArray = placementTile.surface;
            
            if (!surfaceArray.includes(expectedSurfaceId)) {
                return false;
            }
        }
        
        return true;
    }
    
    function getAsset(obj) {
        const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
        if (!assetSource || assetSource.assetIndex == null) return null;
        return gameAssetIndex[assetSource.assetIndex];
    }
}

// Set z-index for pets dynamically (call whenever pet moves)
function setPetZIndex(pet) {
    if (!pet) return;
    
    const rowZIndexMap = generateRowZIndexMap(roomLayout);
    const coords = getObjectCoordinates(pet.id);
    
    if (!coords) return;
    
    const [x, y] = coords;
    const bottomRow = y;
    
    // Set pet z-index to the row it's on
    const zIndex = rowZIndexMap[bottomRow]?.[x];
    if (zIndex) {
        pet.style.zIndex = zIndex;
    }
}

// Call this once when room is initialized
function initializeRoomZIndexes() {
    if (!roomLayout || !userObjectAssets || !gameAssetIndex) {
        console.error('Required data not available');
        return;
    }
    setRoomObjectZIndexes();
    updatePetZIndexes();
}

// Replacement for predictAndSetZIndex - just updates pets
function updatePetZIndexes() {
    const allPets = document.querySelectorAll('.pet');
    allPets.forEach(pet => {
        setPetZIndex(pet, roomLayout);
    });
}

function generateWalkabilityMap() {
    // Add safety check for roomLayout
    if (!roomLayout || roomLayout.length === 0) {
        console.error("roomLayout is not defined or empty");
        return null;
    }

    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const map = [];

    // Initialize map with basic walkability
    for (let row = 0; row < roomLayout.length; row++) {
        map[row] = [];
        for (let col = 0; col < roomLayout[0].length; col++) {
            const tileType = roomLayout[row][col];
            // Only floor (1) and boundary (3) tiles are walkable
            const isWalkable = (tileType === 1.0 || tileType === 3.0 || tileType === 5.0 || tileType === 6.0);
            map[row][col] = {
                walkable: isWalkable,
                allowedDirections: [true, true, true, true] // up, right, down, left
            };
        }
    }

    // Apply boundary tile restrictions (with safety checks)
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (roomLayout[row][col] === 3) { // boundary tile
                let hasNonWalkOnBelow = false;

                if (userObjectAssets && gameAssetIndex) {
                    Object.entries(userObjectAssets).forEach(([assetId, asset]) => {
                        const assetData = gameAssetIndex[asset.assetIndex];
                        if (!assetData) return;

                        const [assetX, assetY] = asset.position;
                        const element = document.getElementById(assetId);
                        if (!element) return;

                        const assetWidth = Math.ceil(element.offsetWidth / unitSize);
                        const assetHeight = Math.ceil(element.offsetHeight / unitSize);
                        const topRowOfAsset = assetY - assetHeight + 1;
                        const bottomRowOfAsset = assetY;

                        // Only consider non-walk-on assets
                        if (!assetData.walkOn) {
                            // Check if asset overlaps row+1 or row+2
                            for (let r = row + 1; r <= row + 2; r++) {
                                if (r >= topRowOfAsset && r <= bottomRowOfAsset && col >= assetX && col < assetX + assetWidth) {
                                    hasNonWalkOnBelow = true;
                                    break;
                                }
                            }
                        }
                    });
                }

                if (hasNonWalkOnBelow) {
                    map[row][col].walkable = false;       // boundary row
                    if (row + 1 < roomLayout.length) {
                        map[row + 1][col].walkable = false; // row immediately below
                    }
                }
            }
        }
    }



    // Set directional movement restrictions (with safety checks)
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {

            if (!map[row][col].walkable) continue;

            if (userObjectAssets && gameAssetIndex) {
                Object.entries(userObjectAssets).forEach(([assetId, asset]) => {

                    const assetData = gameAssetIndex[asset.assetIndex];
                    if (!assetData) return;

                    const [assetX, assetY] = asset.position;
                    const element = document.getElementById(assetId);
                    if (!element) return;

                    const assetWidth = Math.ceil(element.offsetWidth / unitSize);
                    const assetHeight = Math.ceil(element.offsetHeight / unitSize);

                    const topRowOfAsset = assetY - assetHeight + 1;
                    const bottomRowOfAsset = assetY;
                    const rowAboveBottom = bottomRowOfAsset - 1;

                    // --- FOOD-BOWL SPECIAL LOGIC -----------------------------------
                    if (element.className.includes('food-bowl')) {

                        // Block movement on the bowl tile itself
                        if (
                            row === bottomRowOfAsset &&
                            col >= assetX &&
                            col < assetX + assetWidth
                        ) {
                            map[row][col].allowedDirections[2] = false; // down
                        }

                        // Block movement on tile beneath the bowl
                        if (
                            row === bottomRowOfAsset + 1 &&
                            col >= assetX &&
                            col < assetX + assetWidth
                        ) {
                            map[row][col].allowedDirections[0] = false; // up
                        }
                    }

                    // --- STANDARD NON-WALK-ON LOGIC -------------------------------
                    if (!assetData.walkOn) {

                        if (assetHeight === 1 || assetHeight === 2) {
                            // Block both up & down on bottom tile
                            if (
                                row === bottomRowOfAsset &&
                                col >= assetX &&
                                col < assetX + assetWidth
                            ) {
                                map[row][col].allowedDirections[0] = false; // up
                                map[row][col].allowedDirections[2] = false; // down
                            }
                        } else {
                            // Block up on bottom tile
                            if (
                                row === bottomRowOfAsset &&
                                col >= assetX &&
                                col < assetX + assetWidth
                            ) {
                                map[row][col].allowedDirections[0] = false; // up
                            }

                            // Block down on tile above bottom
                            if (
                                row === rowAboveBottom &&
                                col >= assetX &&
                                col < assetX + assetWidth
                            ) {
                                map[row][col].allowedDirections[2] = false; // down
                            }
                        }
                    }

                    // --- NON-STEPPABLE ASSET LOGIC ---------------------------------
                    if (!assetData.walkBehind) {

                        for (let r = topRowOfAsset; r <= bottomRowOfAsset; r++) {
                            if (!map[r]) continue;

                            for (let c = assetX; c < assetX + assetWidth; c++) {
                                if (!map[r][c]) continue;

                                if (r === topRowOfAsset) {
                                    // Top row: block only downward
                                    map[r][c].allowedDirections[2] = false;
                                } else {
                                    // Other rows: cannot stand or walk here
                                    map[r][c].walkable = false;
                                }
                            }
                        }
                    }

                }); // end forEach
            }
        }
    }

    return map;
}


function isOverlapping(petObject, targetObject) {
    const overlappingObjects = detectTileCollision(petObject.id);
    return overlappingObjects.includes(targetObject);
}

function findPetOverlapClusters(data) {
    const idToKey = {}; // map key -> element id
    for (const key of Object.keys(data)) {
        idToKey[key] = key;
    }

    // Step 1: Build overlap graph
    const overlapGraph = {}; // node id -> Set of overlapping node ids

    for (const keyA of Object.keys(data)) {
        const objA = document.getElementById(idToKey[keyA]);
        if (!objA) continue;

        for (const keyB of Object.keys(data)) {
            if (keyA === keyB) continue;

            const objB = document.getElementById(idToKey[keyB]);
            if (!objB) continue;

            if (isOverlapping(objA, objB)) {
                if (!overlapGraph[keyA]) overlapGraph[keyA] = new Set();
                if (!overlapGraph[keyB]) overlapGraph[keyB] = new Set();

                overlapGraph[keyA].add(keyB);
                overlapGraph[keyB].add(keyA);
            }
        }
    }

    // Step 2: Find connected components via DFS/BFS
    const visited = new Set();
    const clusters = [];

    function dfs(node, cluster) {
        visited.add(node);
        cluster.push(node);
        (overlapGraph[node] || []).forEach(neighbor => {
            if (!visited.has(neighbor)) dfs(neighbor, cluster);
        });
    }

    for (const key of Object.keys(data)) {
        if (!visited.has(key)) {
            const cluster = [];
            dfs(key, cluster);

            const hasPet = cluster.some(k => document.getElementById(idToKey[k]).classList.contains('pet'));
            const hasNonPet = cluster.some(k => !document.getElementById(idToKey[k]).classList.contains('pet'));

            // Include cluster only if it has at least one pet AND (more than one node or includes a non-pet)
            if (hasPet && (cluster.length > 1 || hasNonPet)) {
                clusters.push(cluster);
            }
        }
    }

    return clusters;
}

function cancelMovement(objectId) {
    const object = document.getElementById(objectId);
    if (activeMovements.has(objectId)) {
        const movement = activeMovements.get(objectId);
        clearTimeout(movement.interval);
        if (object) {
            object.style.transition = '';
        }
        activeMovements.delete(objectId);
        if (object && object.classList.contains("pet")) {
            setObjectAnimation(object, `${object.id}-stands-idle`);
        }
    } else {
        setObjectAnimation(object, `${object.id}-stands-idle`);
    }
}

// Alternative approach: get computed style instead of parsing calc()
function getObjectCoordinates(objectId) {
    const object = document.getElementById(objectId);
    if (!object) return null;

    // Get the unit size
    const unit = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

    // Get computed style (actual pixel values after calc() is processed)
    const computedStyle = window.getComputedStyle(object);
    const leftPx = parseInt(computedStyle.left) || 0;
    const topPx = parseInt(computedStyle.top) || 0;

    const elementHeight = object.offsetHeight; // actual pixel height of element
    const botPx = topPx + elementHeight;

    // Calculate tile coordinates
    const tileX = Math.round(leftPx / unit);
    let tileY;
    tileY = Math.round(botPx / unit) - 1;

    return [tileX, tileY];
}

function detectTileCollision(objectId) {
    const movingObject = document.getElementById(objectId);
    if (!movingObject) return [];

    // Get the moving object's tile position
    const movingObjPos = getObjectCoordinates(objectId);
    if (!movingObjPos) return [];

    const [movingX, movingY] = movingObjPos;

    // Calculate the size of the moving object in tiles
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const movingWidth = Math.ceil(movingObject.offsetWidth / unitSize);
    const movingHeight = Math.ceil(movingObject.offsetHeight / unitSize);

    const overlappingObjects = [];

    // Get all room objects (excluding the moving object)
    const allObjects = document.querySelectorAll('.room-object');

    // Check against all other objects
    allObjects.forEach(targetObj => {
        // Skip the moving object itself
        if (targetObj.id === objectId) return;

        // Get the target object's tile position
        const targetPos = getObjectCoordinates(targetObj.id);
        if (!targetPos) return;

        const [targetX, targetY] = targetPos;

        // Calculate the size of the target object in tiles
        const targetWidth = Math.ceil(targetObj.offsetWidth / unitSize);
        const targetHeight = Math.ceil(targetObj.offsetHeight / unitSize);

        // Check for tile-based collision
        if (movingX < targetX + targetWidth &&
            movingX + movingWidth > targetX &&
            movingY < targetY + targetHeight &&
            movingY + movingHeight > targetY) {
            
            // Collision detected - highlight the colliding object
            targetObj.classList.add('collision-highlight');
            setTimeout(() => {
                targetObj.classList.remove('collision-highlight');
            }, 1000);

            overlappingObjects.push(targetObj); // Add the overlapping DOM element
        }
    });

    return overlappingObjects; // Return array of overlapping DOM elements
}

function getRandomItemFromACategory(category) {
  const container = document.getElementById("room-container");
  if (!container) {
    console.warn("No container with id 'room-container' found.");
    return null;
  }

  const objects = Array.from(container.querySelectorAll(`.${category}`));
  if (objects.length === 0) {
    console.warn("No .food-bowl elements found inside #room-container.");
    return null;
  }

  // Filter bowls that also have the "full" class
  const fullBowls = objects.filter(bowl => bowl.classList.contains("full"));

  // Choose from full ones if available, otherwise from all bowls
  const candidates = fullBowls.length > 0 ? fullBowls : objects;

  const randomIndex = Math.floor(Math.random() * candidates.length);
  return candidates[randomIndex];
}


// Function to change cat background image
function changeCatFacingDirection(pet, direction) {
    if (pet) {
        if (direction === 'left') {
            pet.classList.remove("pet-right");
            pet.classList.add("pet-left");
        } else {
            pet.classList.remove("pet-left");
            pet.classList.add("pet-right");
        }
    } else {
        console.warn("Pet element not found!");
    }
}

async function sendObjectAssetsUpdateToDatabase() {
    const originalObjectAssets = JSON.parse(JSON.stringify(userObjectAssets));
    
    let objectAssetsString = JSON.stringify(
        Object.values(userObjectAssets).map(entry => [entry.assetIndex, entry.position])
    );

    try {
        const response = await apiFetch(apiBase + 'petGame/objectAssets', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId, objectAssets: objectAssetsString })
        });

        if (!response) {
            return false;
        }

        if (response.ok && response.status === 204) {
            return true;
        } else {
            userObjectAssets = originalObjectAssets;
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.error(`Failed to update object assets: ${response.status}`);
            return false;
        }
    } catch (error) {
        userObjectAssets = originalObjectAssets;
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.log('Error sending Objects Asset position update:', error);
        return false;
    }
}

async function sendPetAssetsUpdateToDatabase() {
    const originalPetAssets = JSON.parse(JSON.stringify(userPetAssets));
    
    let petAssetsString = JSON.stringify(convertUserPetAssetsDictToCompactList(userPetAssets));

    try {
        const response = await apiFetch(apiBase + 'petGame/petAssets', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId, petAssets: petAssetsString })
        });

        if (!response) {
            return false;
        }

        if (response.ok && response.status === 204) {
            return true;
        } else {
            userPetAssets = originalPetAssets;
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.error(`Failed to update pet assets: ${response.status}`);
            return false;
        }
    } catch (error) {
        userPetAssets = originalPetAssets;
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.log('Error sending Pet Asset update:', error);
        return false;
    }
}

async function sendMoneyTransactionToDatabase(amount, type = 'subtract') {
    try {
        const response = await apiFetch(apiBase + 'petGame/transaction', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                studentId: userData.userId, 
                amount: amount,
                type: type 
            })
        });

        if (!response) {
            return false;
        }

        if (response.ok && response.status === 204) {
            return true;
        } else if (response.status === 400) {
            const data = await response.json();
            if (data.error === 'insufficient_funds') {
                messageToTheUser("Nepakanka pinig!", 'error');
            }
            return false;
        } else {
            return false;
        }
    } catch (error) {
        console.log('Error sending money transaction:', error);
        return false;
    }
}

function updateCoinAmounts(money) {
    document.querySelectorAll('.coin-amount').forEach(span => {
        span.textContent = money.toFixed(1);
    });
}

async function sendPetStatsUpdateToDatabase(petId) {
    const pet = document.getElementById(petId);
    if (!pet?._stats) return false;

    const statList = [
            pet._stats.foodNew,
            pet._stats.waterNew,
            pet._stats.loveNew,
            Math.floor(Date.now() / 1000 / 60)
        ]

    const petsArray = [
        [petId, statList]
    ];

    try {
        const response = await apiFetch(apiBase + 'petGame/petStats', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ studentId: userData.userId, petStats: petsArray })
        });

        if (!response) {
            return;
        }

        if (response.ok) {
            document.querySelector('.some-pet-element')?.classList.add('tick-svg');

            updatePetOnWalkStatsInLocalStorage(petId, statList)

            return true;
        } else {
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.error(`Failed to update pet stats: ${response.status}`);
            return false;
        }
    } catch (error) {
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.error('Error sending pet stats update:', error);
        return false;
    }
}


function updateObjectPositionChanges() {
    const container = document.getElementById("roomObjectsContainer");

    // Loop through all items in userObjectAssets
    for (const [key, asset] of Object.entries(userObjectAssets)) {
        const div = container.querySelector(`#${key}`); // find div by id

        if (div) {
            // Div exists  get tile coordinates and update
            const newCoords = getObjectCoordinates(key); // assume returns [x, y]
            asset.position = newCoords;
        } else {
            // Div not present  set position to empty list
            asset.position = [];
        }
    }

    // Group stackable items by assetIndex
    const stackableGroups = {};

    for (const key in userObjectAssets) {
        const asset = userObjectAssets[key];
        const assetIndex = asset.assetIndex;
        const item = gameAssetIndex[assetIndex];
        if (!item) continue;

        if (item.stackable) {
            if (!stackableGroups[assetIndex]) {
                stackableGroups[assetIndex] = [];
            }
            stackableGroups[assetIndex].push(key);
        }
    }

    // Clean up excess unused stackable instances (keep only 1 unused per type)
    for (const assetIndex in stackableGroups) {
        const keys = stackableGroups[assetIndex];
        const unusedKeys = keys.filter(k => 
            !userObjectAssets[k].position || userObjectAssets[k].position.length === 0
        );

        // If more than 1 unused instance, delete extras (but always keep at least 1)
        if (unusedKeys.length > 1) {
            for (let i = 1; i < unusedKeys.length; i++) {
                delete userObjectAssets[unusedKeys[i]];
            }
        }
    }

    // Send updated objectAssets to database
    sendObjectAssetsUpdateToDatabase();
}

const toggleEditSaveBtn = document.getElementById("toggle-edit-save-btn");
const cancelEditBtn = document.getElementById("cancel-edit-btn");
const deleteSelectedItemBtn = document.getElementById("delete-selected-item-button");

let editing = false;

let preEditUserObjectAssets;

toggleEditSaveBtn.addEventListener("click", () => {
    if (!editing) {
    // switch to Save mode
        preEditUserObjectAssets = JSON.parse(JSON.stringify(userObjectAssets)); //deep copy
        toggleEditSaveBtn.textContent = "Isaugoti";
        toggleEditSaveBtn.classList.remove("edit");
        toggleEditSaveBtn.classList.add("save");
        cancelEditBtn.classList.remove("hidden");
        deleteSelectedItemBtn.classList.remove("hidden");
        const petElements = document.querySelectorAll('.pet');
        petElements.forEach(pet => {
            pet.style.display = 'none';
        });
        updateStatsBeforeRerunningInitGameAndRenderPets();
        enableObjectDragging();
        initializeRoomZIndexes();
        makeSelectedClickable();
        displaySidebar();
        renderObjectAssetsDropdown(sidebar=true);
        editing = true;
    } else {
        updateObjectPositionChanges();
        const petElements = document.querySelectorAll('.pet');
        petElements.forEach(pet => {
            setPetZIndex(pet);
        });
        preEditUserObjectAssets = JSON.parse(JSON.stringify(userObjectAssets));
        updateStatsBeforeRerunningInitGameAndRenderPets();
        renderPets();
        enablePetDragging();
        initializeRoomZIndexes();
        resetEditButtonToggle();
        blockTopHalfOfSelectedDivsClickEvents();
        makeSelectedClickThrough();
        const allPets = document.querySelectorAll("#petContainer .pet");
        if (allPets[0]) {
            displayPetStats(allPets[0].id);
        }
        clearPlacementHighlights()
        removeAllDeleteItemHighlights();
        hideSidebar();
    }
});

cancelEditBtn.addEventListener("click", () => {
    if (editing && preEditUserObjectAssets) {
        userObjectAssets = JSON.parse(JSON.stringify(preEditUserObjectAssets));
    }
    renderRoomObjects();
    resetEditButtonToggle();
    updateStatsBeforeRerunningInitGameAndRenderPets();
    renderPets();
    enablePetDragging();
    blockTopHalfOfSelectedDivsClickEvents();
    makeSelectedClickThrough();
    clearPlacementHighlights()
    removeAllDeleteItemHighlights();
    hideSidebar();
    initializeRoomZIndexes();
    
    const allPets = document.querySelectorAll("#petContainer .pet");
    if (allPets[0]) {
        displayPetStats(allPets[0].id);
    }
});


function updateStatsBeforeRerunningInitGameAndRenderPets() {
    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        increasePetStatsInDisplay(pet.id, "food");
        increasePetStatsInDisplay(pet.id, "water");
        increasePetStatsInDisplay(pet.id, "love");
        petStatsList[pet.id] = [pet._stats.foodNew, pet._stats.waterNew, pet._stats.loveNew, Math.floor(Date.now() / 1000 / 60)]
    });
}

function resetEditButtonToggle() {
    disableObjectDragging();
    const petElements = document.querySelectorAll('.pet');
        petElements.forEach(pet => {
        pet.style.display = 'block';
    });
    toggleEditSaveBtn.textContent = "Perstatyti";
    toggleEditSaveBtn.classList.remove("save");
    toggleEditSaveBtn.classList.add("edit");
    cancelEditBtn.classList.add("hidden");
    deleteSelectedItemBtn.classList.add("hidden");
    editing = false;
}

function getFirstRowOfTileType(number) {
  return roomLayout.findIndex(row => row.includes(number));
}
    
// Global caching system for placement maps
const placementCache = {
    // Map from objectId to precomputed placement map for that object
    placementMaps: new Map(),
    // Map from tile position "x,y" to list of object elements covering that tile
    tileOccupancy: new Map(),
    // Set of all object IDs currently placed in the room
    placedObjects: new Set(),
    // Track room layout changes (incremented when layout changes)
    roomLayoutVersion: 0,
    // Hash of combined assets to detect when objects are added/removed
    combinedAssetsHash: '',
    // Cache for expensive getFirstRowOfTileType calls
    firstRowTileType1: null,
    firstRowTileType3: null
};

// Initialize the placement cache (call when room loads or resets)
function initPlacementCache() {
    placementCache.placementMaps.clear();
    placementCache.tileOccupancy.clear();
    placementCache.placedObjects.clear();
    placementCache.roomLayoutVersion = 0;
    placementCache.combinedAssetsHash = '';
    placementCache.firstRowTileType1 = null;
    placementCache.firstRowTileType3 = null;
}

// Get all assets in the room (user objects + furniture preview if active)
function getCombinedAssets() {
    const combinedAssets = { ...userObjectAssets };
    // Add furniture preview if it exists and has asset data
    if (furniturePreviewDict["furniture-preview"].assetIndex !== null) {
        combinedAssets["furniture-preview"] = furniturePreviewDict["furniture-preview"];
    }
    return combinedAssets;
}

// Create a hash of all object IDs to detect when objects are added/removed
function getCombinedAssetsHash() {
    const combinedAssets = getCombinedAssets();
    // Sort keys for consistent hashing
    return JSON.stringify(Object.keys(combinedAssets).sort());
}

// Check if cache needs to be invalidated due to object changes
function shouldInvalidateCache() {
    const currentHash = getCombinedAssetsHash();
    return currentHash !== placementCache.combinedAssetsHash;
}

// Build a map of which objects occupy which tiles (tile  array of objects)
function buildTileOccupancyMap() {
    // Clear existing occupancy data
    placementCache.tileOccupancy.clear();
    const combinedAssets = getCombinedAssets();
    
    // For each placed object, calculate which tiles it covers
    for (const objectId of placementCache.placedObjects) {
        const objectElement = document.getElementById(objectId);
        if (!objectElement) continue;
        
        // Get object's position and dimensions in tile units
        const coords = getObjectCoordinates(objectId);
        const w = Math.ceil(objectElement.offsetWidth / unitSize);
        const h = Math.ceil(objectElement.offsetHeight / unitSize);
        const tiles = getTilesOccupiedByObject(coords, w, h) || [];
        
        // Add this object to each tile it occupies
        for (const [x, y] of tiles) {
            const key = `${x},${y}`;
            if (!placementCache.tileOccupancy.has(key)) {
                placementCache.tileOccupancy.set(key, []);
            }
            placementCache.tileOccupancy.get(key).push(objectElement);
        }
    }
}

// Get cached first row of floor tiles (type 1) - expensive operation
function getCachedFirstRow1() {
    if (placementCache.firstRowTileType1 === null) {
        placementCache.firstRowTileType1 = getFirstRowOfTileType(1);
    }
    return placementCache.firstRowTileType1;
}

// Get cached first row of boundary tiles (type 3) - expensive operation
function getCachedFirstRow3() {
    if (placementCache.firstRowTileType3 === null) {
        placementCache.firstRowTileType3 = getFirstRowOfTileType(3);
    }
    return placementCache.firstRowTileType3;
}

/**
 * PRE-COMPUTE PLACEMENT MAP FOR A SPECIFIC OBJECT
 * This function contains the ORIGINAL placement logic with caching optimizations
 * 
 * Tile types in roomLayout:
 * 1.0 = Floor
 * 2.0 = Wall  
 * 3.0 = Boundary (wall-floor transition line)
 * 4.0-4.6 = Various obstacle tiles (cannot place on)
 * >= 4 && < 8 = All obstacle tiles
 * 
 * Placing Index Guide:
 * 0: Objects you cannot place on
 * 1: Floor
 * 2: Wall
 * 3: Boundary (items that can have top at the boundary)
 * 4: Boundary-wall (items that can bottom at boundary and overlap wall)
 * 5: Flooring (goes under everything)
 * 6: Carpets (goes under floor objects)
 * 7: Objects that can have smaller things placed on ANY part (tables, window-sills)
 * 8: Small objects that can be placed on other bigger objects (flower pots)
 * 9: Wallpapers (z-index: 1)
 * 10: Wall ornaments that can be placed on walls/windows/windowsills/shelves (z-index: 5)
 * 11: Windows (z-index: 3)
 * 12: Shelves, window sills (z-index: 4)
 * 13: Drapes (z-index: 4)
 * 14: Objects that can have smaller things placed on TOP ROW ONLY (fridges)
 * 15: Baseboards / grindjuostes (z-index: 2)
 */
function precomputePlacementMap(objectId) {
    // Validate game data is loaded
    if (!gameAssetIndex || !userObjectAssets) {
        console.error("Game data not loaded");
        return null;
    }

    // Get combined assets (user objects + preview if active)
    const combinedAssets = getCombinedAssets();
    const draggedAsset = combinedAssets[objectId];
    if (!draggedAsset) {
        console.error("Dragged object not found in combinedAssets");
        return null;
    }
    
    // Get asset data for the dragged object
    const draggedAssetData = gameAssetIndex[draggedAsset.assetIndex];
    if (!draggedAssetData) {
        console.error("Asset data not found for dragged object");
        return null;
    }

    // Get DOM element for the dragged object (for dimensions)
    const draggedElement = document.getElementById(objectId);
    if (!draggedElement) {
        console.error("Dragged element not found in DOM");
        return null;
    }

    // Calculate object dimensions in tile units
    const objectWidth = Math.ceil(draggedElement.offsetWidth / unitSize);
    const objectHeight = Math.ceil(draggedElement.offsetHeight / unitSize);
    
    // Get the object's placement rules and type
    const draggedAssetPlacingRules = draggedAssetData.canBePlacedOn || [];
    const draggedAssetPlacingIndex = draggedAssetData.placingIndex || 0;
    const draggedPlacingBuffer = draggedAssetData.placingBuffer || [];

    // Room layout reference and dimensions
    const rl = roomLayout;
    const roomRows = rl.length;
    const roomCols = rl[0].length;

    // Initialize placement map (grid with two-tier system)
    const placementMap = [];
    for (let r = 0; r < roomRows; r++) {
        placementMap[r] = [];
        for (let c = 0; c < roomCols; c++) {
            placementMap[r][c] = { canPlace: false, canOccupy: false, surface: [] };
        }
    }

    // Caches for this computation only
    const placingIndexCache = new Map();
    const tileOccupancyCache = new Map();
    const placementRangesCache = new Map();
    const protrusionSettingCache = new Map();
    
    function getPlacingIndex(objectElement) {
        const id = objectElement.id;
        if (placingIndexCache.has(id)) return placingIndexCache.get(id);

        const asset = combinedAssets[id];
        if (!asset) return 0;

        const assetData = gameAssetIndex[asset.assetIndex];
        if (!assetData) return 0; // wait until assetData exists

        const idx = assetData.placingIndex || 0;

        placingIndexCache.set(id, idx);

        return idx;
    }

    // Helper: Get placing index for an object (with caching)
    function getProtrusionSetting(objectElement) {
        const id = objectElement.id;
        if (protrusionSettingCache.has(id)) return protrusionSettingCache.get(id);

        const asset = combinedAssets[id];
        if (!asset) return 0;

        const assetData = gameAssetIndex[asset.assetIndex];
        if (!assetData) return 0;

        const protrusionSetting = (assetData && assetData.protruding) || 0;

        protrusionSettingCache.set(id, protrusionSetting);
        return protrusionSetting;
    }

    // Helper: Get placement ranges for an object (with caching)
    function getPlacementRanges(objectElement) {
        const id = objectElement.id;
        if (placementRangesCache.has(id)) return placementRangesCache.get(id);

        const asset = combinedAssets[id];
        if (!asset) return [];

        const assetData = gameAssetIndex[asset.assetIndex];
        if (!assetData) return [];

        const w = Math.ceil(objectElement.offsetWidth / unitSize);
        const h = Math.ceil(objectElement.offsetHeight / unitSize);
        if (!w || !h) return [];

        const ranges = assetData.placementRanges || [[0, w-1, 0, h-1]];

        placementRangesCache.set(id, ranges);

        return ranges;
    }

    // Helper: Get objects at a specific tile (fast, uses precomputed occupancy)
    function getObjectsAtTileFast(x, y) {
        const key = `${x},${y}`;
        if (tileOccupancyCache.has(key)) return tileOccupancyCache.get(key);
        
        const objects = placementCache.tileOccupancy.get(key) || [];
        tileOccupancyCache.set(key, objects);
        return objects;
    }

    // Helper to check if a tile is within placement ranges
    function isWithinPlacementRanges(tileX, tileY, baseX, baseY, ranges) {
        if (!ranges || ranges.length === 0) return true; // Empty means all tiles allowed
        
        // Convert tile position to relative coordinates from bottom-left of base object
        const relX = tileX - baseX;
        const relY = baseY - tileY;
        
        // Check if tile is within any of the allowed ranges
        for (const range of ranges) {
            const [xStart, xEnd, yStart, yEnd] = range;
            if (relX >= xStart && relX <= xEnd && relY >= yStart && relY <= yEnd) {
                return true;
            }
        }
        return false;
    }

    function getValidPlacementTiles(
        baseObj,
        baseTiles,
        baseCoords,
        baseWidth,
        baseHeight,
        placingIndex
    ) {
        const ranges = getPlacementRanges(baseObj);
        const [baseX, baseY] = baseCoords;

        // Apply placement ranges
        let validTiles = baseTiles.filter(([tx, ty]) =>
            isWithinPlacementRanges(tx, ty, baseX, baseY, ranges)
        );

        if (!validTiles.length) {
            return []
        } else {
            return validTiles;
        }
    }

    // Helper to get valid placement tiles with buffer applied
    function addBufferToSection(validTiles) {
        // Apply buffer RECTANGULARLY (fixes corners)
        if (draggedPlacingBuffer && draggedPlacingBuffer.length === 4) {
            const [top, right, bottom, left] = draggedPlacingBuffer;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            // Bounding box of ranged tiles
            for (const [x, y] of validTiles) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }

            // Expand by buffer
            minX -= left;
            maxX += right;
            minY -= top;
            maxY += bottom;

            // Clamp to room bounds
            minX = Math.max(0, minX);
            minY = Math.max(0, minY);
            maxX = Math.min(roomCols - 1, maxX);
            maxY = Math.min(roomRows - 1, maxY);

            const bufferedTiles = [];

            // Fill full rectangle (includes corners)
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    bufferedTiles.push([x, y]);
                }
            }

            return bufferedTiles;
        }

        return validTiles;
    }

    // ========== MAIN PLACEMENT LOGIC LOOP ==========
    for (let row = 0; row < roomRows; row++) {
        for (let col = 0; col < roomCols; col++) {
            let rightEndofSection = col + objectWidth - 1;
            let topOfSection = row;
            let bottomOfSection = topOfSection + objectHeight - 1;

            if (rightEndofSection >= roomCols || bottomOfSection >= roomRows) {
                continue;
            }

            let sectionAllowed = true;

            for (let y = row; y <= bottomOfSection; y++) {
                for (let x = col; x <= rightEndofSection; x++) {
                    let tileAllowed = true;
                    const tile = rl[y][x];
                    const tileType = tile.type ?? tile;


                    // RULE 1: Cannot place on obstacle tiles (type 4-7)
                    if (tileType >= 4 && tileType < 8) {
                        tileAllowed = false;
                    }
                    // RULE 2: Floor tiles
                    else if (tileType === 1.0) {
                        if (!draggedAssetPlacingRules.includes(1)) {
                            tileAllowed = false;
                        }
                    }
                    // RULE 3: Wall/Boundary tiles
                    else if (tileType === 2.0 || tileType === 3.0) {
                        if (!draggedAssetPlacingRules.includes(2)) {
                            if (draggedAssetPlacingRules.includes(4)) {
                                const bottomSupportTile = rl[bottomOfSection][x];
                                if (
                                    (bottomSupportTile === 1 && draggedAssetPlacingRules.includes(1)) ||
                                    (bottomSupportTile === 3 && draggedAssetPlacingRules.includes(3))
                                ) {
                                    tileAllowed = true;
                                } else {
                                    tileAllowed = false;
                                }
                            } else {
                                if (tileType === 3.0 && draggedAssetPlacingRules.includes(3)) {
                                    tileAllowed = true;
                                } else {
                                    tileAllowed = false;
                                }
                            }
                        } else {
                            tileAllowed = true;
                        }
                    }

                    // OBJECT-OBJECT INTERACTION CHECKS

                    // SKIPPING OBJECTS THAT ALL OTHER OBJECTS CAN OVERLAP (wallpaper, flooring, carpets, etc.)
                    // THIS ALLOWS TO PLACE THESE ITEMS UNDER OTHER ITEMS WITHOUT MOVING THEM
                    if (!PLACING_INDEXES_TO_BE_IGNORED.has(draggedAssetPlacingIndex)) {
                        
                        let objectsAtTile = getObjectsAtTileFast(x, y);

                        for (const existingObj of objectsAtTile) {
                            const existingPlacingIndex = getPlacingIndex(existingObj);

                            if (PLACING_INDEXES_TO_BE_IGNORED.has(existingPlacingIndex)) continue

                            // PREVENTS SAME TYPE OF OBJECTS BEING PLACED ON TOP OF EACH OTHER
                            if (draggedAssetPlacingIndex === existingPlacingIndex) {
                                tileAllowed = false;
                                break;
                            }

                            // ENABLE OFVERLAP OF WALL ITEMS BY BOUNDARY-WALL ITEMS - ENABLE BOUNDARY TILES
                            if ((draggedAssetPlacingRules.includes(4)) && 
                                !draggedAssetPlacingRules.includes(2)) {
                                if (tileType === 2.0) {
                                    if (draggedAssetPlacingRules.includes(3)) {
                                        if (getCachedFirstRow3() - (objectHeight - 1) <= row) {
                                            tileAllowed = true;
                                            break;
                                        }
                                    } else if (draggedAssetPlacingRules.includes(1)) {
                                        if (getCachedFirstRow1() - (objectHeight - 1) <= row) {
                                            tileAllowed = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            // CHECK IF ITEM CAN BE PLACED ON EXISTING ITEM
                            if (!draggedAssetPlacingRules.includes(existingPlacingIndex)) {
                                tileAllowed = false;
                                break;
                            } else {
                                // SPECIAL CASE A: Shelves/Window Sills (12) on Windows (11) - ONLY BOTTOM TO ROWS ARE ALLOWED
                                if (existingPlacingIndex === 11 && draggedAssetPlacingIndex === 12) {
                                    const coords = getObjectCoordinates(existingObj.id);
                                    const w = Math.ceil(existingObj.offsetWidth / unitSize);
                                    const h = Math.ceil(existingObj.offsetHeight / unitSize);
                                    const tilesOccupiedByWindow = getTilesOccupiedByObject(coords, w, h) || [];
                                    const maxY = Math.max(...tilesOccupiedByWindow.map(c => c[1]));
                                    const bottomRowTiles = tilesOccupiedByWindow.filter(c => c[1] === maxY);
                                    const oneAboveBottomRowTiles = tilesOccupiedByWindow.filter(c => c[1] === maxY - 1);
                                    const relevantTiles = [...bottomRowTiles, ...oneAboveBottomRowTiles];
                                    
                                    const validTiles = getValidPlacementTiles(
                                        existingObj, relevantTiles, coords, w, h, existingPlacingIndex
                                    );
                                    
                                    if (validTiles.some(c => c[0] === x && c[1] === y)) {
                                        tileAllowed = true;
                                    } else {
                                        tileAllowed = false;
                                        break;
                                    }
                                }
                                // SPECIAL CASE B: Drapes (13) on Windows (11) - ALL BUT BOTTOM ROW ARE ALLOWED
                                else if (existingPlacingIndex === 11 && draggedAssetPlacingIndex === 13) {
                                    const coords = getObjectCoordinates(existingObj.id);
                                    const w = Math.ceil(existingObj.offsetWidth / unitSize);
                                    const h = Math.ceil(existingObj.offsetHeight / unitSize);
                                    const tilesOccupiedByWindow = getTilesOccupiedByObject(coords, w, h) || [];
                                    const maxY = Math.max(...tilesOccupiedByWindow.map(c => c[1]));
                                    const windowTilesOtherThanBottom = tilesOccupiedByWindow.filter(c => c[1] !== maxY);
                                    
                                    const validTiles = getValidPlacementTiles(
                                        existingObj, windowTilesOtherThanBottom, coords, w, h, existingPlacingIndex
                                    );
                                    
                                    if (validTiles.some(c => c[0] === x && c[1] === y)) {
                                        tileAllowed = true;
                                    } else {
                                        tileAllowed = false;
                                        break;
                                    }
                                }

                                // GENERAL CASE A: ITEMS THAT CAN BE PLACED ON OTHER ITEMS WITHOUT PROTRUDING
                                else if (draggedAssetPlacingRules.includes(existingPlacingIndex)) {
                                    const coords = getObjectCoordinates(existingObj.id);
                                    const w = Math.ceil(existingObj.offsetWidth / unitSize);
                                    const h = Math.ceil(existingObj.offsetHeight / unitSize);
                                    const tilesOccupiedByObj = getTilesOccupiedByObject(coords, w, h) || [];
                                    
                                    const validTiles = getValidPlacementTiles(
                                        existingObj, tilesOccupiedByObj, coords, w, h, existingPlacingIndex
                                    );
                                    
                                    if (validTiles.some(c => c[0] === x && c[1] === y)) {
                                        tileAllowed = true;
                                        placementMap[y][x].surface.push(existingObj.id);
                                    } else {
                                        tileAllowed = false;
                                        break;
                                    }
                                }
                            }
                        }

                        // GENERAL CASE: ITEMS THAT CAN BE PLACED ON OTHER ITEMS WITH PROTRUDING

                        let objectsAtTileAtThisColumnBottomofSection = getObjectsAtTileFast(x, bottomOfSection);

                        for (const existingObj of objectsAtTileAtThisColumnBottomofSection) {

                            const existingPlacingIndex = getPlacingIndex(existingObj);

                            if (draggedAssetPlacingIndex === existingPlacingIndex) {
                                tileAllowed = false;
                                break;
                            }
                            
                            if (PLACING_INDEXES_TO_BE_IGNORED.has(existingPlacingIndex)) continue

                            const existingItemProtrsuionSetting = getProtrusionSetting(existingObj);

                            if (existingItemProtrsuionSetting) {
                                // PREVENTS SAME TYPE OF OBJECTS BEING PLACED ON TOP OF EACH OTHER
                                if (draggedAssetPlacingIndex === existingPlacingIndex) {
                                    tileAllowed = false;
                                    break;
                                }

                                if (draggedAssetPlacingRules.includes(existingPlacingIndex)) {
                                    const coords = getObjectCoordinates(existingObj.id);
                                    const w = Math.ceil(existingObj.offsetWidth / unitSize);
                                    const h = Math.ceil(existingObj.offsetHeight / unitSize);
                                    const tilesOccupiedByObj = getTilesOccupiedByObject(coords, w, h) || [];
                                
                                    const validTiles = getValidPlacementTiles(
                                        existingObj, tilesOccupiedByObj, coords, w, h, existingPlacingIndex
                                    );

                                    const minY = Math.min(...validTiles.map(c => c[1]));
                                    const protrusionYLimit = minY - existingItemProtrsuionSetting;

                                    if (topOfSection >= protrusionYLimit) {
                                        if (validTiles.some(c => c[0] === x && c[1] === bottomOfSection)) {
                                            tileAllowed = true;
                                            placementMap[y][x].surface.push(existingObj.id);
                                        } else {
                                            tileAllowed = false;
                                            break;
                                        }
                                    }
                                }
                            }

                        }
                    } else {
                        let objectsAtTile = getObjectsAtTileFast(x, y);

                        for (const existingObj of objectsAtTile) {
                            const existingPlacingIndex = getPlacingIndex(existingObj);
                            if (
                                draggedAssetPlacingIndex === existingPlacingIndex && 
                                PLACING_INDEXES_TO_BE_IGNORED.has(draggedAssetPlacingIndex)
                            ) {
                                tileAllowed = false;
                                break;
                            }
                        }
                    }

                    if (tileType === 4.0 || tileType === 4.1 || tileType === 4.2 || 
                        tileType === 4.3 || tileType === 4.4 || tileType === 4.5 || 
                        tileType === 4.6) {
                        tileAllowed = false;
                    }

                    if (!tileAllowed) {
                        sectionAllowed = false;
                        break;
                    }
                }

                if (!sectionAllowed) break;
            }

            // Replace the end of your main loop with this corrected version:

            if (sectionAllowed) {
                // Collect all valid tiles in this section BEFORE buffering
                const validSectionTiles = [];
                for (let y = row; y <= bottomOfSection; y++) {
                    for (let x = col; x <= rightEndofSection; x++) {
                        validSectionTiles.push([x, y]);
                    }
                }
                
                // Find surface IDs that appear in ALL tiles
                const commonSurfaceIds = [];
                if (validSectionTiles.length > 0) {
                    // Get surface IDs from first tile as candidates
                    const firstTile = validSectionTiles[0];
                    const candidateIds = placementMap[firstTile[1]][firstTile[0]].surface || [];
                    
                    // Check each candidate ID to see if it appears in all tiles
                    for (const candidateId of candidateIds) {
                        let appearsInAll = true;
                        for (const [x, y] of validSectionTiles) {
                            const surfaceArray = placementMap[y][x].surface || [];
                            if (!surfaceArray.includes(candidateId)) {
                                appearsInAll = false;
                                break;
                            }
                        }
                        if (appearsInAll) {
                            commonSurfaceIds.push(candidateId);
                        }
                    }
                }
                
                // Apply buffer and get all tiles (original + buffer)
                const allTilesWithBuffer = addBufferToSection(validSectionTiles);
                
                // Determine which rows in the ORIGINAL section have canPlace vs canOccupy
                const canPlaceRows = new Set([bottomOfSection]);
                const canOccupyRows = new Set();
                for (let y = row; y < bottomOfSection; y++) {
                    canOccupyRows.add(y);
                }
                
                // Mark buffered tiles appropriately
                for (const [x, y] of allTilesWithBuffer) {
                    if (y < 0 || y >= roomRows || x < 0 || x >= roomCols) continue;
                    
                    const wasInOriginalSection = validSectionTiles.some(([ox, oy]) => ox === x && oy === y);
                    
                    if (wasInOriginalSection) {
                        if (y === bottomOfSection) {
                            placementMap[y][x].canPlace = true;
                        } else {
                            placementMap[y][x].canOccupy = true;
                        }
                    } else {
                        // Buffer tile
                        if (y === bottomOfSection) {
                            placementMap[y][x].canPlace = true;
                        } else if (y > bottomOfSection) {
                            placementMap[y][x].canPlace = true;
                        } else if (y < row) {
                            if (y + 1 < roomRows && placementMap[y + 1][x].canPlace) {
                                placementMap[y][x].canPlace = true;
                            } else {
                                placementMap[y][x].canOccupy = true;
                            }
                        } else {
                            if (canPlaceRows.has(y)) {
                                placementMap[y][x].canPlace = true;
                            } else if (canOccupyRows.has(y)) {
                                placementMap[y][x].canOccupy = true;
                            }
                        }
                        
                        // Propagate all common surface IDs to buffer tiles
                        for (const surfaceId of commonSurfaceIds) {
                            if (!placementMap[y][x].surface.includes(surfaceId)) {
                                placementMap[y][x].surface.push(surfaceId);
                            }
                        }
                    }
                }
            }
        }
    }

    return placementMap;
}

// ========== PUBLIC INTERFACE FUNCTIONS ==========

/**
 * MAIN FUNCTION - Same interface as original generatePlacementMap
 * Returns placement map for a dragged object, using cache when possible
 * @param {string} draggedObjectId - ID of object being dragged
 * @returns {Array} 2D array placement map or null if error
 */
function generatePlacementMap(draggedObjectId) {
    // Check if cache needs invalidation (new objects added/removed)
    if (shouldInvalidateCache()) {
        // Reinitialize cache with current objects
        initPlacementCache();
        
        // Rebuild placedObjects set from all current objects
        const combinedAssets = getCombinedAssets();
        for (const objectId in combinedAssets) {
            // Don't include the dragged object itself (it's being moved)
            if (objectId !== draggedObjectId) {
                const element = document.getElementById(objectId);
                // Only include objects that are actually placed in the room
                if (element && element.parentNode) {
                    placementCache.placedObjects.add(objectId);
                }
            }
        }
        // Rebuild tile occupancy for all placed objects
        buildTileOccupancyMap();
    }
    
    // Return cached placement map if available (fast path)
    if (placementCache.placementMaps.has(draggedObjectId)) {
        return placementCache.placementMaps.get(draggedObjectId);
    }
    
    // Compute fresh placement map (slow path, but cached for future)
    const placementMap = precomputePlacementMap(draggedObjectId);
    if (placementMap) {
        placementCache.placementMaps.set(draggedObjectId, placementMap);
    }
    
    return placementMap;
}

/**
 * Call when an object is moved to a new position
 * Updates cache to reflect the new layout
 * @param {string} objectId - ID of moved object
 * @param {Object} oldPosition - Optional old position (not used in current impl)
 */
function onObjectMoved(objectId) {
    // Update cache for this object
    updatePlacementCache(objectId);
}

/**
 * Call when a new object is added to the layout
 * Updates cache to include the new object
 * @param {string} objectId - ID of added object
 */
function onObjectAdded(objectId) {
    updatePlacementCache(objectId, true);
}

/**
 * Call when an object is removed from the layout
 * Updates cache to remove the object
 * @param {string} objectId - ID of removed object
 */
function onObjectRemoved(objectId) {
    updatePlacementCache(objectId, false);
}

// ========== INTERNAL CACHE UPDATE FUNCTION ==========

/**
 * Update the placement cache for an object
 * @param {string} objectId - ID of object that changed
 * @param {boolean} wasAdded - True if object was added, false if removed/moved
 */
function updatePlacementCache(objectId, wasAdded = false) {
    // Update placed objects set
    if (wasAdded) {
        placementCache.placedObjects.add(objectId);
    } else {
        placementCache.placedObjects.delete(objectId);
    }
    
    // Rebuild tile occupancy map (reflects new object positions)
    buildTileOccupancyMap();
    
    // Invalidate all placement maps (they may be affected by object movement)
    placementCache.placementMaps.clear();
    
    // Update combined assets hash to current state
    placementCache.combinedAssetsHash = getCombinedAssetsHash();
}

// ========== INITIALIZATION ==========

// Initialize cache when this module loads
initPlacementCache();


// Helper function to get all objects at a specific tile
function getObjectsAtTile(tileCol, tileRow, excludeObjectId = null) {
    const objectsAtTile = [];
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

    const combinedAssets = { ...userObjectAssets };

    // Only add furniture-preview if assetIndex is not null
    if (furniturePreviewDict["furniture-preview"].assetIndex !== null) {
        combinedAssets["furniture-preview"] = furniturePreviewDict["furniture-preview"];
    }

    Object.entries(combinedAssets).forEach(([objectId, asset]) => {
        if (objectId === excludeObjectId) return;

        const element = document.getElementById(objectId);
        if (!element) return;

        const objectPos = getObjectCoordinates(objectId);
        if (!objectPos) return;

        const [objX, objY] = objectPos;
        const objWidth = Math.ceil(element.offsetWidth / unitSize);
        const objHeight = Math.ceil(element.offsetHeight / unitSize);

        // Check if the tile is within this object's bounds
        const objTopRow = objY - objHeight + 1;
        const objBottomRow = objY;
        const objLeftCol = objX;
        const objRightCol = objX + objWidth - 1;

        if (tileCol >= objLeftCol && tileCol <= objRightCol &&
            tileRow >= objTopRow && tileRow <= objBottomRow) {

            objectsAtTile.push(element);
        }
    });

    return objectsAtTile;
}

function determineAndHighlightValidTiles(placementMap) {
    highlightValidPlacements(placementMap)
}

function highlightValidPlacements(placementMap) {
    clearPlacementHighlights();
    if (!placementMap) return;

    const canvas = document.getElementById('placement-canvas') || createHighlightCanvas();
    const ctx = canvas.getContext('2d');

    const tileSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (placementMap[row]?.[col]) {
                const { canPlace, canOccupy } = placementMap[row][col];
                
                // Green for canPlace (bottom placement allowed)
                if (canPlace) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                }
                // Yellow for canOccupy only (overlap allowed, but not bottom placement)
                else if (canOccupy) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                }
                // Red for not allowed (neither canPlace nor canOccupy)
                else {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
                    ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                }
            }
        }
    }
}

function createHighlightCanvas() {
    const canvas = document.createElement('canvas');
    canvas.id = 'placement-canvas';
    canvas.width = roomLayout[0].length * tileSize;
    canvas.height = roomLayout.length * tileSize;
    canvas.style.position = 'absolute';
    canvas.style.pointerEvents = 'none';
    canvas.style.zIndex = '100';
    // position it over your room
    document.getElementById('room-container').appendChild(canvas);
    return canvas;
}

function clearPlacementHighlights() {
    const canvas = document.getElementById('placement-canvas');
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    if (highlightTimeout !== null) {
        clearTimeout(highlightTimeout);
        highlightTimeout = null;
    }
}

// NAVIGATION START

const navButtons = document.querySelectorAll('.nav-item');
const contentPanels = document.querySelectorAll('.game-content-panel');

navButtons.forEach((button) => {
    button.addEventListener('click', () => {
        const targetId = button.dataset.target;

        const previouslyActivePanel = document.querySelector(".game-content-panel.active");
        const previousId = previouslyActivePanel ? previouslyActivePanel.id : null;

        if (previousId === "pet-room-container" && targetId !== "pet-room-container") {
            document.getElementById('cancel-edit-btn').click();
        }
        
        // Remove active class from all buttons and panels
        navButtons.forEach(btn => btn.classList.remove('active'));
        contentPanels.forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked button and target panel
        button.classList.add('active');
        const targetPanel = document.getElementById(targetId);
        targetPanel.classList.add('active');

        endPreview()

        if (button.id !== "pet-room-button") {
            selectedConsumable = [];
            clearPlacementHighlights();
            clearSpecificPlacementHighlights();
        }

        // Trigger rendering depending on the panel
        if (targetId === 'furniture-container') {
            renderObjectAssetsDropdown();
            const checkbox = document.getElementById("object-usage-toggle");
            const switchText = document.querySelector(".switch-text-object");
            if (checkbox && switchText) {
                switchText.textContent = checkbox.checked ? "" : "NENAUD.";
            }
            document.getElementById('furnitureHeader').classList.remove('compact');
        } else if (targetId === 'shop-container') {
            renderShopCategoriesDropdown();
            const checkbox = document.getElementById("shop-not-owned-toggle");
            const switchText = document.querySelector(".switch-text-shop");
            if (checkbox && switchText) {
                switchText.textContent = checkbox.checked ? "" : "NETURIU";
            }
            document.getElementById('shopHeader').classList.remove('compact');
        } else if (targetId === 'pet-room-container') {
            const allPets = document.querySelectorAll("#petContainer .pet");
            if (allPets[0]) {
                displayPetStats(allPets[0].id);
            }
            allPets.forEach(pet => {
                managePetActions(pet);
            });
            toggleRoomDarknessBasedOnElectricityTax();
        } else if (targetId === 'pet-asset-container') {
            const departmentBtns = document.querySelectorAll('#pet-asset-container .department-btn');
            const foodBtn = Array.from(departmentBtns).find(btn => {
                const label = btn.querySelector('.department-label');
                return label && label.textContent.trim() === 'Maistas';
            });

            document.getElementById('petAssetHeader').classList.remove('compact');

            // Trigger the click if it exists
            if (foodBtn) {
                foodBtn.click(); // This fires any click listeners attached
            }

            renderUsersPetAssets();
        } else if (targetId === 'taxes-container') {
            renderTaxesSection();
            document.getElementById('taxesHeader').classList.remove('compact');
        }
    });
});

function navigationResponsiveLayout() {
    const gameContainer = document.getElementById("gameContainer");
    const gameNavigation = document.querySelector(".game-navigation");
    const gameContent = document.getElementById("game-content");
    const gameContentPanel = document.querySelectorAll('.game-content-panel')

    if (!gameContainer || !gameNavigation || !gameContent) {
        console.warn("One or more elements not found.");
        return;
    }

    if (window.matchMedia("(max-width: 767px)").matches) {
        gameContainer.classList.add("mobile");
        gameNavigation.classList.add("mobile");
        gameContent.classList.add("mobile");
        gameContentPanel.forEach(panel => panel.classList.add("mobile"));
    } else {
        gameContainer.classList.remove("mobile");
        gameNavigation.classList.remove("mobile");
        gameContent.classList.remove("mobile");
        gameContentPanel.forEach(panel => panel.classList.remove("mobile"));
    }
}

// Recalculate on resize
window.addEventListener("resize", async () => {
    updateStatsBeforeRerunningInitGameAndRenderPets();
    navigationResponsiveLayout();
    endPreview()
    hideSidebar()

    if (document.getElementById("pet-room-container").classList.contains("active")) {
        await initGame();
        document.querySelector("#end-preview-button").classList.add("hidden")
        resetEditButtonToggle();
    }

    const checkbox = document.getElementById("shop-not-owned-toggle");
    const switchText = document.querySelector(".switch-text-shop");
    if (checkbox && switchText) {
        switchText.textContent = checkbox.checked ? "" : "NETURIU";
    }

    const checkbox2 = document.getElementById("object-usage-toggle");
    const switchText2 = document.querySelector(".switch-text-object");
    if (checkbox2 && switchText2) {
        switchText2.textContent = checkbox2.checked ? "" : "NENAUD.";
    }
});

// NAVIGATION END


function adjustUnitSizeForSmallScreens() {
    const numTiles = 42; // number of columns
    const screenWidth = window.innerWidth;

    // Define breakpoint for "small screens"
    if (screenWidth <= 768) {
        originalUnitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--original-unit-size'));
        unitSize = Math.min(Math.floor(screenWidth / numTiles), originalUnitSize);

        // Set CSS variable
        document.documentElement.style.setProperty("--unit-size", `${unitSize}px`);
        document.documentElement.style.setProperty("--pet-size", `calc(${unitSize}px * 6)`);
    } else {
        unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--original-unit-size'));

        // Reset to default if needed
        document.documentElement.style.setProperty("--unit-size", `${unitSize}px`);
        document.documentElement.style.setProperty("--pet-size", `${unitSize*6}px`);
    }
}


// CREATE SHOPPING FUNCTIONALITY START

// Store the current shop state
let shopState = {
    department: 'pet-supplies',
    category: 'all',
    pet: null,
    tab: 'supplies',
    showUnpurchasedOnly: false
};

async function handlePurchase(item, assetIndex, quantity, selectedCategory, btn) {
    updateShopState();

    const buttons = document.querySelectorAll('.purchase-btn');

    buttons.forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.6';
    });
    
    const itemDetails = gameAssetIndex[assetIndex];
    
    if (!itemDetails) {
        console.error(`Asset with index ${assetIndex} not found in gameAssetIndex`);
        return;
    }
    
    // Calculate total cost
    const totalCost = (itemDetails.cost * COST_MULTIPLIER) * quantity;
    
    // Check if user has enough money (local check first)
    if (userMoney < totalCost) {
        messageToTheUser("Nepakanka pinig!", 'error');
        buttons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
        });
        return;
    }
    
    // Store original states for potential rollback
    const originalMoney = userMoney;
    const originalObjectAssets = JSON.parse(JSON.stringify(userObjectAssets));
    const originalPetAssets = JSON.parse(JSON.stringify(userPetAssets));
    
    // Save current state before making changes (for shop restoration)
    const currentState = {...shopState};
    
    // Build the new assets BEFORE any server calls
    let newAssets = {};
    let assetType = null; // 'pet' or 'object'
    
    if (item.petAsset) {
        assetType = 'pet';
        const cssClasses = itemDetails['css-class'].split(' ');
        const isSkin = cssClasses.includes('skin');
        
        if (isSkin) {
            const petType = cssClasses[0];
            
            if (!userPetAssets.pets) userPetAssets.pets = {};
            if (!userPetAssets.pets[petType]) {
                userPetAssets.pets[petType] = { 
                    skins: {},
                    name: item.petName
                };
            }
            if (!userPetAssets.pets[petType].skins) {
                userPetAssets.pets[petType].skins = {};
            }
            
            const existingSkins = Object.keys(userPetAssets.pets[petType].skins);
            const skinNumber = existingSkins.length + 1;
            const newSkinKey = `${petType}-${skinNumber}`;
            
            userPetAssets.pets[petType].skins[newSkinKey] = {
                assetIndex: assetIndex,
                equiped: false
            };
        } else {
            if (!userPetAssets.supplies) userPetAssets.supplies = {};
            
            if (itemDetails.stackable) {
                let existingSupplyKey = null;
                for (const key in userPetAssets.supplies) {
                    if (userPetAssets.supplies[key].assetIndex === assetIndex) {
                        existingSupplyKey = key;
                        break;
                    }
                }
                
                if (existingSupplyKey) {
                    userPetAssets.supplies[existingSupplyKey].quantity += quantity;
                } else {
                    const newSupplyKey = getNextSupplyKey();
                    userPetAssets.supplies[newSupplyKey] = {
                        assetIndex: assetIndex,
                        quantity: quantity
                    };
                }
            } else {
                for (let i = 0; i < quantity; i++) {
                    const newSupplyKey = getNextSupplyKey();
                    userPetAssets.supplies[newSupplyKey] = {
                        assetIndex: assetIndex,
                        quantity: 1
                    };
                }
            }
        }
    } else {
        assetType = 'object';
        if (item.oneOfKind) {
            const newKey = getNextObjectKey();
            userObjectAssets[newKey] = { assetIndex, position: [] };
        } else {
            for (let i = 0; i < quantity; i++) {
                const newKey = getNextObjectKey();
                userObjectAssets[newKey] = { assetIndex, position: [] };
            }
        }
    }
    
    try {
        // 1. Deduct money from server
        const moneySuccess = await sendMoneyTransactionToDatabase(totalCost, 'subtract');
        
        if (!moneySuccess) {
            // Revert all changes
            userMoney = originalMoney;
            userObjectAssets = originalObjectAssets;
            userPetAssets = originalPetAssets;

            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
            });
            
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            return;
        }
        
        // 2. Update local money only after server confirms
        userMoney -= totalCost;
        updateCoinAmounts(userMoney);
        
        // 3. Update assets on server
        let assetUpdateSuccess = false;
        if (assetType === 'pet') {
            assetUpdateSuccess = await sendPetAssetsUpdateToDatabase();
            const isPet = itemDetails["pet"] === true;
            if (assetUpdateSuccess && isPet) {
                updateStatsBeforeRerunningInitGameAndRenderPets();
                renderPets();
                enablePetDragging();
                createPetButtons();
            }
        } else {
            assetUpdateSuccess = await sendObjectAssetsUpdateToDatabase();
        }
        
        if (!assetUpdateSuccess) {
            // Asset update failed - revert everything including money
            console.error('Critical error: Money deducted but asset update failed');
            
            // Try to refund money on server
            await sendMoneyTransactionToDatabase(totalCost, 'add');
            
            // Revert local state
            userMoney = originalMoney;
            userObjectAssets = originalObjectAssets;
            userPetAssets = originalPetAssets;
            updateCoinAmounts(userMoney);

            buttons.forEach(btn => {
                btn.disabled = false;
                btn.style.opacity = '1';
            });

            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            return;
        }

        // Success!
        buttons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
        });

        // Add animation
        btn.innerHTML = '<svg class="tick-svg" viewBox="0 0 24 24" width="24" height="24"><path class="tick" d="M4 12l6 6 10-10"></path></svg>';
        const tick = btn.querySelector('.tick');
        requestAnimationFrame(() => {
            tick.classList.add('draw');
        });

        // If item is oneOfKind, immediately mark as owned
        if (item.oneOfKind) {
            const itemDiv = btn.closest('.shop-item');
            if (itemDiv) {
                itemDiv.classList.add('owned');
                const previewHolder = itemDiv.querySelector('.item-preview-holder');
                
                // Remove preview button if exists
                const previewButton = previewHolder?.querySelector('.furniture-preview-button');
                if (previewButton) {
                    previewButton.remove();
                }
                
                // Add owned badge
                if (previewHolder && !previewHolder.querySelector('.owned-badge')) {
                    const ownedBadge = document.createElement('div');
                    ownedBadge.className = 'owned-badge';
                    ownedBadge.innerHTML = '<span class="owned-badge-icon"><img src="../images/icons/icon-check.svg"></span>';
                    previewHolder.appendChild(ownedBadge);
                }
                
                // Update button
                btn.classList.add('owned');
                setTimeout(() => {
                    btn.innerHTML = 'Nupirkta';
                    btn.disabled = true;
                }, 500);
            }
        } else {
            // For non-oneOfKind items, restore shop state after animation
            setTimeout(() => {
                restoreShopState(currentState);
            }, 500);
        }
        
    } catch (error) {
        console.error('Purchase error:', error);
        
        // Revert all local changes
        userMoney = originalMoney;
        userObjectAssets = originalObjectAssets;
        userPetAssets = originalPetAssets;
        updateCoinAmounts(userMoney);

        buttons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
        });
        
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
    }
}

function getNextSupplyKey() {
    if (!userPetAssets.supplies) return 'S1';
    let maxNum = 0;
    for (const key in userPetAssets.supplies) {
        const num = parseInt(key.substring(1)); // Extract number from "S5"
        if (num > maxNum) maxNum = num;
    }
    return `S${maxNum + 1}`;
}

function restoreShopState(state) {
    // Update global state
    shopState = {...state};
    
    // Set the department
    const departmentButtons = document.querySelectorAll('#shop-container .department-btn');
    departmentButtons.forEach(btn => {
        const label = btn.querySelector('.department-label').textContent;
        let department;
        if (label === 'Baldai') department = 'furniture';
        if (label === 'Gyvnliai') department = 'pets';
        if (label === 'Maistas' || label === 'Reikmenys') department = 'pet-supplies';
        
        btn.classList.toggle('active', department === state.department);
    });
    
    // Set the pet selection
    selectedPet = state.pet;
    
    // Update active pet buttons in shop section only
    document.querySelectorAll('#pet-list-shop .pet-btn').forEach(btn => {
        const petPreview = btn.querySelector('.pet-preview');
        const petClass = petPreview.classList[1]; // Get the pet type class
        btn.classList.toggle('active', petClass === state.pet);
    });
    
    // Set the tab selection (for Maistas)
    activePetSupplyTab = state.tab;
    
    // Set the category dropdown
    const dropdown = document.getElementById('shop-category-select');
    if (dropdown) {
        dropdown.value = state.category;
    }
    
    // Set the unpurchased toggle
    const toggle = document.getElementById('shop-not-owned-toggle');
    if (toggle) {
        toggle.checked = state.showUnpurchasedOnly;
    }
    
    // Set the pet supply tabs
    const petSupplyTabButtons = document.querySelectorAll('.pet-supply-tab');
    petSupplyTabButtons.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.type === state.tab);
    });
    
    // Re-render with the saved state
    renderShopItems(state.category, state.department, state.tab);
}

function syncPetSelection() {
    // Synchronize pet selection between shop and pet sections
    if (!selectedPet) return;
    
    // Update shop section pet buttons
    document.querySelectorAll('#pet-list-shop .pet-btn').forEach(btn => {
        const petPreview = btn.querySelector('.pet-preview');
        if (petPreview) {
            const petClass = petPreview.classList[1]; // Get the pet type class
            btn.classList.toggle('active', petClass === selectedPet);
        }
    });
    
    // Update pet section pet buttons
    document.querySelectorAll('#pet-list-owned .pet-btn').forEach((btn, index) => {
        const petType = Object.keys(userPetAssets.pets)[index];
        btn.classList.toggle('active', petType === selectedPet);
    });
}

function updateShopState() {
    // Get current department - handle case where no active button exists
    const activeBtn = document.querySelector('.department-btn.active');
    let department = 'furniture'; // default fallback
    
    if (activeBtn) {
        const label = activeBtn.querySelector('.department-label')?.textContent;
        if (label === 'Baldai') department = 'furniture';
        if (label === 'Gyvnliai') department = 'pets';
        if (label === 'Maistas' || label === 'Reikmenys') department = 'pet-supplies';
    }
    
    // Get current category
    const dropdown = document.getElementById('shop-category-select');
    const category = dropdown ? dropdown.value : 'all';
    
    // Get current unpurchased toggle state
    const toggle = document.getElementById('shop-not-owned-toggle');
    const showUnpurchasedOnly = toggle ? toggle.checked : false;
    
    // Update the shop state
    shopState = {
        department,
        category,
        pet: selectedPet,  // Make sure this uses the global selectedPet variable
        tab: activePetSupplyTab,
        showUnpurchasedOnly
    };
}

let selectedPet = null;
let activePetSupplyTab = 'supplies';

function renderShopCategoriesDropdown() {
    const dropdown = document.getElementById('shop-category-select');
    const shopContainer = document.getElementById('shop-items');
    const departmentButtons = document.querySelectorAll('#shop-container .department-btn');
    const petListContainer = document.getElementById('pet-list-shop');
    const petSuppliesTabs = document.getElementById('pet-supplies-tabs');

    const toggle = document.getElementById('shop-not-owned-toggle');
    toggle.checked = false;

    if (!dropdown || !shopContainer || !departmentButtons) return;

    let activeDepartment = getActiveDepartment();

    // Function to check if item is a skin by looking for 'skin' in css-class
    function isSkin(item) {
        const cssClass = item['css-class'] || '';
        return cssClass.includes('skin');
    }

    function getCategoryCounts(department, tabType = 'supplies') {
        const categoryCounts = {};
        for (const key in gameAssetIndex) {
            const item = gameAssetIndex[key];

            if (item.cannotPurchase) continue;

            // Filter by department and tab type
            if (department === 'pet-supplies') {
                if (!item.petAsset) continue;
                
                // Use CSS class to determine skin vs supply
                if (tabType === 'skins' && !isSkin(item)) continue;
                if (tabType === 'supplies' && isSkin(item)) continue;
                
                // For Maistas, filter by selected pet if any
                if (selectedPet) {
                    const petIdentifier = selectedPet.split('-')[0];
                    const cssClass = item['css-class'] || '';
                    if (!cssClass.includes(petIdentifier)) continue;
                }
            } else if (department === 'pets') {
                // For pets section, use the pet property (not CSS class)
                if (!item.petAsset || !item.pet) continue;
            } else if (department === 'furniture' && item.petAsset) {
                continue;
            }

            item.category.forEach(cat => {
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });
        }
        return categoryCounts;
    }

    function updateDropdown(department, tabType = 'supplies') {
        const categoryCounts = getCategoryCounts(department, tabType);

        dropdown.innerHTML = '';

        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = `Visi`;
        dropdown.appendChild(allOption);

        Object.keys(categoryCounts).sort((a, b) => {
            const nameA = a.charAt(0).toUpperCase() + a.slice(1);
            const nameB = b.charAt(0).toUpperCase() + b.slice(1);
            return nameA.localeCompare(nameB);
        }).forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
            dropdown.appendChild(option);
        });
        
        // Restore the saved category selection if it exists
        if (shopState.category && Array.from(dropdown.options).some(opt => opt.value === shopState.category)) {
            dropdown.value = shopState.category;
        }
    }

    function getActiveDepartment() {
        const activeBtn = document.querySelector('.department-btn.active');
        const label = activeBtn?.querySelector('.department-label')?.textContent;
        if (label === 'Gyvnliai') return 'pets';
        if (label === 'Maistas' || label === 'Reikmenys') return 'pet-supplies';
        return 'furniture';
    }

    function renderPetList() {
        // Always hide both containers first
        petListContainer.style.display = 'none';
        petSuppliesTabs.style.display = 'none';
        
        // Only show if we're in pet-supplies department
        if (activeDepartment === 'pet-supplies') {
            petListContainer.style.display = 'flex';
            petSuppliesTabs.style.display = 'flex';
            
            petListContainer.innerHTML = '';

            for (const petType in userPetAssets.pets) {
                const pet = userPetAssets.pets[petType];
                
                let equippedSkinAssetIndex = null;
                for (const skinKey in pet.skins) {
                    if (pet.skins[skinKey].equiped) {
                        equippedSkinAssetIndex = pet.skins[skinKey].assetIndex;
                        break;
                    }
                }

                if (!equippedSkinAssetIndex && Object.keys(pet.skins).length > 0) {
                    const firstSkinKey = Object.keys(pet.skins)[0];
                    equippedSkinAssetIndex = pet.skins[firstSkinKey].assetIndex;
                }

                const petItem = gameAssetIndex[equippedSkinAssetIndex];
                if (!petItem) continue;

                const petBtn = document.createElement('button');
                petBtn.className = `pet-btn ${selectedPet === petType ? 'active' : ''}`;
                
                const previewDiv = document.createElement('div');
                previewDiv.className = `pet-preview ${petItem["css-class"].split(" ").slice(0, 2).join(" ")}`;

                petBtn.appendChild(previewDiv);

                petBtn.addEventListener('click', () => {
                    selectedPet = petType;
                    document.querySelectorAll('.pet-btn').forEach(btn => btn.classList.remove('active'));
                    petBtn.classList.add('active');
                    updateShopState();
                    renderShopItems('all', activeDepartment, activePetSupplyTab);
                });

                petListContainer.appendChild(petBtn);
            }

            if (!selectedPet && Object.keys(userPetAssets.pets).length > 0) {
                selectedPet = Object.keys(userPetAssets.pets)[0];
                petListContainer.querySelector('.pet-btn')?.classList.add('active');
            }
        }
    }

    // Set up Maistas tabs
    const petSupplyTabButtons = document.querySelectorAll('.pet-supply-tab');
    petSupplyTabButtons.forEach(tab => {
        tab.addEventListener('click', () => {
            petSupplyTabButtons.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            activePetSupplyTab = tab.dataset.type;
            updateShopState();
            updateDropdown(activeDepartment, activePetSupplyTab);
            renderShopItems('all', activeDepartment, activePetSupplyTab);
        });
    });

    // Initialize with saved state if available
    if (shopState.department) {
        // Set active department based on saved state
        departmentButtons.forEach(btn => {
            const label = btn.querySelector('.department-label').textContent;
            let department;
            if (label === 'Baldai') department = 'furniture';
            if (label === 'Gyvnliai') department = 'pets';
            if (label === 'Maistas' || label === 'Reikmenys') department = 'pet-supplies';
            
            btn.classList.toggle('active', department === shopState.department);
        });
        
        activeDepartment = shopState.department;
        selectedPet = shopState.pet;
        activePetSupplyTab = shopState.tab;
    }

    updateDropdown(activeDepartment, activePetSupplyTab);
    renderPetList();
    renderShopItems(shopState.category || 'all', activeDepartment, activePetSupplyTab);

    dropdown.addEventListener('change', () => {
        updateShopState();
        const selectedCategory = dropdown.value;
        renderShopItems(selectedCategory, activeDepartment, activePetSupplyTab);
    });

    departmentButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            departmentButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            activeDepartment = getActiveDepartment();
            selectedPet = null; // Reset pet selection
            updateShopState();
            updateDropdown(activeDepartment, activePetSupplyTab);
            renderPetList(); // This will now properly hide/show the tabs based on department
            renderShopItems('all', activeDepartment, activePetSupplyTab);
        });
    });
}

function renderTemporaryRoomObject(assetId) {
    const roomObjectsContainer = document.querySelector("#roomObjectsContainer");
    const item = gameAssetIndex[assetId];

    const div = document.createElement("div");
    div.className = `room-object furniture-preview ${item["css-class"]}`;
    div.id = "furniture-preview";
    roomObjectsContainer.appendChild(div);

    div.style.left = `0px`;
    div.style.top = `0px`;

    return div.id;
}

let furniturePreviewDict = {
    "furniture-preview" : {
        assetIndex: null,
        position: []
    }
}

document.querySelector("#end-preview-button").addEventListener("click", async () => {
    endPreview();
    updateStatsBeforeRerunningInitGameAndRenderPets();
    await initGame();
});;

function endPreview() {
    if (!furniturePreviewDict["furniture-preview"].assetIndex) {
        return
    }
    
    document.querySelector("#end-preview-button").classList.add("hidden");
    document.querySelector("#toggle-edit-save-btn").classList.remove("hidden");

    // Clean up the preview object
    furniturePreviewDict["furniture-preview"].assetIndex = null;
    furniturePreviewDict["furniture-preview"].position = [];

    // Remove the preview div if it exists
    const previewDiv = document.getElementById('furniture-preview');
    
    if (previewDiv) {
        previewDiv.remove();
    }

    // If in edit mode, exit it first
    if (editing) {
        cancelEditBtn.click();
    }
}

async function previewFurniture (key) {
    
    let tempDivId = renderTemporaryRoomObject(key);

    document.querySelectorAll('.game-content-panel').forEach(p => p.classList.remove('active'));
    document.getElementById('pet-room-container').classList.add('active');

    const navButtons = document.querySelectorAll('.nav-item');
    navButtons.forEach(btn => btn.classList.remove('active'));
    navButtons[0].classList.add('active')
    
    furniturePreviewDict["furniture-preview"].assetIndex = key;
    furniturePreviewDict["furniture-preview"].position = getObjectCoordinates(tempDivId);

    updateStatsBeforeRerunningInitGameAndRenderPets();
    
    await initGame();
    const placementMap = generatePlacementMap(tempDivId);

    const validPosition = findValidPosition(placementMap, tempDivId);

    if (validPosition) {
        furniturePreviewDict["furniture-preview"].position = validPosition;
        updateStatsBeforeRerunningInitGameAndRenderPets();
        adjustUnitSizeForSmallScreens();
        await new Promise(resolve => requestAnimationFrame(resolve));
        renderRoomGrid();
        await setPetAndObjectContainersToGridDimentions();
        renderRoomObjects();
        toggleRoomDarknessBasedOnElectricityTax();
        updateSingleItemZIndex(tempDivId);

        toggleEditSaveBtn.click();

        document.querySelector("#end-preview-button").classList.remove("hidden")
        document.querySelector("#toggle-edit-save-btn").classList.add("hidden")
        document.querySelector("#cancel-edit-btn").classList.add("hidden")
        hideSidebar();

        centerViewportOnObject("furniture-preview")

        
    } else {
        furniturePreviewDict["furniture-preview"].position = [];
        document.getElementById(tempDivId).remove();
        if (gameAssetIndex[furniturePreviewDict["furniture-preview"].assetIndex].placingIndex === 13 || gameAssetIndex[furniturePreviewDict["furniture-preview"].assetIndex]["css-class"].includes("window-sill")) {
            messageToTheUser("Nra tinkamo dydio lango arba j ustoja kiti daiktai!")
        } else {
            messageToTheUser("Nepakanka vietos!")
        }
        furniturePreviewDict["furniture-preview"].assetIndex = null;
    }
}

const selectedVariantState = {};

function renderShopItems(selectedCategory = 'all', department = 'pet-supplies', tabType = 'supplies') {
    const shopContainer = document.getElementById('shop-items');
    if (!shopContainer) return;
    shopContainer.innerHTML = '';

    const ownedIndexes = new Set();
    const ownedCssClasses = new Set();

    // Collect owned assets
    for (const key in userObjectAssets) {
        const assetIndex = parseInt(userObjectAssets[key].assetIndex);
        ownedIndexes.add(assetIndex);
        const cssClassStr = gameAssetIndex[assetIndex]?.['css-class'];
        if (cssClassStr) cssClassStr.split(' ').forEach(cls => ownedCssClasses.add(cls));
    }

    // Collect owned pets and skins
    if (userPetAssets.pets) {
        for (const petId in userPetAssets.pets) {
            const pet = userPetAssets.pets[petId];
            if (pet.skins) {
                for (const skinId in pet.skins) {
                    const skin = pet.skins[skinId];
                    const assetIndex = parseInt(skin.assetIndex);
                    ownedIndexes.add(assetIndex);
                    const cssClassStr = gameAssetIndex[assetIndex]?.['css-class'];
                    if (cssClassStr) cssClassStr.split(' ').forEach(cls => ownedCssClasses.add(cls));
                }
            }
        }
    }

    // Collect owned supplies
    if (userPetAssets.supplies) {
        for (const supplyId in userPetAssets.supplies) {
            const supply = userPetAssets.supplies[supplyId];
            const assetIndex = parseInt(supply.assetIndex);
            ownedIndexes.add(assetIndex);
            const cssClassStr = gameAssetIndex[assetIndex]?.['css-class'];
            if (cssClassStr) cssClassStr.split(' ').forEach(cls => ownedCssClasses.add(cls));
        }
    }

    const showUnpurchasedOnly = document.getElementById('shop-not-owned-toggle').checked;

    function isSkin(item) {
        const cssClass = item['css-class'] || '';
        return cssClass.includes('skin');
    }

    // Group items by title if they have 'variant'
    const groupedItems = {};
    const ungroupedItems = [];

    for (const key in gameAssetIndex) {
        const item = gameAssetIndex[key];
        const assetIndex = parseInt(key);

        if (item.cannotPurchase) continue;

        // Filters by department/tab/category
        if (department === 'pet-supplies') {
            if (!item.petAsset) continue;
            if (tabType === 'skins' && !isSkin(item)) continue;
            if (tabType === 'supplies' && isSkin(item)) continue;

            if (selectedPet) {
                const cssClass = item['css-class'] || '';
                if (tabType === 'skins') {
                    if (!cssClass.includes(selectedPet)) continue;
                } else {
                    const petIdentifier = selectedPet.split('-')[0];
                    if (!cssClass.includes(petIdentifier)) continue;
                }
            }
        } else if (department === 'pets') {
            if (!item.petAsset || !item.pet) continue;
        } else if (department === 'furniture' && item.petAsset) {
            continue;
        }

        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;
        if (showUnpurchasedOnly && ownedIndexes.has(assetIndex) && item.oneOfKind) continue;

        if (item.variant && Array.isArray(item.variant)) {
            if (!groupedItems[item.title]) groupedItems[item.title] = [];
            groupedItems[item.title].push({ key, item });
        } else {
            ungroupedItems.push({ key, item });
        }
    }

    // Utility: sort sizes
    const SIZE_ORDER = ['XS', 'S', 'M', 'L', 'XL'];
    function sortSizes(sizes) {
        return sizes.sort((a, b) => {
            const idxA = SIZE_ORDER.indexOf(a.toUpperCase());
            const idxB = SIZE_ORDER.indexOf(b.toUpperCase());
            if (idxA === -1 && idxB === -1) return 0;
            if (idxA === -1) return 1;
            if (idxB === -1) return -1;
            return idxA - idxB;
        });
    }

    // Function to analyze variant types and their order
    function analyzeVariantTypes(variants) {
        const variantPositions = [];
        const variantCount = variants[0].item.variant.length;
        
        for (let i = 0; i < variantCount; i++) {
            const values = [...new Set(variants.map(v => v.item.variant[i]))];
            
            let type = 'text';
            const firstValue = values[0];
            
            if (SIZE_ORDER.includes(firstValue?.toUpperCase())) {
                type = 'size';
            } else if (firstValue && firstValue.startsWith('#')) {
                type = 'color';
            } else if (['vertikalus', 'horizontalus', 'vertikali', 'horizontali', 'vertikals', 'horizontals'].includes(firstValue?.toLowerCase())) {
                type = 'orientation';
            }
            
            let label = type.charAt(0).toUpperCase() + type.slice(1);
            if (type === 'orientation') label = 'Orientacija';
            else if (type === 'size') label = 'Dydis';
            else if (type === 'color') label = 'Spalva';
            
            variantPositions.push({
                index: i,
                values: values,
                type: type,
                label: label
            });
        }
        
        return variantPositions;
    }

    // Custom dropdown component that always uses modal
    function createCustomDropdown(label, options, selectedValue, onChange, isColor = false, variantIndex = 0) {
        const wrapper = document.createElement('div');
        wrapper.className = 'custom-dropdown-wrapper';
        
        const dropdown = document.createElement('div');
        dropdown.className = 'custom-dropdown';
        dropdown.dataset.variantIndex = variantIndex;
        
        const selected = document.createElement('div');
        selected.className = 'custom-dropdown-selected';
        
        const dropdownIcon = document.createElement('div');
        dropdownIcon.className = 'custom-dropdown-icon';
        dropdownIcon.innerHTML = '';
        
        selected.appendChild(dropdownIcon);
        dropdown.appendChild(selected);
        
        selected.addEventListener('click', (e) => {
            e.stopPropagation();
            openVariantModal(label, options, selectedValue, isColor, (newValue) => {
                selectedValue = newValue;
                if (isColor) {
                    selected.innerHTML = '';
                    const selectedColorCircle = document.createElement('span');
                    selectedColorCircle.className = 'color-circle';
                    selectedColorCircle.style.backgroundColor = newValue;
                    selectedColorCircle.title = newValue;
                    
                    selected.appendChild(selectedColorCircle);
                    selected.appendChild(dropdownIcon);
                } else {
                    selected.textContent = newValue;
                    selected.appendChild(dropdownIcon);
                }
                onChange(newValue);
            });
        });
        
        if (isColor) {
            selected.innerHTML = '';
            const selectedColorCircle = document.createElement('span');
            selectedColorCircle.className = 'color-circle';
            selectedColorCircle.style.backgroundColor = selectedValue;
            selectedColorCircle.title = selectedValue;
            
            selected.appendChild(selectedColorCircle);
            selected.appendChild(dropdownIcon);
        } else {
            selected.textContent = selectedValue;
            selected.appendChild(dropdownIcon);
        }
        
        wrapper.appendChild(dropdown);
        
        return {
            wrapper: wrapper,
            setSelected: (value) => {
                selectedValue = value;
                if (isColor) {
                    selected.innerHTML = '';
                    const selectedColorCircle = document.createElement('span');
                    selectedColorCircle.className = 'color-circle';
                    selectedColorCircle.style.backgroundColor = value;
                    selectedColorCircle.title = value;
                    
                    selected.appendChild(selectedColorCircle);
                    selected.appendChild(dropdownIcon);
                } else {
                    selected.textContent = value;
                    selected.appendChild(dropdownIcon);
                }
            }
        };
    }

    // Variant selection modal
    function openVariantModal(label, options, currentValue, isColor, onSelect) {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'variant-modal-overlay';
        
        const modal = document.createElement('div');
        modal.className = 'variant-modal';
        
        const modalHeader = document.createElement('div');
        modalHeader.className = 'variant-modal-header';
        
        const modalTitle = document.createElement('h3');
        modalTitle.className = 'variant-modal-title';
        modalTitle.textContent = label;
        
        const closeButton = document.createElement('button');
        closeButton.className = 'variant-modal-close';
        closeButton.innerHTML = '';
        closeButton.addEventListener('click', closeModal);
        
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(closeButton);
        
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'variant-modal-options';
        
        options.forEach(optionValue => {
            const option = document.createElement('div');
            option.className = 'variant-modal-option';
            if (optionValue === currentValue) {
                option.classList.add('selected');
            }
            option.dataset.value = optionValue;
            
            if (isColor) {
                const colorCircle = document.createElement('span');
                colorCircle.className = 'color-circle-large';
                colorCircle.style.backgroundColor = optionValue;
                colorCircle.title = optionValue;
                
                option.appendChild(colorCircle);
            } else {
                option.textContent = optionValue;
            }
            
            option.addEventListener('click', () => {
                onSelect(optionValue);
                closeModal();
            });
            
            optionsContainer.appendChild(option);
        });
        
        modal.appendChild(modalHeader);
        modal.appendChild(optionsContainer);
        modalOverlay.appendChild(modal);
        
        document.body.appendChild(modalOverlay);
        document.body.style.overflow = 'hidden';
        
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeModal();
            }
        });
        
        const escHandler = (e) => {
            if (e.key === 'Escape') closeModal();
        };
        document.addEventListener('keydown', escHandler);
        
        modalOverlay._escHandler = escHandler;
    }
    
    function closeModal() {
        const modal = document.querySelector('.variant-modal-overlay');
        if (modal) {
            document.removeEventListener('keydown', modal._escHandler);
            document.body.style.overflow = '';
            document.body.removeChild(modal);
        }
    }

    // Variant dropdowns helper
    function createVariantDropdowns(variants, onChange, initialVariant = null) {
        const container = document.createElement('div');
        container.className = 'variant-dropdowns';
        
        const variantTypes = analyzeVariantTypes(variants);
        
        const selectedValues = {};
        const dropdownControls = {};

        const startVariant = initialVariant || variants[0];
        variantTypes.forEach((type, idx) => {
            selectedValues[idx] = startVariant.item.variant[idx];
        });
        
        function updateDropdowns() {
            let filteredVariants = [...variants];
            
            variantTypes.forEach((type, idx) => {
                if (dropdownControls[idx]) {
                    const availableValues = [...new Set(
                        filteredVariants.filter(v => 
                            variantTypes.every((otherType, otherIdx) => 
                                otherIdx === idx || v.item.variant[otherIdx] === selectedValues[otherIdx]
                            )
                        ).map(v => v.item.variant[idx])
                    )];
                    
                    if (type.type === 'size') {
                        availableValues.sort((a, b) => {
                            const idxA = SIZE_ORDER.indexOf(a.toUpperCase());
                            const idxB = SIZE_ORDER.indexOf(b.toUpperCase());
                            if (idxA === -1 && idxB === -1) return 0;
                            if (idxA === -1) return 1;
                            if (idxB === -1) return -1;
                            return idxA - idxB;
                        });
                    }
                    
                    if (!availableValues.includes(selectedValues[idx]) && availableValues.length > 0) {
                        selectedValues[idx] = availableValues[0];
                        dropdownControls[idx].setSelected(selectedValues[idx]);
                    }
                }
            });
        }
        
        function getSelectedVariant() {
            return variants.find(v =>
                variantTypes.every((type, idx) => v.item.variant[idx] === selectedValues[idx])
            );
        }
        
        variantTypes.forEach((type, idx) => {
            const allValues = [...new Set(variants.map(v => v.item.variant[idx]))];
            
            let options = allValues;
            if (type.type === 'size') {
                options = sortSizes([...allValues]);
            }
            
            const dropdown = createCustomDropdown(
                type.label,
                options,
                selectedValues[idx],
                (newValue) => {
                    selectedValues[idx] = newValue;
                    updateDropdowns();
                    onChange(getSelectedVariant());
                },
                type.type === 'color',
                idx
            );
            
            dropdownControls[idx] = dropdown;
            container.appendChild(dropdown.wrapper);
        });
        
        updateDropdowns();
        onChange(getSelectedVariant());
        
        return container;
    }

    // Function to create preview button SVG
    function createPreviewButton(key) {
        const btn = document.createElement('button');
        btn.className = 'furniture-preview-button';
        btn.innerHTML = `
            <svg viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg">
            <g id="#000000ff">
                <path fill="currentColor" opacity="1.00" d="M36.64 15.81C50.35 12.75 64.6 18.19 74.99 27.1C80.59 32.24 86 37.71 90 44.21L90 45.73C88.02 49.39 85.71 52.88 82.91 55.98C78 61.42 72.6 66.65 65.92 69.86C60.03 72.66 53.67 74.84 47.09 74.94C33.6 75.71 20.23 69.69 10.94 60.06C6.55 55.91 2.82 51.08 0 45.74L0 44.21C3.86 37.89 9.09 32.58 14.49 27.57C20.71 21.84 28.52 18.03 36.64 15.81M42.33 24.28C35.57 24.96 29.44 29.28 26.35 35.3C23.27 41.54 23.38 49.22 26.69 55.35C29.39 59.98 33.82 63.75 39.08 65.06C46.25 67.12 54.61 65.29 59.84 59.85C67.89 52.16 67.88 37.84 59.85 30.15C55.4 25.51 48.63 23.5 42.33 24.28Z"/>
                <path fill="currentColor" opacity="1.00" d="M43.34 36.28C47.08 35.56 51.53 37.4 52.99 41.08C54.64 44.43 53.88 48.67 51.37 51.37C48.85 53.67 45 54.58 41.8 53.27C36.93 51.78 34.78 45.49 37 41.08C38 38.42 40.65 36.81 43.34 36.28Z"/>
            </g>
            </svg>`;
        btn.onclick = () => previewFurniture(key);
        return btn;
    }

    // Helper function to check requirements
    function checkRequirements(item) {
        let canPurchase = true;
        let unmetRequirements = [];

        if (item.requires && item.requires.length > 0) {
            item.requires.forEach(reqPair => {
                const [reqClass, reqLabel] = reqPair;
                if (reqClass === 'electricity') {
                    if (!taxesData.electricityTax.paid) {
                        canPurchase = false;
                        unmetRequirements.push(reqLabel);
                    }
                } else if (!ownedCssClasses.has(reqClass)) {
                    canPurchase = false;
                    unmetRequirements.push(reqLabel);
                }
            });
        }

        return { canPurchase, unmetRequirements };
    }

    // Helper function to check if item is currently owned (checks live data)
    function isItemOwned(assetIndex) {
        assetIndex = parseInt(assetIndex);
        
        // Check object assets
        for (const key in userObjectAssets) {
            if (parseInt(userObjectAssets[key].assetIndex) === assetIndex) {
                return true;
            }
        }
        
        // Check pet skins
        if (userPetAssets.pets) {
            for (const petId in userPetAssets.pets) {
                const pet = userPetAssets.pets[petId];
                if (pet.skins) {
                    for (const skinId in pet.skins) {
                        if (parseInt(pet.skins[skinId].assetIndex) === assetIndex) {
                            return true;
                        }
                    }
                }
            }
        }
        
        // Check supplies
        if (userPetAssets.supplies) {
            for (const supplyId in userPetAssets.supplies) {
                if (parseInt(userPetAssets.supplies[supplyId].assetIndex) === assetIndex) {
                    return true;
                }
            }
        }
        
        return false;
    }

    // --- Render grouped items ---
    for (const title in groupedItems) {
        const variants = groupedItems[title];
        
        let selectedVariant;
        if (selectedVariantState[title]) {
            const storedSelection = selectedVariantState[title];
            selectedVariant = variants.find(v => 
                v.item.variant.every((val, idx) => val === storedSelection[idx])
            ) || variants[0];
        } else {
            selectedVariant = variants[0];
        }

        // Check requirements for the selected variant
        const { canPurchase, unmetRequirements } = checkRequirements(selectedVariant.item);

        const itemDiv = document.createElement('div');
        itemDiv.className = 'shop-item grouped-item';

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${selectedVariant.item['css-class']}`;
        const previewHolder = document.createElement('div');
        previewHolder.className = 'item-preview-holder';
        previewHolder.appendChild(previewDiv);

        const isOwned = selectedVariant.item.oneOfKind && ownedIndexes.has(parseInt(selectedVariant.key));
        
        if (!isOwned && selectedVariant.item['css-class'] && selectedVariant.item['css-class'].includes("previewable")) {
            previewHolder.appendChild(createPreviewButton(selectedVariant.key));
        }

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';
        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = selectedVariant.item.title;
        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = (selectedVariant.item.description || "") + generateConsumableItemDescription(selectedVariant.item);

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        if (canPurchase) {
            const priceDiv = document.createElement('div');
            priceDiv.className = 'item-price';
            const coinSpan = document.createElement('span');
            coinSpan.className = 'item-price-coin-icon';
            coinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
            const priceSpan = document.createElement('span');
            priceSpan.textContent = selectedVariant.item.cost * COST_MULTIPLIER;
            priceDiv.appendChild(coinSpan);
            priceDiv.appendChild(priceSpan);

            const priceAndQuantDiv = document.createElement('div');
            priceAndQuantDiv.className = 'item-price-and-quantity';
            priceAndQuantDiv.appendChild(priceDiv);
            
            let quantityInput = null;
            if (!selectedVariant.item.oneOfKind) {
                const quantityInputHolder = document.createElement('div');
                quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';
                quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = 1;
                quantityInput.max = 999;
                quantityInput.step = 1;
                quantityInput.value = 1;
                quantityInput.className = 'purchase-quantity';
                quantityInput.id = `purchase-qty-${selectedVariant.key}`;
                quantityInput.readOnly = true;

                const updatePrice = () => {
                    const qty = parseInt(quantityInput.value, 10) || 1;
                    priceSpan.textContent = (selectedVariant.item.cost * COST_MULTIPLIER) * qty;
                };

                const minusBtn = document.createElement('button');
                minusBtn.className = 'control-btn';
                minusBtn.textContent = '';
                minusBtn.onmousedown = () => startHold(quantityInput.id, 1, 999, false, updatePrice);
                minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, 999, false, updatePrice); };
                minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                const plusBtn = document.createElement('button');
                plusBtn.className = 'control-btn';
                plusBtn.textContent = '+';
                plusBtn.onmousedown = () => startHold(quantityInput.id, 1, 999, true, updatePrice);
                plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, 999, true, updatePrice); };
                plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                quantityInputHolder.appendChild(minusBtn);
                quantityInputHolder.appendChild(quantityInput);
                quantityInputHolder.appendChild(plusBtn);
                priceAndQuantDiv.appendChild(quantityInputHolder);
                quantityInput.addEventListener('input', updatePrice);
                quantityInput.addEventListener('change', updatePrice);
            }

            infoDiv.appendChild(priceAndQuantDiv);

            let btn = createHoldPurchaseButton(selectedVariant.item, selectedVariant.key, selectedCategory, quantityInput);

            if (isOwned) {
                itemDiv.classList.add('owned');
                btn.classList.add('owned');
                btn.textContent = 'Nupirkta';
                btn.disabled = true;
                const ownedBadge = document.createElement('div');
                ownedBadge.className = 'owned-badge';
                ownedBadge.innerHTML = '<span class="owned-badge-icon"><img src="../images/icons/icon-check.svg"></span>';
                previewHolder.appendChild(ownedBadge);
            }

            const variantDropdowns = createVariantDropdowns(variants, (newVariant) => {
                selectedVariant = newVariant;
                selectedVariantState[title] = newVariant.item.variant;
                
                // Re-check requirements for new variant
                const { canPurchase: newCanPurchase, unmetRequirements: newUnmetRequirements } = checkRequirements(newVariant.item);
                
                previewDiv.className = `item-preview ${selectedVariant.item['css-class']}`;
                
                const newIsOwned = selectedVariant.item.oneOfKind && isItemOwned(selectedVariant.key);
                itemDiv.classList.toggle('owned', newIsOwned);
                
                // Remove existing price/requirements sections
                const existingPriceAndQuant = infoDiv.querySelector('.item-price-and-quantity');
                const existingRequires = infoDiv.querySelector('.item-requires');
                const existingStandalonePrice = infoDiv.querySelector('.item-price:not(.item-price-and-quantity .item-price)');
                
                if (existingPriceAndQuant) existingPriceAndQuant.remove();
                if (existingRequires) existingRequires.remove();
                if (existingStandalonePrice) existingStandalonePrice.remove();
                
                btn.remove();
                
                if (newCanPurchase) {
                    // Recreate price and quantity section
                    const newPriceDiv = document.createElement('div');
                    newPriceDiv.className = 'item-price';
                    const newCoinSpan = document.createElement('span');
                    newCoinSpan.className = 'item-price-coin-icon';
                    newCoinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
                    const newPriceSpan = document.createElement('span');
                    newPriceSpan.textContent = selectedVariant.item.cost * COST_MULTIPLIER;
                    newPriceDiv.appendChild(newCoinSpan);
                    newPriceDiv.appendChild(newPriceSpan);

                    const newPriceAndQuantDiv = document.createElement('div');
                    newPriceAndQuantDiv.className = 'item-price-and-quantity';
                    newPriceAndQuantDiv.appendChild(newPriceDiv);
                    
                    let newQuantityInput = null;
                    if (!selectedVariant.item.oneOfKind) {
                        const quantityInputHolder = document.createElement('div');
                        quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';
                        newQuantityInput = document.createElement('input');
                        newQuantityInput.type = 'number';
                        newQuantityInput.min = 1;
                        newQuantityInput.max = 999;
                        newQuantityInput.step = 1;
                        newQuantityInput.value = 1;
                        newQuantityInput.className = 'purchase-quantity';
                        newQuantityInput.id = `purchase-qty-${selectedVariant.key}`;
                        newQuantityInput.readOnly = true;

                        const updatePrice = () => {
                            const qty = parseInt(newQuantityInput.value, 10) || 1;
                            newPriceSpan.textContent = (selectedVariant.item.cost * COST_MULTIPLIER) * qty;
                        };

                        const minusBtn = document.createElement('button');
                        minusBtn.className = 'control-btn';
                        minusBtn.textContent = '';
                        minusBtn.onmousedown = () => startHold(newQuantityInput.id, 1, 999, false, updatePrice);
                        minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                        minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(newQuantityInput.id, 1, 999, false, updatePrice); };
                        minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                        const plusBtn = document.createElement('button');
                        plusBtn.className = 'control-btn';
                        plusBtn.textContent = '+';
                        plusBtn.onmousedown = () => startHold(newQuantityInput.id, 1, 999, true, updatePrice);
                        plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                        plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(newQuantityInput.id, 1, 999, true, updatePrice); };
                        plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                        quantityInputHolder.appendChild(minusBtn);
                        quantityInputHolder.appendChild(newQuantityInput);
                        quantityInputHolder.appendChild(plusBtn);
                        newPriceAndQuantDiv.appendChild(quantityInputHolder);
                        newQuantityInput.addEventListener('input', updatePrice);
                        newQuantityInput.addEventListener('change', updatePrice);
                    }

                    infoDiv.appendChild(newPriceAndQuantDiv);
                    quantityInput = newQuantityInput;
                    
                    btn = createHoldPurchaseButton(selectedVariant.item, selectedVariant.key, selectedCategory, quantityInput);
                    
                    if (newIsOwned) {
                        btn.classList.add('owned');
                        btn.textContent = 'Nupirkta';
                        btn.disabled = true;
                    }
                    
                    itemDiv.appendChild(btn);
                } else {
                    // Show requirements
                    const newPriceDiv = document.createElement('div');
                    newPriceDiv.className = 'item-price';
                    const newCoinSpan = document.createElement('span');
                    newCoinSpan.className = 'item-price-coin-icon';
                    newCoinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
                    const newPriceSpan = document.createElement('span');
                    newPriceSpan.textContent = selectedVariant.item.cost * COST_MULTIPLIER;
                    newPriceDiv.appendChild(newCoinSpan);
                    newPriceDiv.appendChild(newPriceSpan);

                    const requiresDiv = document.createElement('div');
                    requiresDiv.className = 'item-requires';
                    requiresDiv.textContent = 'Reikalinga: ' + newUnmetRequirements.join(', ');

                    itemDiv.appendChild(newPriceDiv);
                    itemDiv.appendChild(requiresDiv);
                }
                
                previewHolder.querySelector('.furniture-preview-button')?.remove();
                if (!newIsOwned && selectedVariant.item['css-class'] && selectedVariant.item['css-class'].includes("previewable")) {
                    previewHolder.appendChild(createPreviewButton(selectedVariant.key));
                }
                
                previewHolder.querySelector('.owned-badge')?.remove();
                if (newIsOwned) {
                    const ownedBadge = document.createElement('div');
                    ownedBadge.className = 'owned-badge';
                    ownedBadge.innerHTML = '<span class="owned-badge-icon"><img src="../images/icons/icon-check.svg"></span>';
                    previewHolder.appendChild(ownedBadge);
                }
                
                descP.innerHTML = (selectedVariant.item.description || "") + generateConsumableItemDescription(selectedVariant.item);
}, selectedVariant);
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(variantDropdowns);
        itemDiv.appendChild(btn);
    } else {
        // Cannot purchase - show requirements

        // Define selectedVariant first
        let selectedVariant;
        if (selectedVariantState[title]) {
            const storedSelection = selectedVariantState[title];
            selectedVariant = variants.find(v => 
                v.item.variant.every((val, idx) => val === storedSelection[idx])
            ) || variants[0];
        } else {
            selectedVariant = variants[0];
        }

        const variantDropdowns = createVariantDropdowns(variants, (newVariant) => {
            selectedVariant = newVariant;
            selectedVariantState[title] = newVariant.item.variant;
            
            const { canPurchase: newCanPurchase, unmetRequirements: newUnmetRequirements } = checkRequirements(newVariant.item);
            
            previewDiv.className = `item-preview ${selectedVariant.item['css-class']}`;
            
            const newIsOwned = selectedVariant.item.oneOfKind && isItemOwned(selectedVariant.key);
            itemDiv.classList.toggle('owned', newIsOwned);
            
            // Remove ALL existing price/requirements/button from BOTH infoDiv AND itemDiv
            infoDiv.querySelectorAll('.item-price-and-quantity, .item-requires, .item-price').forEach(el => el.remove());
            itemDiv.querySelectorAll('button:not(.control-btn):not(.furniture-preview-button):not(.variant-modal-close)').forEach(btn => btn.remove());
            
            if (newCanPurchase) {
                // Now can purchase - add price and button
                const newPriceDiv = document.createElement('div');
                newPriceDiv.className = 'item-price';
                const newCoinSpan = document.createElement('span');
                newCoinSpan.className = 'item-price-coin-icon';
                newCoinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
                const newPriceSpan = document.createElement('span');
                newPriceSpan.textContent = selectedVariant.item.cost * COST_MULTIPLIER;
                newPriceDiv.appendChild(newCoinSpan);
                newPriceDiv.appendChild(newPriceSpan);

                const newPriceAndQuantDiv = document.createElement('div');
                newPriceAndQuantDiv.className = 'item-price-and-quantity';
                newPriceAndQuantDiv.appendChild(newPriceDiv);
                
                let newQuantityInput = null;
                if (!selectedVariant.item.oneOfKind) {
                    const quantityInputHolder = document.createElement('div');
                    quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';
                    newQuantityInput = document.createElement('input');
                    newQuantityInput.type = 'number';
                    newQuantityInput.min = 1;
                    newQuantityInput.max = 999;
                    newQuantityInput.step = 1;
                    newQuantityInput.value = 1;
                    newQuantityInput.className = 'purchase-quantity';
                    newQuantityInput.id = `purchase-qty-${selectedVariant.key}`;
                    newQuantityInput.readOnly = true;

                    const updatePrice = () => {
                        const qty = parseInt(newQuantityInput.value, 10) || 1;
                        newPriceSpan.textContent = (selectedVariant.item.cost * COST_MULTIPLIER) * qty;
                    };

                    const minusBtn = document.createElement('button');
                    minusBtn.className = 'control-btn';
                    minusBtn.textContent = '';
                    minusBtn.onmousedown = () => startHold(newQuantityInput.id, 1, 999, false, updatePrice);
                    minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                    minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(newQuantityInput.id, 1, 999, false, updatePrice); };
                    minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                    const plusBtn = document.createElement('button');
                    plusBtn.className = 'control-btn';
                    plusBtn.textContent = '+';
                    plusBtn.onmousedown = () => startHold(newQuantityInput.id, 1, 999, true, updatePrice);
                    plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                    plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(newQuantityInput.id, 1, 999, true, updatePrice); };
                    plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                    quantityInputHolder.appendChild(minusBtn);
                    quantityInputHolder.appendChild(newQuantityInput);
                    quantityInputHolder.appendChild(plusBtn);
                    newPriceAndQuantDiv.appendChild(quantityInputHolder);
                    newQuantityInput.addEventListener('input', updatePrice);
                    newQuantityInput.addEventListener('change', updatePrice);
                }

                infoDiv.appendChild(newPriceAndQuantDiv);
                
                const btn = createHoldPurchaseButton(selectedVariant.item, selectedVariant.key, selectedCategory, newQuantityInput);
                
                if (newIsOwned) {
                    btn.classList.add('owned');
                    btn.textContent = 'Nupirkta';
                    btn.disabled = true;
                }
                
                itemDiv.appendChild(btn);
            } else {
                // Still cannot purchase - show requirements
                const newPriceDiv = document.createElement('div');
                newPriceDiv.className = 'item-price';
                const newCoinSpan = document.createElement('span');
                newCoinSpan.className = 'item-price-coin-icon';
                newCoinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
                const newPriceSpan = document.createElement('span');
                newPriceSpan.textContent = selectedVariant.item.cost * COST_MULTIPLIER;
                newPriceDiv.appendChild(newCoinSpan);
                newPriceDiv.appendChild(newPriceSpan);

                const newRequiresDiv = document.createElement('div');
                newRequiresDiv.className = 'item-requires';
                newRequiresDiv.textContent = 'Reikalinga: ' + newUnmetRequirements.join(', ');

                infoDiv.appendChild(newPriceDiv);
                infoDiv.appendChild(newRequiresDiv);
            }
            
            previewHolder.querySelector('.furniture-preview-button')?.remove();
            if (!newIsOwned && selectedVariant.item['css-class'] && selectedVariant.item['css-class'].includes("previewable")) {
                previewHolder.appendChild(createPreviewButton(selectedVariant.key));
            }
            
            previewHolder.querySelector('.owned-badge')?.remove();
            if (newIsOwned) {
                const ownedBadge = document.createElement('div');
                ownedBadge.className = 'owned-badge';
                ownedBadge.innerHTML = '<span class="owned-badge-icon"><img src="../images/icons/icon-check.svg"></span>';
                previewHolder.appendChild(ownedBadge);
            }
            
            descP.innerHTML = (selectedVariant.item.description || "") + generateConsumableItemDescription(selectedVariant.item);
        }, selectedVariant);
        
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(variantDropdowns);
    }

    shopContainer.appendChild(itemDiv);
}

// --- Render ungrouped items ---
ungroupedItems.forEach(({ key, item }) => {
    const assetIndex = parseInt(key);
    
    // Check requirements
    const { canPurchase, unmetRequirements } = checkRequirements(item);
    
    const itemDiv = document.createElement('div');
    const itemClasses = item.category.join(' ');
    itemDiv.className = `shop-item ${itemClasses}`;

    const previewDiv = document.createElement('div');
    previewDiv.className = `item-preview ${item['css-class']}`;
    const previewHolder = document.createElement('div');
    previewHolder.className = 'item-preview-holder';
    previewHolder.appendChild(previewDiv);

    const isOwned = item.oneOfKind && ownedIndexes.has(assetIndex);
    
    if (!isOwned && item['css-class'] && item['css-class'].includes("previewable")) {
        previewHolder.appendChild(createPreviewButton(key));
    }

    const infoDiv = document.createElement('div');
    infoDiv.className = 'item-info';
    const nameH3 = document.createElement('h3');
    nameH3.className = 'item-name';
    nameH3.textContent = item.title;
    const descP = document.createElement('p');
    descP.className = 'item-description';
    descP.innerHTML = (item.description || "") + generateConsumableItemDescription(item);

    infoDiv.appendChild(nameH3);
    infoDiv.appendChild(descP);

    if (canPurchase) {
        const priceDiv = document.createElement('div');
        priceDiv.className = 'item-price';
        const coinSpan = document.createElement('span');
        coinSpan.className = 'item-price-coin-icon';
        coinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
        const priceSpan = document.createElement('span');
        priceSpan.textContent = item.cost * COST_MULTIPLIER;
        priceDiv.appendChild(coinSpan);
        priceDiv.appendChild(priceSpan);

        const priceAndQuantDiv = document.createElement('div');
        priceAndQuantDiv.className = 'item-price-and-quantity';
        priceAndQuantDiv.appendChild(priceDiv);

        let quantityInput = null;
        if (!item.oneOfKind) {
            const quantityInputHolder = document.createElement('div');
            quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';
            quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.min = 1;
            quantityInput.max = 999;
            quantityInput.step = 1;
            quantityInput.value = 1;
            quantityInput.className = 'purchase-quantity';
            quantityInput.id = `purchase-qty-${key}`;
            quantityInput.readOnly = true;

            const updatePrice = () => {
                const qty = parseInt(quantityInput.value, 10) || 1;
                priceSpan.textContent = (item.cost * COST_MULTIPLIER) * qty;
            };

            const minusBtn = document.createElement('button');
            minusBtn.className = 'control-btn';
            minusBtn.textContent = '';
            minusBtn.onmousedown = () => startHold(quantityInput.id, 1, 999, false, updatePrice);
            minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
            minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, 999, false, updatePrice); };
            minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

            const plusBtn = document.createElement('button');
            plusBtn.className = 'control-btn';
            plusBtn.textContent = '+';
            plusBtn.onmousedown = () => startHold(quantityInput.id, 1, 999, true, updatePrice);
            plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
            plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, 999, true, updatePrice); };
            plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

            quantityInputHolder.appendChild(minusBtn);
            quantityInputHolder.appendChild(quantityInput);
            quantityInputHolder.appendChild(plusBtn);
            priceAndQuantDiv.appendChild(quantityInputHolder);
            quantityInput.addEventListener('input', updatePrice);
            quantityInput.addEventListener('change', updatePrice);
        }

        infoDiv.appendChild(priceAndQuantDiv);

        const btn = createHoldPurchaseButton(item, key, selectedCategory, quantityInput);

        if (isOwned) {
            itemDiv.classList.add('owned');
            btn.classList.add('owned');
            btn.textContent = 'Nupirkta';
            btn.disabled = true;
            const ownedBadge = document.createElement('div');
            ownedBadge.className = 'owned-badge';
            ownedBadge.innerHTML = '<span class="owned-badge-icon"><img src="../images/icons/icon-check.svg"></span>';
            previewHolder.appendChild(ownedBadge);
        }

        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(btn);
    } else {
        // Cannot purchase - show requirements
        const priceDiv = document.createElement('div');
        priceDiv.className = 'item-price';
        const coinSpan = document.createElement('span');
        coinSpan.className = 'item-price-coin-icon';
        coinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
        const priceSpan = document.createElement('span');
        priceSpan.textContent = item.cost * COST_MULTIPLIER;
        priceDiv.appendChild(coinSpan);
        priceDiv.appendChild(priceSpan);

        const requiresDiv = document.createElement('div');
        requiresDiv.className = 'item-requires';
        requiresDiv.textContent = 'Reikalinga: ' + unmetRequirements.join(', ');

        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(priceDiv);
        itemDiv.appendChild(requiresDiv);
    }

    shopContainer.appendChild(itemDiv);
});

// Show message if no items found
if (shopContainer.children.length === 0) {
    const messageDiv = document.createElement('div');
    messageDiv.textContent = `Nra nieko tinkamo iam augintiniui.`;
    messageDiv.className = 'no-matching-supplies-message';
    shopContainer.appendChild(messageDiv);
}

scalePreview();
}


const HOLD_DURATION_MS = 2000; // hold duration
const DYNAMIC_BTN_CLASS = 'purchase-btn-hold'; // unique class

function createHoldPurchaseButton(item, assetIndex, selectedCategory, quantityInput) {
    const btn = document.createElement('button');
    btn.className = `purchase-btn ${DYNAMIC_BTN_CLASS}`;
    
    // Add text content
    const textSpan = document.createElement('span');
    textSpan.textContent = 'Pirkti';
    btn.appendChild(textSpan);

    // Add responsive SVG with <rect>
    btn.innerHTML += `
        <svg class="btn-svg" viewBox="0 0 120 40" preserveAspectRatio="none">
            <rect x="1%" y="2" width="98%" height="36px" rx="10" ry="18"
                fill="none" stroke="var(--progress)" stroke-width="4"></rect>
        </svg>
    `;

    const svgRect = btn.querySelector('svg rect');

    // Dynamically calculate perimeter
    function updateStroke() {
        const width = btn.offsetWidth;
        const height = btn.offsetHeight;
        const perimeter = 2 * (width + height);
        
        // Remove transition first
        svgRect.style.transition = 'none';
        svgRect.style.strokeDasharray = perimeter;
        svgRect.style.strokeDashoffset = perimeter;
        
        // Force reflow
        svgRect.offsetHeight;
    }
    updateStroke();
    window.addEventListener('resize', updateStroke);

    // Hold logic
    let holdTimeout;

    function startHold() {
        // Reset state without transition
        updateStroke();
        
        btn.classList.add('process');

        // Use requestAnimationFrame to ensure reset happened before animating
        requestAnimationFrame(() => {
            // Animate stroke
            svgRect.style.transition = `stroke-dashoffset ${HOLD_DURATION_MS}ms linear`;
            svgRect.style.strokeDashoffset = '0';
        });

        holdTimeout = setTimeout(async () => {
            btn.classList.remove('process');
            btn.classList.add('success');

            const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
            await handlePurchase(item, assetIndex, quantity, selectedCategory, btn);
        }, HOLD_DURATION_MS-600);
    }

    function cancelHold() {
        clearTimeout(holdTimeout);
        btn.classList.remove('process');
        updateStroke();
    }

    btn.addEventListener('mousedown', startHold);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(); });
    btn.addEventListener('mouseup', cancelHold);
    btn.addEventListener('mouseleave', cancelHold);
    btn.addEventListener('touchend', cancelHold);
    btn.addEventListener('touchcancel', cancelHold);

    return btn;
}


// Toggle functionality for unpurchased only
const toggle = document.getElementById('shop-not-owned-toggle');
toggle.addEventListener('change', () => {
    updateShopState();
    const selectedCategory = document.getElementById('shop-category-select').value;
    const activeDepartment = document.querySelector('.department-btn.active .department-label').textContent;
    let dept;
    if (activeDepartment === 'Baldai') dept = 'furniture';
    if (activeDepartment === 'Gyvnliai') dept = 'pets';
    if (activeDepartment === 'Maistas' || activeDepartment === 'Reikmenys') dept = 'pet-supplies';
    renderShopItems(selectedCategory, dept, activePetSupplyTab);
});

function rerenderObjectAssetListIfNoItemsInSelectedCategory(sidebar=false) {
    // Select correct dropdown
    const dropdown = sidebar
        ? document.getElementById('object-sidebar-category-select')
        : document.getElementById('object-category-select');

    function thereAreItemsInSelectedCategory () {
        if (!dropdown) return false;

        const selected = dropdown.value;

        if (selected === 'all') {
            return Object.values(userObjectAssets).some(asset => {
                if (!asset || asset.assetIndex != null === false) return false;

                // NEW: sidebar only counts items not placed anywhere
                if (sidebar && asset.position && asset.position.length !== 0) return false;

                return true;
            });
        }

        for (const key in userObjectAssets) {
            const asset = userObjectAssets[key];
            if (!asset || asset.assetIndex == null) continue;

            // NEW: sidebar only counts items with no position
            if (sidebar && asset.position && asset.position.length !== 0) continue;

            const item = gameAssetIndex[asset.assetIndex];
            if (!item || !item.category) continue;

            if (item.category.includes(selected)) {
                return true;
            }
        }

        return false;
    }

    if (!thereAreItemsInSelectedCategory()) {
        if (sidebar) {
            renderObjectAssetsDropdown(sidebar);
        } else {
            renderObjectAssetsDropdown();
        }
    } else {
        if (sidebar) {
            let dropdown = document.getElementById('object-sidebar-category-select');
            if (dropdown) {
                renderObjectAssets(dropdown.value, false, true);
            }
        } else {
            let dropdown = document.getElementById('object-category-select');
            usageToggle = document.getElementById('object-usage-toggle');
            
            if (dropdown && usageToggle) {
                renderObjectAssets(dropdown.value, usageToggle.checked, false);
            }
        }
    }

    updateObjectAssetDropdown(sidebar);
}

function updateObjectAssetDropdown(sidebar = false) {
    let dropdown;
    if (sidebar) {
        dropdown = document.getElementById('object-sidebar-category-select');
    } else {
        dropdown = document.getElementById('object-category-select');
    }

    if (!dropdown) return;

    const currentValue = dropdown.value; // Save currently selected option

    // Gather categories from currently owned object assets
    const categoryCounts = {};

    for (const key in userObjectAssets) {
        const asset = userObjectAssets[key];
        if (!asset || asset.assetIndex == null) continue;

        // Sidebar only counts assets with empty position
        if (sidebar && asset.position && asset.position.length !== 0) continue;

        const item = gameAssetIndex[asset.assetIndex];
        if (!item || !item.category) continue;

        item.category.forEach(cat => {
            categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
        });
    }

    // Clear existing options
    dropdown.innerHTML = '';

    // Add "All" option
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = `Visi`;
    dropdown.appendChild(allOption);

    // Add categories (sorted alphabetically)
    Object.keys(categoryCounts).sort((a, b) => {
        const nameA = a.charAt(0).toUpperCase() + a.slice(1);
        const nameB = b.charAt(0).toUpperCase() + b.slice(1);
        return nameA.localeCompare(nameB);
    }).forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
        dropdown.appendChild(option);
    });

    // Restore previously selected option if it exists, else default to 'all'
    if (Array.from(dropdown.options).some(opt => opt.value === currentValue)) {
        dropdown.value = currentValue;
    } else {
        dropdown.value = 'all';
    }
}

function renderObjectAssetsDropdown(sidebar=false) {
    let dropdown;
    let usageToggle;
    let container;
    if (sidebar) {
        dropdown = document.getElementById('object-sidebar-category-select');
        container = document.querySelector('.object-sidebar-assets');
    } else {
        dropdown = document.getElementById('object-category-select');
        usageToggle = document.getElementById('object-usage-toggle');
        container = document.querySelector('.object-assets');

        if (!dropdown || !container || !usageToggle) return;

        usageToggle.checked = false;
    }

    // Gather categories from currently owned object assets
    const categoryCounts = {};
    let totalAssets = 0;

    for (const key in userObjectAssets) {
        const asset = userObjectAssets[key];
        if (!asset || asset.assetIndex == null) continue;

        // If sidebar, only count assets with empty position
        if (sidebar && asset.position && asset.position.length !== 0) continue;

        const item = gameAssetIndex[asset.assetIndex];
        if (!item || !item.category) continue;

        totalAssets++;
        item.category.forEach(cat => {
            categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
        });
    }

    // Clear existing options
    dropdown.innerHTML = '';

    // Add "All" option
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = `Visi`;
    allOption.selected = true;
    dropdown.appendChild(allOption);

    // Add categories (sorted alphabetically for consistency)
    Object.keys(categoryCounts).sort((a, b) => {
        const nameA = a.charAt(0).toUpperCase() + a.slice(1);
        const nameB = b.charAt(0).toUpperCase() + b.slice(1);
        return nameA.localeCompare(nameB);
    }).forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
        dropdown.appendChild(option);
    });

    // Initial render
    renderObjectAssets('all', false, sidebar);

    if (sidebar) {
        // Filter on dropdown change
        dropdown.addEventListener('change', () => {
            renderObjectAssets(dropdown.value, false, sidebar);
        });

    } else {
        // Filter on dropdown change
        dropdown.addEventListener('change', () => {
            renderObjectAssets(dropdown.value, usageToggle.checked, sidebar);
        });

        // Filter on toggle change
        usageToggle.addEventListener('change', () => {
            renderObjectAssets(dropdown.value, usageToggle.checked, sidebar);
        });
    }
}



function renderObjectAssets(selectedCategory = 'all', unusedOnly = false, sidebar) {
    let container;
    
    if (sidebar) {
        container = document.querySelector('.object-sidebar-assets');
    } else {
        container = document.querySelector('.object-assets');
    }

    if (!container) return;

    container.innerHTML = '';

    // Group stackable items by assetIndex
    const stackableGroups = {};
    const regularItems = [];

    for (const key in userObjectAssets) {
        const asset = userObjectAssets[key];
        const assetIndex = asset.assetIndex;
        const item = gameAssetIndex[assetIndex];
        if (!item) continue;

        if (item.stackable) {
            if (!stackableGroups[assetIndex]) {
                stackableGroups[assetIndex] = [];
            }
            stackableGroups[assetIndex].push(key);
        } else {
            regularItems.push(key);
        }
    }

    // Clean up excess unused stackable instances (keep only 1 unused per type)
    for (const assetIndex in stackableGroups) {
        const keys = stackableGroups[assetIndex];
        const unusedKeys = keys.filter(k => 
            !userObjectAssets[k].position || userObjectAssets[k].position.length === 0
        );

        // If more than 1 unused instance, delete extras
        if (unusedKeys.length > 1) {
            for (let i = 1; i < unusedKeys.length; i++) {
                delete userObjectAssets[unusedKeys[i]];
            }
            // Update the group to reflect deletions
            stackableGroups[assetIndex] = keys.filter(k => userObjectAssets[k]);
        }
    }

    // Render stackable items (one card per type)
    for (const assetIndex in stackableGroups) {
        const item = gameAssetIndex[assetIndex];
        if (!item) continue;

        // Category filter
        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;

        const keys = stackableGroups[assetIndex];
        const usedCount = keys.filter(k => 
            userObjectAssets[k].position && userObjectAssets[k].position.length > 0
        ).length;

        // Usage filter
        if (unusedOnly && usedCount === keys.length) continue;

        const itemDiv = document.createElement('div');
        itemDiv.className = `shop-item ${item.category.join(' ')}`;

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${item['css-class']}`;

        const previewHolder = document.createElement('div');
        previewHolder.className = `item-preview-holder`;

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';

        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = item.title;

        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = (item.description || "");
        descP.innerHTML += generateConsumableItemDescription(item);

        // Show usage count for stackable items
        if (usedCount > 0) {
            const countSpan = document.createElement('span');
            countSpan.className = 'item-quantity';
            if (!sidebar) {
                countSpan.textContent = `Naudojama: ${usedCount}`;
            }
            descP.appendChild(countSpan);
        }

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        const btn = document.createElement('button');
        btn.id = `${assetIndex}-use-btn`
        btn.className = 'use-btn';
        btn.textContent = 'Naudoti';
        btn.disabled = false;

        //Render Stackable Items
        btn.addEventListener('click', async () => {
            // Create a new instance for stackable items
            const newKey = getNextObjectKey();
            userObjectAssets[newKey] = { assetIndex: parseInt(assetIndex), position: [] };

            let tempDivId = renderSingleRoomObject(newKey);

            if (!sidebar) {
                document.querySelectorAll('.game-content-panel').forEach(p => p.classList.remove('active'));
                document.getElementById('pet-room-container').classList.add('active');

                const navButtons = document.querySelectorAll('.nav-item');
                navButtons.forEach(btn => btn.classList.remove('active'));
                navButtons[0].classList.add('active');
    
                updateStatsBeforeRerunningInitGameAndRenderPets();
                await initGame();
                let tempDivId = renderSingleRoomObject(newKey);
            }

            userObjectAssets[tempDivId].position = getObjectCoordinates(tempDivId);
            
            // Attempt to place the item at a valid position
            const placementMap = generatePlacementMap(tempDivId);
            const validPosition = findValidPosition(placementMap, tempDivId);

            if (validPosition) {
                userObjectAssets[tempDivId].position = validPosition;
                if (!sidebar) {
                    await sendObjectAssetsUpdateToDatabase();
                    updateStatsBeforeRerunningInitGameAndRenderPets();
                    await attemptGameInit();
                } else {
                    const tempDiv = document.getElementById(tempDivId)
                    tempDiv.style.left = `calc(${validPosition[0]} * var(--unit-size))`;
                    tempDiv.style.top = `calc((${validPosition[1] + 1} * var(--unit-size)) - ${tempDiv.offsetHeight}px)`;
                    
                    setTimeout(() => {
                        disableObjectDragging();
                        enableObjectDragging();
                    }, 50);
                }

                if (!isObjectVisibleInViewport(tempDivId)) {
                    centerViewportOnObject(tempDivId)
                }

                updateSingleItemZIndex(tempDivId)
            } else {
                userObjectAssets[tempDivId].position = [];
                document.getElementById(tempDivId).remove();
                delete userObjectAssets[tempDivId];
                if (gameAssetIndex[parseInt(assetIndex)].placingIndex === 13 || 
                    gameAssetIndex[parseInt(assetIndex)]["css-class"].includes("window-sill")) {
                    messageToTheUser("Nra tinkamo dydio lango arba j ustoja kiti daiktai!");
                } else {
                    messageToTheUser("Nepakanka vietos!");
                }
            }

            if (window.innerWidth <= 768) {
                closeSidebar();
            }
        });

        // Add delete button for stackable items when none are in use
        if (usedCount === 0) {
            const itemDeleteBtnHolder = document.createElement('div');
            itemDeleteBtnHolder.className = 'item-delete-btn-holder';
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'item-delete-btn';
            deleteBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 6 L6 18 M6 6 L18 18" stroke="#F5F5F7" stroke-width="2"/></svg>';

            deleteBtn.addEventListener('click', () => {
                const refund = Math.round((gameAssetIndex[userObjectAssets[keys[0]]["assetIndex"]].cost * COST_MULTIPLIER) / 2 * 10) / 10;
                showCustomConfirm(`Ar tikrai nori parduoti  daikt? U j atgausi tik pus kainos: 
                    <div class="coin-display-delete-confirm">
                        <span class="coin-icon">
                            <img src="../images/icons/icon-sudedu-coin.png">
                        </span>
                        <span class="coin-amount">${refund}</span>
                    </div>`, async () => {
                    
                    const sucess = await Promise.all(
                        keys.map(key => removeObjectFromUserAssets(key))
                    )

                    if (sucess) {
                        const moneySuccess = await sendMoneyTransactionToDatabase(refund, 'add');
                    
                        if (!moneySuccess) {
                            return;
                        }
                        
                        userMoney += refund;
                        updateCoinAmounts(userMoney);
                    }

                    rerenderObjectAssetListIfNoItemsInSelectedCategory();
                    renderShopCategoriesDropdown();
                });
            });

            if (!sidebar) {
                itemDeleteBtnHolder.appendChild(deleteBtn);
                previewDiv.appendChild(itemDeleteBtnHolder);
            }
        }

        previewHolder.appendChild(previewDiv);
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(btn);

        container.appendChild(itemDiv);
    }

    // Render regular (non-stackable) items
    for (const key of regularItems) {
        const asset = userObjectAssets[key];
        const assetIndex = asset.assetIndex;
        const item = gameAssetIndex[assetIndex];
        if (!item) continue;

        // Category filter
        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;
        // Usage filter
        if (unusedOnly && asset.position && asset.position.length > 0) continue;

        const itemDiv = document.createElement('div');
        itemDiv.className = `shop-item ${item.category.join(' ')}`;
        itemDiv.id = `${key}-item-card`

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${item['css-class']}`;

        const previewHolder = document.createElement('div');
        previewHolder.className = `item-preview-holder`;

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';

        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = item.title;

        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = (item.description || "");
        descP.innerHTML += generateConsumableItemDescription(item);

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        const btn = document.createElement('button');
        btn.className = 'use-btn';
        btn.id = `${key}-use-btn`

        if (asset.position && asset.position.length > 0) {
            btn.textContent = 'Naudojama';
            btn.disabled = true;
            btn.className = 'use-btn used';
            itemDiv.classList.add("in-use");
        } else {
            btn.textContent = 'Naudoti';
            btn.disabled = false;
        }

        btn.addEventListener('click', async () => {
            let tempDivId = renderSingleRoomObject(key);

            userObjectAssets[tempDivId].position = getObjectCoordinates(tempDivId);

            if (!sidebar) {
                document.querySelectorAll('.game-content-panel').forEach(p => p.classList.remove('active'));
                document.getElementById('pet-room-container').classList.add('active');

                const navButtons = document.querySelectorAll('.nav-item');
                navButtons.forEach(btn => btn.classList.remove('active'));
                navButtons[0].classList.add('active');
                
                updateStatsBeforeRerunningInitGameAndRenderPets();
                await initGame();
            }
        
            // Attempt to place the item at a valid position
            const placementMap = generatePlacementMap(tempDivId);
            const validPosition = findValidPosition(placementMap, tempDivId);

            if (validPosition) {
                userObjectAssets[tempDivId].position = validPosition;
                if (!sidebar) {
                    await sendObjectAssetsUpdateToDatabase();
                    updateStatsBeforeRerunningInitGameAndRenderPets();
                    await attemptGameInit();
                } else {
                    const tempDiv = document.getElementById(tempDivId)
                    tempDiv.style.left = `calc(${validPosition[0]} * var(--unit-size))`;
                    tempDiv.style.top = `calc((${validPosition[1] + 1} * var(--unit-size)) - ${tempDiv.offsetHeight}px)`;
                    rerenderObjectAssetListIfNoItemsInSelectedCategory(sidebar=true);
                    setTimeout(() => {
                        disableObjectDragging();
                        enableObjectDragging();
                    }, 50);
                }

                if (!isObjectVisibleInViewport(tempDivId)) {
                    centerViewportOnObject(tempDivId)
                }

                updateSingleItemZIndex(tempDivId)
            } else {
                userObjectAssets[tempDivId].position = [];
                document.getElementById(tempDivId).remove();
                if (gameAssetIndex[userObjectAssets[tempDivId].assetIndex].placingIndex === 13 || 
                    gameAssetIndex[userObjectAssets[tempDivId].assetIndex]["css-class"].includes("window-sill")) {
                    messageToTheUser("Nra tinkamo dydio lango arba j ustoja kiti daiktai!");
                } else {
                    messageToTheUser("Nepakanka vietos!");
                }
            }

            itemDiv.classList.add("in-use");

            if (sidebar) {
                if (userObjectAssets[tempDivId].position && userObjectAssets[tempDivId].position.length > 0) {
                    btn.textContent = 'Naudojama';
                    btn.disabled = true;
                    btn.className = 'use-btn used';
                } else {
                    btn.textContent = 'Naudoti';
                    btn.disabled = false;
                    btn.className = 'use-btn';
                }
            }

            if (window.innerWidth <= 768) {
                closeSidebar();
            }
        });

        if (asset.position && asset.position.length === 0) {
            const itemDeleteBtnHolder = document.createElement('div');
            itemDeleteBtnHolder.className = 'item-delete-btn-holder';
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'item-delete-btn';
            deleteBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 6 L6 18 M6 6 L18 18" stroke="#F5F5F7" stroke-width="2"/></svg>';

            deleteBtn.addEventListener('click', () => {
                const itemPrice = Math.round((gameAssetIndex[userObjectAssets[key]["assetIndex"]].cost * COST_MULTIPLIER) / 2 * 10) / 10;
                showCustomConfirm(`Ar tikrai nori parduoti  daikt? U j atgausi tik pus kainos: 
                <div class="coin-display-delete-confirm">
                    <span class="coin-icon">
                        <img src="../images/icons/icon-sudedu-coin.png">
                    </span>
                    <span class="coin-amount">${itemPrice}</span>
                </div>`, 
                removeObjectFromUserAssets, [key, itemPrice]);
            });
            
            if (!sidebar) {
                itemDeleteBtnHolder.appendChild(deleteBtn);
                previewDiv.appendChild(itemDeleteBtnHolder);
            }
        }

        previewHolder.appendChild(previewDiv);
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(btn);

        container.appendChild(itemDiv);
    }

    scalePreview();
}

async function removeObjectFromUserAssets(assetKey, refund=null) {
    delete userObjectAssets[assetKey];
    let success = await sendObjectAssetsUpdateToDatabase();
    if (success && refund) {
        console.log(refund)
        const moneySuccess = await sendMoneyTransactionToDatabase(refund, 'add');
    
        if (!moneySuccess) {
            return;
        }
        
        userMoney += refund;
        updateCoinAmounts(userMoney);
    }
    rerenderObjectAssetListIfNoItemsInSelectedCategory();
}

// Render a single object in the room
function renderSingleRoomObject(assetId) {
    const roomObjectsContainer = document.querySelector("#roomObjectsContainer");
    const asset = userObjectAssets[assetId];
    const item = gameAssetIndex[asset.assetIndex];

    const div = document.createElement("div");
    div.className = `room-object ${item["css-class"]}`;
    div.id = assetId;
    roomObjectsContainer.appendChild(div);

    div.style.left = `0px`;
    div.style.top = `0px`;

    return assetId;
}

function findValidPosition(placementMap, assetId) {
    const asset = document.getElementById(assetId);
    if (!asset) return null;

    // Calculate dimensions in tiles
    const objectWidth = Math.ceil(asset.offsetWidth / unitSize);
    const objectHeight = Math.ceil(asset.offsetHeight / unitSize);

    const [targetCol, targetRow] = viewportState.closestTile;
    
    // Helper to check if object fits at position according to new placement rules
    const checkFit = (startRow, startCol) => {
        const rows = objectHeight;
        const cols = objectWidth;

        // Check bottom row - must be in canPlace tiles
        const bottomRow = startRow + rows - 1;
        for (let c = 0; c < cols; c++) {
            const mapCol = startCol + c;
            
            if (!placementMap[bottomRow] || 
                !placementMap[bottomRow][mapCol] || 
                !placementMap[bottomRow][mapCol].canPlace) {
                return false;
            }
        }

        // Check upper rows - can be in either canPlace OR canOccupy tiles
        for (let r = 0; r < rows - 1; r++) {
            for (let c = 0; c < cols; c++) {
                const mapRow = startRow + r;
                const mapCol = startCol + c;

                if (!placementMap[mapRow] || 
                    !placementMap[mapRow][mapCol] || 
                    (!placementMap[mapRow][mapCol].canPlace && !placementMap[mapRow][mapCol].canOccupy)) {
                    return false;
                }
            }
        }
        
        return true;
    };
    
    // Valid tile types for rooms
    const validTypes = new Set([1.0, 2.0, 3.0]);
    
    // Helper to check if tile is valid
    const isValidTile = (x, y) => {
        if (x < 0 || x >= roomLayout[0].length || y < 0 || y >= roomLayout.length) return false;
        const tileType = roomLayout[y][x];
        const type = tileType?.type ?? tileType;
        return validTypes.has(type);
    };
    
    // Find all tiles in the room containing the target position using flood-fill
    const roomTiles = new Set();
    if (isValidTile(targetCol, targetRow)) {
        const visited = new Set();
        const queue = [[targetCol, targetRow]];
        visited.add(`${targetCol},${targetRow}`);
        
        while (queue.length > 0) {
            const [x, y] = queue.shift();
            roomTiles.add(`${x},${y}`);
            
            // Check 4 adjacent cells
            const neighbors = [[x-1, y], [x+1, y], [x, y-1], [x, y+1]];
            for (const [nx, ny] of neighbors) {
                const key = `${nx},${ny}`;
                if (!visited.has(key) && isValidTile(nx, ny)) {
                    visited.add(key);
                    queue.push([nx, ny]);
                }
            }
        }
    }
    
    // Helper to check if position is in the target room
    const isInTargetRoom = (col, row) => {
        // Check if any part of the object footprint is in the target room
        for (let y = 0; y < objectHeight; y++) {
            for (let x = 0; x < objectWidth; x++) {
                if (roomTiles.has(`${col + x},${row + y}`)) {
                    return true;
                }
            }
        }
        return false;
    };
    
    let closestInRoom = null;
    let closestGlobal = null;
    let minDistanceInRoom = Infinity;
    let minDistanceGlobal = Infinity;

    // Search placement map for fitting positions
    for (let row = 0; row < placementMap.length; row++) {
        for (let col = 0; col < placementMap[0].length; col++) {
            if (checkFit(row, col)) {
                // Calculate position (center or bottom-left based on your preference)
                // The new placement rules use startRow (top-left), so we need to convert
                // to whatever coordinate system your original used
                const positionRow = row + objectHeight - 1; // Bottom row if using bottom-left
                const positionCol = col; // Left column
                
                // Calculate distance to target
                const distance = Math.sqrt(
                    Math.pow(positionCol - targetCol, 2) + 
                    Math.pow(positionRow - targetRow, 2)
                );
                
                // Check if in target room
                if (roomTiles.size > 0 && isInTargetRoom(col, row)) {
                    if (distance < minDistanceInRoom) {
                        minDistanceInRoom = distance;
                        closestInRoom = [positionCol, positionRow];
                    }
                }
                
                // Track global closest as backup
                if (distance < minDistanceGlobal) {
                    minDistanceGlobal = distance;
                    closestGlobal = [positionCol, positionRow];
                }
            }
        }
    }
    
    // Prefer position in target room, fall back to global closest
    return closestInRoom || closestGlobal;
}


function scalePreview() {
    const holders = document.querySelectorAll(".item-preview-holder");

    holders.forEach(holder => {
        const preview = holder.querySelector(".item-preview");
        if (!preview) return; // safety check

        const holderW = holder.clientWidth;
        const holderH = holder.clientHeight;
        const previewW = preview.scrollWidth;
        const previewH = preview.scrollHeight;

        const scale = Math.min(holderW / previewW, holderH / previewH, 1);
        preview.style.setProperty("--scale", scale);
    });
}


// CREATE SHOPPING FUNCTIONALITY END

function renderPetAssetsDropdown(selectedPetType = null) {
    const dropdown = document.getElementById('pet-category-select');
    const container = document.getElementById('pet-supplies');
    
    if (!container) return;

    // If no pet selected, show message
    if (!selectedPetType) {
        container.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Pasirink augintin!';
        messageDiv.className = 'no-selection-message';
        container.appendChild(messageDiv);
        return;
    }

    // Check if there are any supplies at all
    if (!userPetAssets.supplies || Object.keys(userPetAssets.supplies).length === 0) {
        container.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Maisto nra. Gali nupirkti parduotuvje.';
        messageDiv.className = 'no-supplies-message';
        container.appendChild(messageDiv);
        return;
    }

    // If dropdown exists, set up category filtering
    if (dropdown) {
        // Gather categories from currently owned Maistas (filtered by selected pet)
        const categoryCounts = {};
        let totalAssets = 0;
        
        for (const key in userPetAssets.supplies) {
            const asset = userPetAssets.supplies[key];
            if (!asset || asset.assetIndex == null) continue;
            
            const item = gameAssetIndex[asset.assetIndex];
            if (!item || !item.category) continue;

            // Skip skins (items with 'skin' in their css-class)
            if (item['css-class'] && item['css-class'].includes('skin')) continue;

            // Filter by selected pet type
            if (selectedPetType) {
                const cssClass = item['css-class'] || '';
                if (!cssClass.includes(selectedPetType.split('-')[0])) continue;
            }
            
            totalAssets++;
            item.category.forEach(cat => {
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });
        }

        // Clear existing options
        dropdown.innerHTML = '';

        // Add "All" option
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = `Visi`;
        allOption.selected = true;
        dropdown.appendChild(allOption);

        // Add categories (sorted alphabetically for consistency)
        Object.keys(categoryCounts).sort().forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
            dropdown.appendChild(option);
        });

        // Filter on dropdown change
        dropdown.onchange = () => {
            renderPetSupplies(dropdown.value, selectedPetType);
        };
    }

    // Initial render
    renderPetSupplies('all', selectedPetType);
}

function renderPetSupplies(selectedCategory = 'all', selectedPetType = null) {
    const container = document.getElementById('pet-supplies');
    if (!container) return;

    container.innerHTML = '';

    // If no pet selected, show message
    if (!selectedPetType) {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Pasirink augintin!';
        messageDiv.className = 'no-selection-message';
        container.appendChild(messageDiv);
        return;
    }

    const petIdentifier = selectedPetType.split('-')[0];
    let hasMatchingSupplies = false;

    // Render Maistas
    for (const key in userPetAssets.supplies) {
        const asset = userPetAssets.supplies[key];
        const assetIndex = asset.assetIndex;
        const item = gameAssetIndex[assetIndex];
        
        if (!item) continue;

        // Skip skins (items with 'skin' in their css-class)
        if (item['css-class'] && item['css-class'].includes('skin')) continue;

        // Category filter
        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;

        // Filter by selected pet type
        const cssClass = item['css-class'] || '';
        if (!cssClass.includes(petIdentifier)) {
            continue;
        }

        hasMatchingSupplies = true;

        const itemDiv = document.createElement('div');
        itemDiv.className = `shop-item ${item.category.join(' ')}`;

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${item['css-class']}`;

        const previewHolder = document.createElement('div');
        previewHolder.className = 'item-preview-holder';

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';

        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = item.title;

        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = (item.description || "");
        descP.innerHTML += generateConsumableItemDescription(item)

        // Add quantity display for supplies
        if (asset.quantity) {
            const quantitySpan = document.createElement('span');
            quantitySpan.className = 'item-quantity';
            quantitySpan.textContent = ` (x${asset.quantity})`;
            nameH3.appendChild(quantitySpan);
        }

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        let quantityInput = null;
        if (!item.oneOfKind && item.stackable) {
            const quantityInputHolder = document.createElement('div');
            quantityInputHolder.className = 'pet-supply-use-quantity-holder input-wrapper';

            const quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.min = 1;
            quantityInput.max = asset.quantity; // don't allow more than owned
            quantityInput.value = 1;
            quantityInput.className = 'pet-supply-use-quantity';
            quantityInput.readOnly = true; // prevent manual typing if using buttons

            // Set ID before using it in buttons
            quantityInput.id = `pet-supply-qty-${asset.assetIndex}`;

            // Buttons
            const minusBtn = document.createElement('button');
            minusBtn.className = 'control-btn';
            minusBtn.textContent = '';
            minusBtn.onmousedown = () => startHold(quantityInput.id, 1, asset.quantity, false, () => updateQuantity(quantityInput));
            minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
            minusBtn.ontouchstart = (e) => { 
                e.preventDefault(); 
                startHold(quantityInput.id, 1, asset.quantity, false, () => updateQuantity(quantityInput)); 
            };
            minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

            const plusBtn = document.createElement('button');
            plusBtn.className = 'control-btn';
            plusBtn.textContent = '+';
            plusBtn.onmousedown = () => startHold(quantityInput.id, 1, asset.quantity, true, () => updateQuantity(quantityInput));
            plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
            plusBtn.ontouchstart = (e) => { 
                e.preventDefault(); 
                startHold(quantityInput.id, 1, asset.quantity, true, () => updateQuantity(quantityInput)); 
            };
            plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

            quantityInputHolder.appendChild(minusBtn);
            quantityInputHolder.appendChild(quantityInput);
            quantityInputHolder.appendChild(plusBtn);

            // Update function
            function updateQuantity(input) {
                if (!input) input = quantityInput;
                let value = parseInt(input.value, 10);
                const min = parseInt(input.min, 10);
                const max = parseInt(input.max, 10);
                if (isNaN(value) || value < min) value = min;
                if (value > max) value = max;
                input.value = value;
            }

            // Optional: if you want manual input allowed
            quantityInput.addEventListener('input', () => updateQuantity(quantityInput));
            quantityInput.addEventListener('change', () => updateQuantity(quantityInput));

            infoDiv.appendChild(quantityInputHolder);
        }

        const btn = document.createElement('button');
        btn.className = 'use-btn';

        // Handle different types of Maistas
        if (!item.stackable && item.oneOfKind) {
            // Non-consumable items (like beds, toys)
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                console.log(`Using ${item.title}`);
            });
        } else {
            // Consumable items
            btn.textContent = 'Naudoti';
            if (!item.stackable && item.oneOfKind) {
            // Non-consumable items (like beds, toys)
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                usePetSupply(key);
            });
        } else {
            // Consumable items with quantity support
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                const useQuantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                if (asset.quantity >= useQuantity) {
                    usePetSupply(key, useQuantity);
                }
            });
        }
        }

        previewHolder.appendChild(previewDiv);
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(btn);
        container.appendChild(itemDiv);
    }

    // If no matching supplies found after filtering
    if (!hasMatchingSupplies) {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = `Maisto tinkamo iam augintiniui nra. Gali nupirkti parduotuvje.`;
        messageDiv.className = 'no-matching-supplies-message';
        container.appendChild(messageDiv);
    }

    scalePreview();
}

function usePetSupply (itemIndex, useQuantity=1) {
    selectedConsumable = [itemIndex, useQuantity];
    const item = userPetAssets["supplies"][itemIndex]
    const itemInfo = gameAssetIndex[item.assetIndex]
    const providesData = itemInfo["provides"]

    if (!providesData) return

    const provides = providesData[0]
    const providesFor = providesData[1]
    if (provides === "food") {
        document.getElementById("pet-room-button").click();
        selectFullSpeciesBowls (providesFor)

    } else if (provides === "love") {
        selectedConsumable = [itemIndex, useQuantity];
        
        document.getElementById("pet-room-button").click();

        messageToTheUser(`Pasirink augintin.`, false)
    }
}

function selectFullSpeciesBowls (providesFor) {
    const objects = document.querySelectorAll('.room-object');
    let foodBowls = []
    providesFor.forEach(item => {
    const matching = Array.from(objects).filter(obj =>
        obj.className.includes(`${item}-food-bowl`) && !obj.className.includes("furniture-preview") && !obj.className.includes("full")
    );
        foodBowls.push(...matching); // add to the overall list
    });

    if (foodBowls.length === 0) {
        messageToTheUser(`Nra tinkamo tucio maisto dubenlio.`)
    } else {
        highlightSpecificObjects(foodBowls);
    }
}

function highlightSpecificObjects(objects) {
    objects.forEach(obj => {
        const coords = getObjectCoordinates(obj.id)
        const objectWidth = Math.ceil(obj.offsetWidth / unitSize);
        const objectHeight = Math.ceil(obj.offsetHeight / unitSize);
        const occupiedTiles = getTilesOccupiedByObject(coords, objectWidth, objectHeight)
          
        for (let i = 0; i < occupiedTiles.length; i++) {
            createSpecificPlacementHighlight(occupiedTiles[i][0], occupiedTiles[i][1], true)
        }  
    });
    
    messageToTheUser(`Pasirink maisto dubenl.`, false)
}

// Function to create individual highlight overlay
function createSpecificPlacementHighlight(col, row, isValid) {
    const highlight = document.createElement('div');
    highlight.className = `placement-highlight ${isValid ? 'valid' : 'invalid'}`;
    highlight.style.cssText = `
        position: absolute;
        left: calc(${col} * var(--unit-size));
        top: calc(${row} * var(--unit-size));
        width: var(--unit-size);
        height: var(--unit-size);
        background-color: ${isValid ? 'rgba(0, 255, 0, 0.15)' : 'rgba(255, 0, 0, 0.15)'};
        pointer-events: none;
        z-index: 1000;
    `;
    
    document.getElementById('room-container').appendChild(highlight);
}

function clearSpecificPlacementHighlights() {
    document.querySelectorAll('.placement-highlight').forEach(highlight => {
        highlight.remove();
    });
}

function getTilesOccupiedByObject(bottomLeft, width, height) {
    if (!bottomLeft || !Array.isArray(bottomLeft) || bottomLeft.length < 2) {
        return [];
    }

    const [x, y] = bottomLeft;
    const tiles = [];

    for (let dx = 0; dx < width; dx++) {
        for (let dy = 0; dy < height; dy++) {
            tiles.push([x + dx, y - dy]); 
        }
    }
    return tiles;
}

function renderPetSkins(selectedPetType = null) {
    const container = document.getElementById('pet-skins');
    if (!container) return;

    container.innerHTML = '';

    // If specific pet selected, only show that pet's skins
    if (selectedPetType && userPetAssets.pets[selectedPetType] && userPetAssets.pets[selectedPetType].skins) {
        const pet = userPetAssets.pets[selectedPetType];
        
        for (const skinKey in pet.skins) {
            const skin = pet.skins[skinKey];
            const assetIndex = skin.assetIndex;
            const item = gameAssetIndex[assetIndex];
            
            if (!item) continue;

            // Simplified skin check - look for 'skin' in css-class
            if (!item['css-class'] || !item['css-class'].includes('skin')) continue;

            if (selectedPetType && !item['css-class'].includes(selectedPetType)) continue;

            const itemDiv = document.createElement('div');
            itemDiv.className = `shop-item ${item.category.join(' ')}`;

            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']}`;

            const previewHolder = document.createElement('div');
            previewHolder.className = 'item-preview-holder';

            const infoDiv = document.createElement('div');
            infoDiv.className = 'item-info';

            const nameH3 = document.createElement('h3');
            nameH3.className = 'item-name';
            nameH3.textContent = item.title;

            const descP = document.createElement('p');
            descP.className = 'item-description';
            descP.innerHTML = (item.description || "");
            descP.innerHTML += generateConsumableItemDescription(item)

            infoDiv.appendChild(nameH3);
            infoDiv.appendChild(descP);

            const btn = document.createElement('button');
            
            if (skin.equiped) {
                btn.textContent = 'Naudojama';
                btn.disabled = true;
                btn.className = 'use-btn equipped';
            } else {
                btn.textContent = 'Naudoti';
                btn.className = 'use-btn';
                btn.addEventListener('click', () => {
                    // Unequip other skins of the same pet type
                    for (const otherSkinKey in pet.skins) {
                        pet.skins[otherSkinKey].equiped = false;
                    }
                    // Equip this skin
                    skin.equiped = true;
                    
                    sendPetAssetsUpdateToDatabase();
                    renderUsersPetAssets();
                });
            }

            previewHolder.appendChild(previewDiv);
            itemDiv.appendChild(previewHolder);
            itemDiv.appendChild(infoDiv);
            itemDiv.appendChild(btn);
            container.appendChild(itemDiv);
        }
    } else {
        // Show message when no specific pet is selected
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Please select a pet to view their skins';
        messageDiv.className = 'no-selection-message';
        container.appendChild(messageDiv);
    }

    scalePreview();
}

function ensurePetSelection() {
    // Ensure a pet is always selected when pets are available
    if ((!selectedPet || !userPetAssets.pets[selectedPet]) && Object.keys(userPetAssets.pets).length > 0) {
        selectedPet = Object.keys(userPetAssets.pets)[0];
        syncPetSelection();
    }
}

function renderPetListForPetSection() {
    const container = document.getElementById('pet-list-owned');
    if (!container) return;

    container.innerHTML = '';

    // Ensure we have a selected pet if pets exist
    if (!selectedPet && Object.keys(userPetAssets.pets).length > 0) {
        selectedPet = Object.keys(userPetAssets.pets)[0];
    }

    // Render buttons for each owned pet
    for (const petType in userPetAssets.pets) {
        const pet = userPetAssets.pets[petType];
        
        // Find the equipped skin to show preview
        let equippedSkinAssetIndex = null;
        for (const skinKey in pet.skins) {
            if (pet.skins[skinKey].equiped) {
                equippedSkinAssetIndex = pet.skins[skinKey].assetIndex;
                break;
            }
        }

        // If no equipped skin, use the first available skin
        if (!equippedSkinAssetIndex && Object.keys(pet.skins).length > 0) {
            const firstSkinKey = Object.keys(pet.skins)[0];
            equippedSkinAssetIndex = pet.skins[firstSkinKey].assetIndex;
        }

        const petItem = gameAssetIndex[equippedSkinAssetIndex];
        if (!petItem) continue;

        // --- Pet button ---
        const petBtn = document.createElement('button');
        petBtn.className = `pet-btn ${selectedPet === petType ? 'active' : ''}`;
        
        const previewDiv = document.createElement('div');
        previewDiv.className = `pet-preview ${petItem["css-class"].split(" ").slice(0, 2).join(" ")}`;
        petBtn.appendChild(previewDiv);

        petBtn.addEventListener('click', () => {
            selectedPet = petType;
            
            // Update active state for pet section buttons only
            document.querySelectorAll('#pet-list-owned .pet-btn').forEach(btn => btn.classList.remove('active'));
            petBtn.classList.add('active');

            // Check which content is currently visible and refresh it
            const petSkinsContainer = document.getElementById('pet-skins');
            const petSuppliesContainer = document.getElementById('pet-supplies');
            
            if (petSuppliesContainer && petSuppliesContainer.style.display !== 'none') {
                renderPetAssetsDropdown(selectedPet);
            } else if (petSkinsContainer && petSkinsContainer.style.display !== 'none') {
                renderPetSkins(selectedPet);
            } else {
                // Fallback: check active department button
                const activeDepartment = document.querySelector('#pet-asset-container .department-btn.active .department-label').textContent;
                if (activeDepartment === 'Ivaizda') {
                    renderPetSkins(selectedPet);
                } else if (activeDepartment === 'Maistas' || activeDepartment === 'Reikmenys') {
                    renderPetAssetsDropdown(selectedPet);
                }
            }
        });

        // --- Delete Pet button ---
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'pet-delete-btn';
        deleteBtn.textContent = 'Atiduoti';
        deleteBtn.addEventListener('click', () => {
            showCustomConfirm("Ar tikrai nori atiduoti  augintin  gyvunli namus? Jo susigrinti negalsi.", deletePetConfirmed, [petType]);
        });

        const petSectionPetButtonContainer = document.createElement('div');
        petSectionPetButtonContainer.className = 'pet-section-pet-button-container';

        petSectionPetButtonContainer.appendChild(deleteBtn)
        petSectionPetButtonContainer.appendChild(petBtn)
        
        container.appendChild(petSectionPetButtonContainer);
    }
}

function deletePetConfirmed(petId) {
    delete userPetAssets["pets"][petId];
    
    // Reset selectedPet if the deleted pet was selected
    if (selectedPet === petId) {
        selectedPet = null;
    }

    const petDiv = document.getElementById(petId);

    if (petDiv) {
        petDiv.remove();
    }
    
    sendPetAssetsUpdateToDatabase();
    deletePetStatsInDatabase(petId)
    renderUsersPetAssets();
    updateStatsBeforeRerunningInitGameAndRenderPets();
    renderPets();
    enablePetDragging();
    createPetButtons();
}

async function deletePetStatsInDatabase(petId) {
    try {
        const response = await apiFetch(apiBase + 'petGame/deletePetStats', {
            method: 'POST', // or 'DELETE' if backend is updated
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                studentId: userData.userId,
                petId: petId
            })
        });

        if (!response) {
            return;
        }

        if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
        }

        console.log(`Successfully deleted pet stats for: ${petId}`);

        // Optionally remove the pets element from the UI
        const petDiv = document.getElementById(petId);
        if (petDiv) {
            petDiv.remove();
        }

    } catch (error) {
        console.error("Error deleting pet stats:", error);
    }
}

document.addEventListener("DOMContentLoaded", () => {
  const checkbox = document.getElementById("shop-not-owned-toggle");
  const switchText = document.querySelector(".switch-text-shop");

  if (checkbox && switchText) {
    checkbox.addEventListener("change", () => {
      switchText.textContent = checkbox.checked ? "" : "NETURIU";
    });
  }

  const checkbox2 = document.getElementById("object-usage-toggle");
  const switchText2 = document.querySelector(".switch-text-object");

  if (checkbox2 && switchText2) {
    checkbox2.addEventListener("change", () => {
      switchText2.textContent = checkbox2.checked ? "" : "NENAUD.";
    });
}
});


function renderUsersPetAssets() {
    renderPetListForPetSection();

    const departmentBtns = document.querySelectorAll('#pet-asset-container .department-btn');
    const petSkinsContainer = document.getElementById('pet-skins');
    const petSuppliesContainer = document.getElementById('pet-supplies');

    departmentBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            departmentBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            const departmentLabel = btn.querySelector('.department-label').textContent;
            
            // Ensure pet selection before rendering content
            ensurePetSelection();
            
            // Get the currently selected pet (now guaranteed to exist)
            let currentSelectedPet = selectedPet;
            const dropdown = document.getElementById('pet-category-select');
            
            if (departmentLabel === 'Ivaizda') {
                petSkinsContainer.style.display = 'grid';
                petSuppliesContainer.style.display = 'none';
                renderPetSkins(currentSelectedPet);
                dropdown.style.display = "none";
            } else if (departmentLabel === 'Maistas' || departmentLabel === 'Reikmenys') {
                petSkinsContainer.style.display = 'none';
                petSuppliesContainer.style.display = 'grid';
                dropdown.style.display = "flex";
                renderPetAssetsDropdown(currentSelectedPet);
            }
        });
    });

    // Ensure pet selection and render initial content
    ensurePetSelection();
    renderPetAssetsDropdown(selectedPet);
    document.getElementById('pet-category-select').style.display = "flex";
}

// Generate segments dynamically
function createSegments(barId, maxValue = 12) {
    const bar = document.getElementById(barId);
    if (!bar) return;
    const segmentsContainer = bar.querySelector('.segments');
    segmentsContainer.innerHTML = ''; // clear existing
    for (let i = 0; i < maxValue; i++) {
        const span = document.createElement('span');
        span.className = 'segment';
        segmentsContainer.appendChild(span);
    }
}

// Initialize bars for all stats
['food-bar', 'water-bar', 'love-bar'].forEach(barId => createSegments(barId));


const allPets = document.querySelectorAll("#petContainer .pet");
let activePetId = allPets[0]; // default to first pet

function createPetButtons() {
    const container = document.getElementById('pet-buttons');
    const checkboxHolder = document.getElementById('pet-on-walk-checkbox-holder');

    container.innerHTML = ''; // clear existing buttons
    checkboxHolder.innerHTML = ''; // clear existing checkboxes

    const allPets = document.querySelectorAll("#petContainer .pet");

    allPets.forEach((pet, index) => {
        // --- Create pet button ---
        const btn = document.createElement('button');
        btn.innerHTML = `
                        <div class="pet-stats-selection-button-text">
                            ${userPetAssets["pets"][pet.id].name}
                        <div id="pet-stats-selection-button-indicator-${pet.id}" class="pet-stats-selection-button-indicator"></div>
                        </div>
                        `;

        btn.className = index === 0 ? 'active' : ''; // first button active by default
        btn.classList.add("pet-stats-selection-button");

        // --- Create associated checkbox div ---
        const walkDiv = document.createElement('div');
        walkDiv.className = 'pet-on-walk-holder';
        walkDiv.style.display = 'none'; // hidden by default

        const label = document.createElement('label');
        label.className = 'switch'; // for styling

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `pet-on-walk-toggle-${pet.id}`;
        checkbox.className = "pet-on-walk-toggle";
        const skins = userPetAssets.pets[pet.id].skins
        const equippedSkin = Object.values(skins).find(skin => skin.equiped);
        equippedSkinName = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];
        checkbox.checked = petOnWalk === equippedSkinName;

        const span = document.createElement('span');
        span.className = 'switch-slider';

        // Add text inside the switch
        const switchText = document.createElement('span');
        switchText.className = 'switch-text switch-text-pet';
        switchText.textContent = checkbox.checked ? '' : 'KARTU';
        span.appendChild(switchText);

        label.appendChild(checkbox);
        label.appendChild(span);
        walkDiv.appendChild(label);
        checkboxHolder.appendChild(walkDiv);

        // --- Button click logic ---
        btn.onclick = () => {
            // Remove active class from all buttons
            container.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active'); // mark clicked button active

            // Show only the checkbox associated with this pet
            checkboxHolder.querySelectorAll('.pet-on-walk-holder').forEach(div => div.style.display = 'none');
            walkDiv.style.display = 'flex';

            displayPetStats(pet.id);
        };

        // --- Checkbox logic ---
        checkbox.onchange = () => {
            if (checkbox.checked) {
                // untick all other checkboxes
                checkboxHolder.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    if (cb !== checkbox) cb.checked = false;
                });
                const skins = userPetAssets.pets[pet.id].skins
                const equippedSkin = Object.values(skins).find(skin => skin.equiped);
                petOnWalk = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];
                console.log(petOnWalk)
                sendPetOnWalkUpdateToServer();
                switchText.textContent = '';
                // update other switches
                checkboxHolder.querySelectorAll('.switch-text-pet').forEach(st => {
                    if (st !== switchText) st.textContent = 'KARTU';
                });
            } else {
                petOnWalk = "";
                sendPetOnWalkUpdateToServer();
                switchText.textContent = 'KARTU';
            }
        };

        container.appendChild(btn);

        // Show the checkbox of the initially active button
        if (index === 0) {
            walkDiv.style.display = 'flex';
        }
    });
}

async function sendPetOnWalkUpdateToServer() {
    try {
        const response = await apiFetch(apiBase + 'petGame/petOnWalk', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': userData.token
            },
            body: JSON.stringify({ studentId: userData.userId, petOnWalk: petOnWalk })
        });

        if (!response) {
            return;
        }

        if (response.ok) {
            document.querySelector('.some-pet-element')?.classList.add('tick-svg');
            userData.petOnWalk = petOnWalk
            localStorage.setItem('userData', JSON.stringify(userData));
            return true;
        } else {
            console.error(`Failed to update pet stats: ${response.status}`);
            messageToTheUser("Nepavyko pasiimti augintinio kartu  uduotis. Bandyk vl vliau.")
            return false;
        }
    } catch (error) {
        console.error('Error sending pet stats update:', error);
        messageToTheUser("Nepavyko pasiimti augintinio kartu  uduotis. Bandyk vl vliau.")
        return false;
    }
}

function updatePetOnWalkStatsInLocalStorage (petId, statList) {
    const skins = userPetAssets.pets[petId].skins
    const equippedSkin = Object.values(skins).find(skin => skin.equiped);
    const equippedSkinName = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];

    if (petOnWalk === equippedSkinName) {
        userData.petStats = statList
        localStorage.setItem('userData', JSON.stringify(userData));
    }
}


// Display stats for the selected pet
function displayPetStats(activePetId) {
    const currentPet = document.getElementById(activePetId);
    const currentTime = Math.floor(Date.now() / 1000 / 60);
    const timeElapsed = currentTime - currentPet._stats.date;
    const statDecrease = Math.floor(timeElapsed * PET_STATS_EXPIRATION);

    const petSpecies = activePetId.split("-")[0];
    const bonusStats = bonusFromDailySupplyItems();

    currentPet._stats.food = Math.max(bonusStats[petSpecies]?.food ?? 0, currentPet._stats.food - statDecrease);
    currentPet._stats.foodNew = Math.max(bonusStats[petSpecies]?.food ?? 0, currentPet._stats.foodNew - statDecrease);
    currentPet._stats.water = Math.max(bonusStats[petSpecies]?.water ?? 0, currentPet._stats.water - statDecrease);
    currentPet._stats.waterNew = Math.max(bonusStats[petSpecies]?.water ?? 0, currentPet._stats.waterNew - statDecrease);
    currentPet._stats.love = Math.max(bonusStats[petSpecies]?.love ?? 0, currentPet._stats.love - statDecrease);
    currentPet._stats.loveNew = Math.max(bonusStats[petSpecies]?.love ?? 0, currentPet._stats.loveNew - statDecrease);
    currentPet._stats.date = currentTime;

    updatePetOnWalkStatsInLocalStorage(activePetId, [currentPet._stats.foodNew, currentPet._stats.waterNew, currentPet._stats.loveNew, currentPet._stats.date])

    setPetStatsBar("food-bar", currentPet._stats.food+1);
    setPetStatsBar("water-bar", currentPet._stats.water+1);
    setPetStatsBar("love-bar", currentPet._stats.love+1);

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        calculateHappinesIndexForPet(pet.id)
    });

    function setPetStatsBar(barId, value) {
        const bar = document.getElementById(barId);
        if (!bar) return;
        const segments = bar.getElementsByClassName('segment');

        let color;
        if (value <= 2) color = '#e74c3c';
        else if (value <= 5) color = '#f1c40f';
        else color = '#2ecc71';

        for (let i = 0; i < segments.length; i++) {
            segments[i].style.backgroundColor = i < value ? color : 'rgba(0,0,0,0)';
        }
    }
}

function increasePetStatsInDatabase(petId, stat, amount) {
    const currentPet = document.getElementById(petId)

    const currentTime = Math.floor(Date.now() / 1000 / 60);
    const timeElapsed = currentTime - currentPet._stats.date;
    const statDecrease = Math.floor(timeElapsed * PET_STATS_EXPIRATION);

    const petSpecies = petId.split("-")[0];
    const bonusStats = bonusFromDailySupplyItems();

    currentPet._stats.food = Math.max(bonusStats[petSpecies]?.food ?? 0, currentPet._stats.food - statDecrease);
    currentPet._stats.foodNew = Math.max(bonusStats[petSpecies]?.food ?? 0, currentPet._stats.foodNew - statDecrease);
    currentPet._stats.water = Math.max(bonusStats[petSpecies]?.water ?? 0, currentPet._stats.water - statDecrease);
    currentPet._stats.waterNew = Math.max(bonusStats[petSpecies]?.water ?? 0, currentPet._stats.waterNew - statDecrease);
    currentPet._stats.love = Math.max(bonusStats[petSpecies]?.love ?? 0, currentPet._stats.love - statDecrease);
    currentPet._stats.loveNew = Math.max(bonusStats[petSpecies]?.love ?? 0, currentPet._stats.loveNew - statDecrease);

    let newAmount = currentPet._stats[stat] + amount;
    if (newAmount > 10) newAmount = 10;
    currentPet._stats[`${stat}New`] = newAmount
    currentPet._stats.date = Math.floor(Date.now() / 1000 / 60);
    sendPetStatsUpdateToDatabase(petId);
}



function increasePetStatsInDisplay(petId, stat) {
    const pet = document.getElementById(petId)

    pet._stats[`${stat}`] = pet._stats[`${stat}New`]
    
    const statsPetButtons = document.querySelectorAll("button.pet-stats-selection-button");
    const targetStatsButton = Array.from(statsPetButtons).find(btn => btn.textContent.trim() === userPetAssets["pets"][petId].name);

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        calculateHappinesIndexForPet(pet.id)
    });
    
    if (targetStatsButton) {
        targetStatsButton.click();
    }
}

function getAppliedBackgroundImageSelector(element) {
    // Check inline style first
    const inlineBg = element.style.backgroundImage;
    if (inlineBg) return "inline style";

    let appliedRule = null;

    const sheets = Array.from(document.styleSheets);
    sheets.forEach(sheet => {
        let rules;
        try {
            rules = sheet.cssRules;
        } catch (e) {
            return; // skip cross-origin sheets
        }
        if (!rules) return;

        Array.from(rules).forEach(rule => {
            if (rule.style && rule.style.backgroundImage) {
                try {
                    if (element.matches(rule.selectorText)) {
                        // Keep the last matching rule in the cascade
                        appliedRule = rule.selectorText;
                    }
                } catch (e) {
                    // invalid selector, skip
                }
            }
        });
    });

    return appliedRule;
}

function preloadBackgroundImageForSelectors(class1, class2) {
    const combinedSelector = `${class1}${class2}`; // ensure dot notation
    const sheets = Array.from(document.styleSheets);
    let bgUrl = null;

    sheets.forEach(sheet => {
        let rules;
        try {
            rules = sheet.cssRules;
        } catch (e) {
            return; // skip cross-origin stylesheets
        }
        if (!rules) return;

        // Determine base URL for resolving relative paths
        let baseUrl;
        if (sheet.href) {
            baseUrl = new URL(sheet.href, window.location.href).href.replace(/\/[^/]*$/, '/'); // folder of CSS
        } else {
            baseUrl = window.location.href.replace(/\/[^/]*$/, '/'); // inline style: use page URL folder
        }

        Array.from(rules).forEach(rule => {
            if (rule.selectorText === combinedSelector && rule.style && rule.style.backgroundImage) {
                const match = rule.style.backgroundImage.match(/url\(["']?(.*?)["']?\)/);
                if (match) {
                    try {
                        // Resolve relative URL to absolute
                        bgUrl = new URL(match[1], baseUrl).href;
                    } catch (err) {
                        console.warn(`Failed to resolve URL for ${combinedSelector}: ${match[1]}`);
                    }
                }
            }
        });
    });

    if (bgUrl) {
        const img = new Image();
        img.onload = () => console.log(`Preloaded successfully: ${bgUrl}`);
        img.onerror = () => console.warn(`Failed to preload image: ${bgUrl}`);
        img.src = bgUrl; // preload image
    } else {
        console.warn(`No background-image found for selector ${combinedSelector}`);
    }
}


function displayWaterBowlFillingOptions(obj) {
    if (obj.className.includes("full")) {
        messageToTheUser("Dubenelis jau pilnas!")
        return
    }

    const objectsClass = getAppliedBackgroundImageSelector(obj)
    preloadBackgroundImageForSelectors(objectsClass, ".full")

    const speciesSuitableForBowl = [...new Set(
        Array.from(obj.classList)
            .filter(cls => cls.includes("water-bowl") && cls !== "water-bowl" && !cls.includes("furniture-preview"))
            .map(cls => cls.split("-")[0])
    )]
    .map(species => speciesTranslationDict[species] || species)  // translate each if available
    .join(", ");

    const waterBowlOptionsElement = document.createElement('div');
    waterBowlOptionsElement.className = 'water-bowl-options-container';

    const btn = document.createElement('button');
        btn.className = 'fill-water-bowl-btn';
        btn.textContent = 'Pripildyti';
        btn.addEventListener('click', () => {
            closeObjectPopup();

            if (!taxesData.waterTax.paid) {
                messageToTheUser("Nra vandens. Sumokk vandens mokest!","error");
                return
            }
            
            obj.classList.add("full")
            initUserTriggeredAction("water", obj)
        });

        waterBowlOptionsElement.appendChild(btn);

    openObjectPopup(waterBowlOptionsElement, 'Vandens dubenlis', `Tinka: ${speciesSuitableForBowl}`)
}

function displayBathFillingOption(obj) {
    if (obj._full && obj._full === true) {
        messageToTheUser("Vonia jau pripilta!")
        return
    }

    const speciesSuitableForBath = [...new Set(
        Array.from(obj.classList)
            .filter(cls => cls.includes("-bath") && !cls.includes("furniture-preview"))
            .map(cls => cls.split("-")[0])
    )]
    .map(species => speciesTranslationDict[species] || species)
    .join(", ");

    const bathOptionsElement = document.createElement('div');
    bathOptionsElement.className = 'bath-options-container';

    const btn = document.createElement('button');
        btn.className = 'fill-bath-btn';
        btn.textContent = 'Pripildyti';
        btn.addEventListener('click', () => {
            closeObjectPopup();

            if (!taxesData.waterTax.paid) {
                messageToTheUser("Nra vandens. Sumokk vandens mokest!","error");
                return
            }
            
            obj._full = true;

            const bathType = Array.from(obj.classList).find(cls => cls.startsWith("bath-"))
            setObjectAnimation(obj, `${bathType}-filled`)
            initUserTriggeredAction("bath", obj)
        });

        bathOptionsElement.appendChild(btn);

    openObjectPopup(bathOptionsElement, 'Vonia', `Tinka: ${speciesSuitableForBath}`)
}


function displayFoodOptions(obj) {
    if (obj.className.includes("full")) {
        messageToTheUser("Dubenelis jau pilnas!");
        return;
    }

    const objectsClass = getAppliedBackgroundImageSelector(obj)
    preloadBackgroundImageForSelectors(objectsClass, ".full")

    if (selectedConsumable.length !== 0 && gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex]["provides"] &&
        gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex]["provides"][0] === "food"
    ) {
        const selectedFoodInfo = gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex];
        const targetClasses = selectedFoodInfo.provides[1];

        if (!targetClasses.some(cls => obj.className.includes(cls))) {
            messageToTheUser("Dubenlis netinkamas iam maistui.");
            return;
        }

        clearPlacementHighlights();
        clearSpecificPlacementHighlights();

        obj.classList.add("full");
        obj._foodContent = [selectedFoodInfo["provides"], selectedConsumable[1]];

        initUserTriggeredAction("food", obj);

        const updatedQuantity = userPetAssets["supplies"][selectedConsumable[0]]["quantity"] - selectedConsumable[1];
        if (updatedQuantity <= 0) {
            delete userPetAssets.supplies[selectedConsumable[0]];
        } else {
            userPetAssets.supplies[selectedConsumable[0]]["quantity"] = updatedQuantity;
        }
        selectedConsumable = [];
        clearPlacementHighlights();
        clearSpecificPlacementHighlights();
        sendPetAssetsUpdateToDatabase();
    } else {
        selectedConsumable = [];
        const matchedSupplies = [];

        Object.entries(userPetAssets.supplies).forEach(([supplyKey, supply]) => {
            const item = gameAssetIndex[supply.assetIndex];
            if (item && item["provides"] && item["provides"][0] === "food") {
                const targetClasses = item.provides[1];
                targetClasses.forEach(cls => {
                    for (const c of obj.classList) {
                        if (c.includes(cls)) {
                            matchedSupplies.push({ key: supplyKey, supply, item });
                            break;
                        }
                    }
                });
            }
        });

        // Create container element
        const foodOptionsElement = document.createElement('div');
        foodOptionsElement.className = 'food-options-container';

        const speciesSuitableForBowl = [...new Set(
            Array.from(obj.classList)
                .filter(cls => cls.includes("food-bowl") && cls !== "food-bowl")
                .map(cls => cls.split("-")[0])
        )]
            .map(species => speciesTranslationDict[species] || species)
            .join(", ");

        if (matchedSupplies.length === 0) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const noItemMessage = document.createElement('div');
            noItemMessage.className = 'no-item-message';
            noItemMessage.innerHTML = "Maisto tinkamo dti   dubenl nra. Gali nupirkti parduotuvje.";

            foodOptionsElement.append(noItemMessage);
        }

        matchedSupplies.forEach(({ key, supply, item }) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']}`;

            const previewHolder = document.createElement('div');
            previewHolder.className = 'food-item-preview-holder';

            previewHolder.appendChild(previewDiv)

            const nameH3 = document.createElement('h3');
            nameH3.className = 'food-item-name';
            nameH3.textContent = item.title;

            const description = document.createElement('div');
            description.className = 'food-item-description';
            description.innerHTML = (item.description || "") + generateConsumableItemDescription(item);

            const quantitySpan = document.createElement('span');
            quantitySpan.className = 'item-quantity';
            quantitySpan.textContent = ` (x${supply.quantity})`;

            const nameAndDescriptionHolder = document.createElement('div');
            nameAndDescriptionHolder.className = 'food-item-name-description-holder';

            nameH3.appendChild(quantitySpan);
            nameAndDescriptionHolder.appendChild(nameH3);
            nameAndDescriptionHolder.appendChild(description);

            const previewAndTextHolder = document.createElement('div');
            previewAndTextHolder.className = 'food-item-preview-text-holder';
            previewAndTextHolder.appendChild(previewHolder);
            previewAndTextHolder.appendChild(nameAndDescriptionHolder);

            // Quantity input if stackable
            let quantityInput = null;
            let quantityInputHolder = null;

            if (supply.quantity) {
                quantityInputHolder = document.createElement('div');
                quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';

                quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = 1;
                quantityInput.max = supply.quantity;
                quantityInput.step = 1;
                quantityInput.value = 1;
                quantityInput.className = 'food-quantity-input';
                quantityInput.readOnly = true;
                quantityInput.id = `food-qty-${supply.assetIndex}`;

                const minusBtn = document.createElement('button');
                minusBtn.className = 'control-btn';
                minusBtn.textContent = '';
                minusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, false, () => updateQuantity(quantityInput));
                minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, false, () => updateQuantity(quantityInput)); };
                minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                const plusBtn = document.createElement('button');
                plusBtn.className = 'control-btn';
                plusBtn.textContent = '+';
                plusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, true, () => updateQuantity(quantityInput));
                plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, true, () => updateQuantity(quantityInput)); };
                plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                quantityInputHolder.appendChild(minusBtn);
                quantityInputHolder.appendChild(quantityInput);
                quantityInputHolder.appendChild(plusBtn);

                function updateQuantity(input) {
                    if (!input) input = quantityInput;
                    let value = parseInt(input.value, 10);
                    const min = parseInt(input.min, 10);
                    const max = parseInt(input.max, 10);
                    if (isNaN(value) || value < min) value = min;
                    if (value > max) value = max;
                    input.value = value;
                }

                const quantAndBtnHolder = document.createElement('div');
                quantAndBtnHolder.className = 'food-item-quant-btn-holder';
                quantAndBtnHolder.appendChild(quantityInputHolder);

                // Keep value within min/max if manually edited
                quantityInput.addEventListener('input', () => {
                    let value = parseInt(quantityInput.value, 10);
                    const max = parseInt(quantityInput.max, 10);
                    const min = parseInt(quantityInput.min, 10);
                    if (isNaN(value) || value < min) value = min;
                    if (value > max) value = max;
                    quantityInput.value = value;
                    updateQuantity(quantityInput);
                });
                quantityInput.addEventListener('change', () => updateQuantity(quantityInput));

                itemDiv.appendChild(previewAndTextHolder);
                itemDiv.appendChild(quantAndBtnHolder);
            } else {
                const quantAndBtnHolder = document.createElement('div');
                quantAndBtnHolder.className = 'food-item-quant-btn-holder';
                itemDiv.appendChild(previewAndTextHolder);
                itemDiv.appendChild(quantAndBtnHolder);
            }

            // Use button
            const btn = document.createElement('button');
            btn.className = 'food-use-btn';
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                const useQuantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                if (!item["provides"]) return
                if (supply.quantity >= useQuantity) {
                    supply.quantity -= useQuantity;
                    if (supply.quantity <= 0) {
                        delete userPetAssets.supplies[key];
                    } else {
                        userPetAssets.supplies[key]["quantity"] = supply.quantity;
                    }
                    sendPetAssetsUpdateToDatabase();
                    closeObjectPopup();
                    obj.classList.add("full");
                    obj._foodContent = [item["provides"], useQuantity];
                    initUserTriggeredAction("food", obj);
                }
            });

            itemDiv.querySelector('.food-item-quant-btn-holder')?.appendChild(btn);
            foodOptionsElement.appendChild(itemDiv);
        });

        openObjectPopup(foodOptionsElement, "Maisto dubenlis", `Tinka: ${speciesSuitableForBowl}`);
    }
}


function displayPetTreatOptions(obj) {
    if (selectedConsumable.length !== 0) {
        const selectedFoodInfo = gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex];

        if (selectedFoodInfo["provides"] && selectedFoodInfo["provides"][0] === "love") {
            const targetClasses = selectedFoodInfo.provides[1];

            if (!targetClasses.some(cls => obj.className.includes(cls))) {
                messageToTheUser("Skanukas netinka iam augintiniui.");
                return;
            }

            initUserTriggeredAction("love", [obj, selectedFoodInfo["provides"][2], [selectedConsumable[1]]]);

            const updatedQuantity = userPetAssets["supplies"][selectedConsumable[0]]["quantity"] - selectedConsumable[1];
            if (updatedQuantity <= 0) {
                delete userPetAssets.supplies[selectedConsumable[0]];
            } else {
                userPetAssets.supplies[selectedConsumable[0]]["quantity"] = updatedQuantity;
            }
            selectedConsumable = [];
            sendPetAssetsUpdateToDatabase();
        }
    } else {
        const matchedSupplies = [];

        Object.entries(userPetAssets.supplies).forEach(([supplyKey, supply]) => {
            const item = gameAssetIndex[supply.assetIndex];
            if (item && item["provides"] && item["provides"][0] === "love") {
                const targetClasses = item.provides[1];
                targetClasses.forEach(cls => {
                    for (const c of obj.classList) {
                        if (c.includes(cls)) {
                            matchedSupplies.push({ key: supplyKey, supply, item });
                            break;
                        }
                    }
                });
            }
        });

        const treatsOptionsElement = document.createElement('div');
        treatsOptionsElement.className = 'treats-options-container';

        if (matchedSupplies.length === 0) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const noItemMessage = document.createElement('div');
            noItemMessage.className = 'no-item-message';
            noItemMessage.innerHTML = "Skaniuk tinkam iam augintiniui nra. Gali nupirkti parduotuvje.";

            treatsOptionsElement.append(noItemMessage);
        }

        matchedSupplies.forEach(({ key, supply, item }) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']}`;

            const previewHolder = document.createElement('div');
            previewHolder.className = 'food-item-preview-holder';

            previewHolder.appendChild(previewDiv);

            const nameH3 = document.createElement('h3');
            nameH3.className = 'food-item-name';
            nameH3.textContent = item.title;

            const description = document.createElement('div');
            description.className = 'food-item-description';
            description.innerHTML = (item.description || "") + generateConsumableItemDescription(item);

            const quantitySpan = document.createElement('span');
            quantitySpan.className = 'item-quantity';
            quantitySpan.textContent = ` (x${supply.quantity})`;

            const nameAndDescriptionHolder = document.createElement('div');
            nameAndDescriptionHolder.className = 'food-item-name-description-holder';

            nameH3.appendChild(quantitySpan);
            nameAndDescriptionHolder.appendChild(nameH3);
            nameAndDescriptionHolder.appendChild(description);

            const previewAndTextHolder = document.createElement('div');
            previewAndTextHolder.className = 'food-item-preview-text-holder';
            previewAndTextHolder.appendChild(previewHolder);
            previewAndTextHolder.appendChild(nameAndDescriptionHolder);

            // Quantity input with buttons
            let quantityInput = null;
            let quantityInputHolder = null;

            if (supply.quantity) {
                quantityInputHolder = document.createElement('div');
                quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';

                quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = 1;
                quantityInput.max = supply.quantity;
                quantityInput.step = 1;
                quantityInput.value = 1;
                quantityInput.className = 'food-quantity-input';
                quantityInput.readOnly = true;
                quantityInput.id = `treat-qty-${supply.assetIndex}`;

                const minusBtn = document.createElement('button');
                minusBtn.className = 'control-btn';
                minusBtn.textContent = '';
                minusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, false, updateQuantity);
                minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, false, updateQuantity); };
                minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                const plusBtn = document.createElement('button');
                plusBtn.className = 'control-btn';
                plusBtn.textContent = '+';
                plusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, true, updateQuantity);
                plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, true, updateQuantity); };
                plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                quantityInputHolder.appendChild(minusBtn);
                quantityInputHolder.appendChild(quantityInput);
                quantityInputHolder.appendChild(plusBtn);

                // Keep value within min/max if manually edited
                quantityInput.addEventListener('input', () => {
                    let value = parseInt(quantityInput.value, 10);
                    const max = parseInt(quantityInput.max, 10);
                    const min = parseInt(quantityInput.min, 10);
                    if (isNaN(value) || value < min) value = min;
                    if (value > max) value = max;
                    quantityInput.value = value;
                    updateQuantity(quantityInput);
                });
                quantityInput.addEventListener('change', () => updateQuantity(quantityInput));

                function updateQuantity(input) {
                    if (!input) input = quantityInput;
                    let value = parseInt(input.value, 10);
                    const min = parseInt(input.min, 10);
                    const max = parseInt(input.max, 10);
                    if (isNaN(value) || value < min) value = min;
                    if (value > max) value = max;
                    input.value = value;
                }
            }

            const quantAndBtnHolder = document.createElement('div');
            quantAndBtnHolder.className = 'food-item-quant-btn-holder';
            if (quantityInputHolder) quantAndBtnHolder.appendChild(quantityInputHolder);

            // Use button
            const btn = document.createElement('button');
            btn.className = 'treat-use-btn';
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                const useQuantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                if (!item["provides"]) return
                if (supply.quantity >= useQuantity) {
                    supply.quantity -= useQuantity;
                    if (supply.quantity <= 0) {
                        delete userPetAssets.supplies[key];
                    } else {
                        userPetAssets.supplies[key]["quantity"] = supply.quantity;
                    }
                    sendPetAssetsUpdateToDatabase();
                    closeObjectPopup();

                    initUserTriggeredAction("love", [obj, item["provides"][2], useQuantity]);
                }
            });

            quantAndBtnHolder.appendChild(btn);

            itemDiv.appendChild(previewAndTextHolder);
            itemDiv.appendChild(quantAndBtnHolder);

            treatsOptionsElement.appendChild(itemDiv);
        });

        openObjectPopup(
            treatsOptionsElement,
            `<div id="pet-container-${obj.id}">
                <span id="pet-name-${obj.id}">${userPetAssets["pets"][obj.id].name}</span>
                <button class="edit-name-button" onclick="editPetName('${obj.id}', this)">
                    <span class="edit-icon"><img src="../images/icons/icon-edit.svg"></span>
                </button>
            </div>`,
            ''
        );
    }
}


function generateConsumableItemDescription(item) {
    if (!item || !item.provides || item.provides.length !== 3) return '';

    const providesType = item.provides[0];
    const providesQuantity = item.provides[2];

    let container = `<div class="item-description-icons">`;

    container += `
        <svg class="item-description-icon">
            <use href="#icon-${providesType}"></use>
        </svg> x ${providesQuantity}
    `;

    if (!item.petAsset) {
        container += 'per dien'
    }

    container += `</div>`;
    return container;
}

document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        const allPets = document.querySelectorAll("#petContainer .pet");
        allPets.forEach(pet => {
            managePetActions(pet);
        });
    }
});

let autonomousPetActionCounter = 1;
let startingActions = {
    "cat-1": [startSleeping],
    "cat-2": [startSleeping]
};


async function startSleeping(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-sleeps`);

    const timeMin = 1000;
    const timeMax = 3000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    
    setObjectAnimation(pet, `${pet.id}-lays-idle`);

    const timeMin2 = 1000;
    const timeMax2 = 3000;
    const randomDuration2 = Math.floor(Math.random() * (timeMax2 - timeMin2 + 1)) + timeMin2;
    await cancellableWait(randomDuration2, signal);
    
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

function managePetActions(pet) {

    if (pet._busy) {
        return
    }

    const petRoomContainer = document.getElementById("pet-room-container");
    if (!petRoomContainer || 
        petRoomContainer.style.display === "none" || 
        !petRoomContainer.offsetParent || 
        document.hidden) {
        
        // Abort any ongoing action for this pet
        if (petControllers[pet.id]) {
            petControllers[pet.id].abort();
            setObjectAnimation(pet, `${pet.id}-stands-idle`);
            delete petControllers[pet.id]; // Clean up the controller
        }
        return; // Exit the function without starting new actions
    }

    // cancel any ongoing action for this pet
    if (petControllers[pet.id]) {
        petControllers[pet.id].abort();
        setObjectAnimation(pet, `${pet.id}-stands-idle`);
    }

    // create a new controller for this action chain
    const controller = new AbortController();
    petControllers[pet.id] = controller;

    if (startingActions[pet.id]?.length > 0) {
        const fn = startingActions[pet.id].shift(); // gets actual function
        fn(pet, controller.signal).catch(err => {
            if (err.name !== "AbortError") console.error(err);
        });
        return
    }

    if (pendingPetActions[pet.id] && pendingPetActions[pet.id].length !== 0) {
        const [fn, args] = pendingPetActions[pet.id][0];
        fn(...args, controller.signal).catch(err => {
            if (err.name !== "AbortError") console.error(err);
        });
    } else {

        let situationalPetActions = [];

        // Push arrays
        if (pet._stats.food <= 3) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["hungry"]);
        }

        if (pet._stats.water <= 3) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["thirsty"]);
        }

        if (pet._stats.love <= 3) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["sad"]);
        }

        if (!calculateHappinesIndexForPet(pet.id)) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["angry"]);
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["sad"]);
        }

        // Flatten the array of arrays into a single list of strings
        situationalPetActions = situationalPetActions.flat();

        let randomSituationalAction = null;
        if (situationalPetActions.length > 0) {
            // Now this will be a single string
            randomSituationalAction = situationalPetActions[Math.floor(Math.random() * situationalPetActions.length)];
        }

        if (autonomousPetActionCounter % 2 === 0) {
            // Even counter  pick random action from the list (if available)
            let randomNormalAction = petAutonomousActions[pet.id]?.length
                ? petAutonomousActions[pet.id][Math.floor(Math.random() * petAutonomousActions[pet.id].length)]
                : null;
            
            let randomAction; // Fixed: declare randomAction variable
            if (randomSituationalAction) {
                randomAction = [randomNormalAction, randomSituationalAction][Math.floor(Math.random() * 2)];
            } else {
                randomAction = randomNormalAction;
            }

            if (randomAction && typeof window[randomAction] === "function") {
                window[randomAction](pet, controller.signal).catch(err => {
                    if (err.name !== "AbortError") console.error(err);
                });
            }

            autonomousPetActionCounter++;
        } else {
            petWalksAround(pet, controller.signal);
            autonomousPetActionCounter++;
        }
    }
}

async function petDances(pet, signal) {
  if (signal.aborted) {
    cancelMovement(pet.id);
    throw new DOMException("Aborted", "AbortError");
  }

  cancelMovement(pet.id);
  setObjectAnimation(pet, `${pet.id}-dances`);

  await cancellableWait(4000, signal);

  if (signal.aborted) {
    cancelMovement(pet.id);
    throw new DOMException("Aborted", "AbortError");
  }

  pendingPetActions[pet.id].shift();
  managePetActions(pet);
}


async function petHappy(pet, quantity, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if (!quantity) return;

    cancelMovement(pet.id)

    setObjectAnimation(pet, `${pet.id}-happy`);

    await cancellableWait(2000, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    increasePetStatsInDisplay(pet.id, "love")

    pendingPetActions[pet.id].shift();

    managePetActions(pet);
}

async function petEats(pet, object, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if (!object) return;

    const provides = object._foodContent;
    const providesFor = provides[0][1];
    const providesQuantity = provides[0][2] * provides[1];

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id].assetIndex]?.["interactive-spot"];

    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [...objectCoords];

    if (Array.isArray(objectInteractivePart) && objectInteractivePart.length >= 2) {
        objectInteractiveCoords[0] += objectInteractivePart[0];
        objectInteractiveCoords[1] -= objectInteractivePart[1];
    } else {
        objectInteractivePart = [0, 0];
    }

    console.log()

    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteractReverse = canPlaceObjectAt(objectInteractiveBottomRightCoords[0], objectInteractiveBottomRightCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if ((ableToPostitionToInteract && !ableToPostitionToInteractReverse) ||
        (ableToPostitionToInteract && petCoords[0] - objectCoords[0] >= 0)) {

        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "left");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "food");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else if (ableToPostitionToInteractReverse) {
        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveBottomRightCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "right");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "food");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else {
        messageToTheUser(`Augintiniai negali prieiti prie maisto. Perstatyk baldus!`);
        pendingPetActions[pet.id].shift();
        managePetActions(pet);
    }
}

async function petDrinks(pet, object, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if (!object) return;

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart =
    gameAssetIndex[userObjectAssets[object.id].assetIndex]?.["interactive-spot"];

    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [...objectCoords];

    if (Array.isArray(objectInteractivePart) && objectInteractivePart.length >= 2) {
    objectInteractiveCoords[0] += objectInteractivePart[0];
    objectInteractiveCoords[1] -= objectInteractivePart[1];
    } else {
        objectInteractivePart = [0, 0];
    }

    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteractReverse = canPlaceObjectAt(objectInteractiveBottomRightCoords[0], objectInteractiveBottomRightCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if ((ableToPostitionToInteract && !ableToPostitionToInteractReverse) ||
        (ableToPostitionToInteract && petCoords[0] - objectCoords[0] >= 0)) {

        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "left");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "water");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else if (ableToPostitionToInteractReverse) {
        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveBottomRightCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "right");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "water");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else {
        messageToTheUser(`Augintiniai negali prieiti prie maisto. Perstatyk baldus!`);
        pendingPetActions[pet.id].shift();
        managePetActions(pet);
    }
}


async function petBathes(pet, object, signal) {
    if (signal.aborted) {
        cancelMovement(pet.id)
        throw new DOMException("Aborted", "AbortError");
    }

    if (!object) return;

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id].assetIndex]?.["interactive-spot"];

    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [...objectCoords];

    if (Array.isArray(objectInteractivePart) && objectInteractivePart.length >= 2) {
    objectInteractiveCoords[0] += objectInteractivePart[0];
    objectInteractiveCoords[1] -= objectInteractivePart[1];
    } else {
        objectInteractivePart = [0, 0];
    }

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];

    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);
    let ableToPostitionToInteractAlt = canPlaceObjectAt(objectCoords[0], objectCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

    let finalBathInteractionCoords = null;
    if (ableToPostitionToInteract) {
        finalBathInteractionCoords = objectInteractiveCoords
    } else if (ableToPostitionToInteractAlt) {
        finalBathInteractionCoords = objectCoords
    }

    if (finalBathInteractionCoords) {

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        await movePetToTile(pet, getObjectCoordinates(pet.id), finalBathInteractionCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        pet.style.visibility = "hidden";

        const bathType = Array.from(object.classList).find(cls => cls.startsWith("bath-"))

        const skins = userPetAssets.pets[pet.id].skins;

        let equippedSkin = Object.values(skins).find(skin => skin.equiped);
        
        if (!equippedSkin) {
            const firstSkinKey = Object.keys(skins)[0];
            equippedSkin = skins[firstSkinKey];
            equippedSkin.equiped = true;
            sendPetAssetsUpdateToDatabase();
        }

        const equippedSkinSecondClass = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];

        object.classList.add(equippedSkinSecondClass);

        setObjectAnimation(object, `${bathType}-with-pet`)
        pendingPetActions[pet.id].shift();
        pet._busy = true;

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        pet.style.visibility = "visible";

        setObjectAnimation(object, `${bathType}-empty`);
        object._full = false;
        pet._busy = false;

        managePetActions(pet);
    } else {
        messageToTheUser(`Augintinis negali prieiti prie vonios. Perstatyk baldus!`);
        pendingPetActions[pet.id].shift();
        managePetActions(pet);
    }
}

async function petSleeps(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    const objectContainer = document.getElementById("roomObjectsContainer");
    const allObjects = objectContainer.querySelectorAll("*");

    const petContainer = document.getElementById("petContainer");
    let tilesOccupiedByPets = [];

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        const petPos = getObjectCoordinates(pet.id);
        const petWidth = Math.ceil(pet.offsetWidth / unitSize);
        const petHeight = Math.ceil(pet.offsetHeight / unitSize);
        tilesOccupiedByPets.push(...getTilesOccupiedByObject(petPos, petWidth, petHeight));
    });

    const petBeds = Array.from(allObjects).filter(el =>
        Array.from(el.classList).some(cls => cls.includes("cat-bed"))
    );

    const freeBeds = petBeds.filter(bed => {
        if (bed._occupied && bed._occupied !== pet.id) return false;
        const bedPos = getObjectCoordinates(bed.id);
        const bedWidth = Math.ceil(bed.offsetWidth / unitSize);
        const bedHeight = Math.ceil(bed.offsetHeight / unitSize);
        const bedTiles = getTilesOccupiedByObject(bedPos, bedWidth, bedHeight);
        return !bedTiles.some(tile => tilesOccupiedByPets.includes(tile));
    });

    if (freeBeds.length === 0) return;

    const object = freeBeds[Math.floor(Math.random() * freeBeds.length)];
    object._occupied = pet.id;
    addEnterLeaveListener(object, pet);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id].assetIndex]?.["interactive-spot"];

    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [...objectCoords];

    if (Array.isArray(objectInteractivePart) && objectInteractivePart.length >= 2) {
        objectInteractiveCoords[0] += objectInteractivePart[0];
        objectInteractiveCoords[1] -= objectInteractivePart[1];
    }

    await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    setObjectAnimation(pet, `${pet.id}-sleeps`);

    const timeMin = 15000;
    const timeMax = 45000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;

    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    setObjectAnimation(pet, `${pet.id}-sits-idle`);
    managePetActions(pet);
}

async function petWalksAround(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    pet = document.getElementById(pet.id)
    const suitableWalkingTiles = globalWalkabilityMap;
    const validCoords = findValidPlacements(suitableWalkingTiles, pet);

    if (validCoords.length === 0) {
        return;
    }

    // Pick a random coordinate
    const randomIndex = Math.floor(Math.random() * validCoords.length);
    const randomCoord = validCoords[randomIndex];
    const petPos = getObjectCoordinates(pet.id)

    if (!endCoordsValidityChecker(petPos[0], petPos[1], randomCoord[0], randomCoord[1], pet.id, suitableWalkingTiles)) {
        if (petControllers[pet.id]) {
            petControllers[pet.id].abort();
            setObjectAnimation(pet, `${pet.id}-stands-idle`);
            delete petControllers[pet.id]; // Clean up the controller
        }
        return
    }
    await movePetToTile(pet, getObjectCoordinates(pet.id), randomCoord, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    managePetActions(pet);
}

function findValidPlacements(walkabilityMap, pet) {
    const rows = walkabilityMap.length;
    const cols = walkabilityMap[0].length;
    const validCoords = [];
    
    const petWidth = pet.offsetWidth;
    const petHeight = pet.offsetHeight;
    const petWidthInTiles = Math.ceil(petWidth / unitSize);
    const petHeightInTiles = Math.ceil(petHeight / unitSize);
    
    //  Fix: Start row from petHeightInTiles-1 to ensure topRow is never < 0
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col <= cols - petWidthInTiles; col++) {
            
            // Check if bottom row is walkable
            let bottomRowWalkable = true;
            for (let c = col; c < col + petWidthInTiles; c++) {
                if (!walkabilityMap[row][c] || !walkabilityMap[row][c].walkable) {
                    bottomRowWalkable = false;
                    break;
                }
            }
            
            if (bottomRowWalkable) {
                validCoords.push([col, row]);
            }
        }
    }
        
    return validCoords;
}

function endCoordsValidityChecker (startCol, startRow, endCol, endRow, objectId, walkabilityMap) {
    // Get object size in tiles
    const object = document.getElementById(objectId);
    if (!object) {
        console.error("Object not found:", objectId);
        return null;
    }

    const objWidth = object.offsetWidth;
    const objHeight = object.offsetHeight;
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const widthInTiles = Math.ceil(objWidth / unitSize);

    // Add safety check
    if (!walkabilityMap || walkabilityMap.length === 0) {
        console.error("Failed to generate walkability map");
        return false;
    }

    // Validate start & end
    if (!canPlaceObjectAt(startCol, startRow, objWidth, objHeight, walkabilityMap)) {
        return false;
    }
    if (!canPlaceObjectAt(endCol, endRow, objWidth, objHeight, walkabilityMap)) {
        console.log(endCol, endRow)
        return false;
    }
    return true;
}

async function petStandsIdle(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-stands-idle`);

    const timeMin = 3000;
    const timeMax = 5000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function petSitsIdle(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-sits-idle`);

    const timeMin = 3000;
    const timeMax = 5000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function petLaysIdle(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-lays-idle`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function petTalks(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-talks`);

    const timeMin = 2000;
    const timeMax = 4000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1LicksPaw(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-licks-paw`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Cries(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-cries`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Sad(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-sits-idle-thinks`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Angry(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-angry`);

    const timeMin = 2000;
    const timeMax = 4000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Angry2(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-angry-2`);

    const timeMin = 3000;
    const timeMax = 6000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Hungry(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    const petSpecies = pet.classList[0].split('-')[0]

    const roomObjectsContainer = document.getElementById("roomObjectsContainer");

    // Find all elements whose class includes both "food-bowl" and the species substring
    const matchingFoodBowls = Array.from(roomObjectsContainer.querySelectorAll("*")).filter(el => {
        const classStr = el.className; // full class string
        return classStr.includes("food-bowl") && classStr.includes(petSpecies) && !classStr.includes("furniture-preview");
    });

    let object;


    if (matchingFoodBowls.length > 0) {
        const randomIndex = Math.floor(Math.random() * matchingFoodBowls.length);
        object = matchingFoodBowls[randomIndex];
    } else {
        return
    }

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]?.assetIndex]?.["interactive-spot"];

    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [...objectCoords];

    if (Array.isArray(objectInteractivePart) && objectInteractivePart.length >= 2) {
        objectInteractiveCoords[0] += objectInteractivePart[0];
        objectInteractiveCoords[1] -= objectInteractivePart[1];
    } else {
        objectInteractivePart = [0, 0];
    }

    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteractReverse = canPlaceObjectAt(objectInteractiveBottomRightCoords[0], objectInteractiveBottomRightCoords[1], pet.offsetWidth, pet.offsetHeight, globalWalkabilityMap);

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    const animations = ["cat-1-excited", "cat-1-talks"]
    const randomAnimation = animations[Math.floor(Math.random() * animations.length)];

    const timeMin = 10000;
    const timeMax = 20000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;

    if ((ableToPostitionToInteract && !ableToPostitionToInteractReverse) ||
        (ableToPostitionToInteract && petCoords[0] - objectCoords[0] >= 0)) {

        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }


        setObjectAnimation(pet, randomAnimation);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "left");
        }

        await cancellableWait(randomDuration, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        managePetActions(pet);

    } else if (ableToPostitionToInteractReverse) {
        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveBottomRightCoords, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, randomAnimation);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "right");
        }

        await cancellableWait(randomDuration, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        managePetActions(pet);

    }
}


function cancellableWait(ms, signal) {
    return new Promise((resolve, reject) => {
        const id = setTimeout(() => resolve(), ms);
        signal.addEventListener("abort", () => {
            clearTimeout(id);
            reject(new DOMException("Aborted", "AbortError"));
        }, { once: true });
    });
}


const petAutonomousActions = {
    "cat-1": ["petStandsIdle", "petSitsIdle", "petLaysIdle", "petSleeps", "petTalks", "cat1LicksPaw"],
    "cat-2": ["petStandsIdle", "petSitsIdle", "petLaysIdle", "petSleeps", "petTalks", "cat1LicksPaw"]
    }

const petAutonomousActionsSituational = {
    "cat-1": {
        "hungry": ["cat1Hungry"],
        "thirsty": [],
        "sad": ["cat1Cries", "cat1Sad"],
        "angry": ["cat1Angry", "cat1Angry2"]
        },
    "cat-2": {
        "hungry": ["cat1Hungry"],
        "thirsty": [],
        "sad": ["cat1Cries", "cat1Sad"],
        "angry": ["cat1Angry", "cat1Angry2"]
        }
    }


function initUserTriggeredAction(type, object) {
    if (type === "food") {
        const provides = object._foodContent

        const petContainer = document.getElementById("petContainer");
        const petDivs = petContainer.querySelectorAll("div.pet");

        const providesFor = provides[0][1];
        const providesQuantity = provides[0][2] * provides[1];

        const suitablePets = Array.from(petDivs).filter(div =>
        Array.from(div.classList).some(cls =>
            providesFor.some(kw => cls.includes(kw))
        )
        );

        let lowest = [];
        let minFood = Infinity;

        suitablePets.forEach(div => {
            const stats = div._stats;
            if (!stats) return;

            const food = stats.foodNew;
            if (food < minFood) {
                minFood = food;
                lowest = [div];
            } else if (food === minFood) {
                lowest.push(div);
            }
        });

        if (suitablePets.length === 0) {
            return
        }

        let selectedPet = null;
        if (lowest.length > 0) {
            selectedPet = lowest[Math.floor(Math.random() * lowest.length)];
        }

        if (!pendingPetActions[selectedPet.id]) {
            pendingPetActions[selectedPet.id] = [];
        }

        increasePetStatsInDatabase(selectedPet.id, "food", providesQuantity)
        pendingPetActions[selectedPet.id].unshift([petEats, [selectedPet, object]]);
        managePetActions(selectedPet);
    
    } else if (type === "water") {        
        const bowlClasses = Array.from(object.classList);

        const petContainer = document.getElementById("petContainer");
        const petDivs = petContainer.querySelectorAll("div.pet");

        const suitablePets = Array.from(petDivs).filter(div => {
            const petSpecies = div.id.split("-")[0];

            // Check if petSpecies is a substring of any bowl class
            return bowlClasses.some(cls => cls.includes(petSpecies));
        });

        let lowest = [];
        let minWater = Infinity;

        suitablePets.forEach(div => {
            const stats = div._stats;
            if (!stats) return;

            const water = stats.waterNew;
            if (water < minWater) {
                minWater = water;
                lowest = [div];
            } else if (water === minWater) {
                lowest.push(div);
            }
        });

        if (suitablePets.length === 0) {
            return
        }

        let selectedPet = null;
        if (lowest.length > 0) {
        selectedPet = lowest[Math.floor(Math.random() * lowest.length)];
        }

        if (!pendingPetActions[selectedPet.id]) {
            pendingPetActions[selectedPet.id] = [];
        }

        increasePetStatsInDatabase(selectedPet.id, "water", 10)
        pendingPetActions[selectedPet.id].unshift([petDrinks, [selectedPet, object]]);
        managePetActions(selectedPet);
    
    } else if (type === "love") {
        if (!pendingPetActions[object[0].id]) {
            pendingPetActions[object[0].id] = [];
        }
        
        increasePetStatsInDatabase(object[0].id, "love", object[1] * object[2])
        
        pendingPetActions[object[0].id].unshift([petHappy, [object[0], object[1]]]);
        managePetActions(object[0]);
    
    } else if (type === "music") {
        const pets = document.querySelectorAll('.pet');
        pets.forEach((pet) => {
            if (!pendingPetActions[pet.id]) {
                pendingPetActions[pet.id] = [];
            }

            // Queue the dance action for this pet
            pendingPetActions[pet.id].unshift([petDances, [pet]]);

            managePetActions(pet);
        });
    } else if (type === "bath") {
        const bathClasses = Array.from(object.classList);

        const petContainer = document.getElementById("petContainer");
        const petDivs = petContainer.querySelectorAll("div.pet");

        const suitablePets = Array.from(petDivs).filter(div => {
            const petSpecies = div.id.split("-")[0];

            // Check if petSpecies is a substring of any bowl class
            return bathClasses.some(cls => cls.includes(petSpecies));
        });

        if (suitablePets.length === 0) {
            return
        }

        let selectedPet = suitablePets[Math.floor(Math.random() * suitablePets.length)];

        const objectsClass = getAppliedBackgroundImageSelector(object)
        preloadBackgroundImageForSelectors(objectsClass, `.${selectedPet.classList[1]}`)

        if (!pendingPetActions[selectedPet.id]) {
            pendingPetActions[selectedPet.id] = [];
        }

        pendingPetActions[selectedPet.id].unshift([petBathes, [selectedPet, object]]);
        managePetActions(selectedPet);
    }
}

function addEnterLeaveListener(targetObject, petObject) {
    let hasEntered = false;
    
    // Use tile-based collision detection instead of bounding rectangles
    function isOverlapping() {
        const overlappingObjects = detectTileCollision(petObject.id);
        return overlappingObjects.includes(targetObject);
    }
    
    // Check initial state
    const startedInside = isOverlapping();
    if (startedInside) {
        hasEntered = true; // Pet starts inside, wait for it to leave
    }
    
    const intervalId = setInterval(() => {
        const currentlyOverlapping = isOverlapping();
        
        if (!hasEntered) {
            // Waiting for pet to enter
            if (currentlyOverlapping) {
                hasEntered = true;
            }
        } else {
            // Pet has entered (or started inside), waiting for it to leave
            if (!currentlyOverlapping) {
                delete targetObject._occupied;
                cleanup();
                return;
            }
        }
    }, 50); // Check every 50ms for smoother detection
    
    // Timeout after 15 seconds
    const timeoutId = setTimeout(() => {
        cleanup();
    }, 15000);
    
    function cleanup() {
        clearInterval(intervalId);
        clearTimeout(timeoutId);
    }
    
    return cleanup;
}

function taxesNavChoiceIndicator() {
    const navigationTaxesElement = document.querySelector(".taxes-nav-icon");
    if (!navigationTaxesElement) return;

    const currentTime = Math.floor(Date.now() / 1000 / 60);
    const taxPaymentPeriodInMinutes = taxPaymentPeriod * 24 * 60;

    let hasOverdue = false;
    let hasPending = false;

    for (const taxKey in taxesData) {
        const tax = taxesData[taxKey];
        if (!tax) continue;

        const taxDueDateInMinutes = tax.date + taxPaymentPeriodInMinutes;
        const graceEndDateInMinutes =
            tax.date + taxPaymentPeriodInMinutes + (taxGracePeriod * 24 * 60);

        if (tax.paid && currentTime < taxDueDateInMinutes) {
            // still paid  do nothing
        } else if (currentTime >= taxDueDateInMinutes && currentTime < graceEndDateInMinutes) {
            hasPending = true;
        } else {
            hasOverdue = true;
        }
    }

    // Remove any old indicator first
    const oldIndicator = document.querySelector("#tax-indicator");
    if (oldIndicator) oldIndicator.remove();

    // Add new indicator if needed
    if (hasOverdue) {
        const indicatorDiv = document.createElement("div");
        indicatorDiv.id = "tax-indicator";
        indicatorDiv.style.backgroundColor = '#ef4444'
        navigationTaxesElement.appendChild(indicatorDiv);
    } else if (hasPending) {
        const indicatorDiv = document.createElement("div");
        indicatorDiv.id = "tax-indicator";
        indicatorDiv.style.backgroundColor = '#f59e0b'
        navigationTaxesElement.appendChild(indicatorDiv);
        
    }
}

function renderTaxesSection() {
    const taxPaymentPeriodInMinutes = taxPaymentPeriod * 24 * 60;
    const recordsList = document.querySelector(".records-list");
    const currentTime = Math.floor(Date.now() / 1000 / 60);

    recordsList.querySelectorAll(".tax-record").forEach(record => {
        const infoDiv = record.querySelector(".record-info");
        const dateSpan = infoDiv.querySelector(".record-date");
        const statusBadge = record.querySelector(".status-badge");
        let payBtn;
        let taxCostElement;
        let daysRemainingElement;

        // Determine which tax this record corresponds to
        let taxKey = "";
        if (infoDiv.classList.contains("water-tax")) {
            taxKey = "waterTax";
            taxCostElement = record.querySelector("#water-tax-cost");
            payBtn = record.querySelector(".pay-tax-btn.water");
            daysRemainingElement = record.querySelector("#days-remaining-water");
        }
        if (infoDiv.classList.contains("electricity-tax")) {
            taxKey = "electricityTax";
            taxCostElement = record.querySelector("#electricity-tax-cost");
            payBtn = record.querySelector(".pay-tax-btn.electricity");
            daysRemainingElement = record.querySelector("#days-remaining-electricity");
        }

        // Update cost display
        taxCostElement.innerHTML = `<div class="item-price-coin-icon tax-price"><span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span><span class="coin-amount"></span></div> ${taxPrice[taxKey]}`;

        const tax = taxesData[taxKey];
        const taxDueDateInMinutes = tax.date + taxPaymentPeriodInMinutes;
        const graceEndDateInMinutes = tax.date + taxPaymentPeriodInMinutes + (taxGracePeriod * 24 * 60);

        // Convert to readable date format
        const timestamp = taxDueDateInMinutes * 60 * 1000;
        const date = new Date(timestamp);
        const paymentDueDate = date.toISOString().split("T")[0];
        const daysRemaining = Math.ceil((graceEndDateInMinutes - currentTime) / 60 / 24)

        // Determine status
        let status = "";
        if (tax.paid && currentTime < taxDueDateInMinutes) {
            status = "paid";        // still covered
        } else if (currentTime >= taxDueDateInMinutes && currentTime < graceEndDateInMinutes) {
            status = "pending";     // grace period
        } else {
            status = "overdue";     // past grace period
        }

        // Update tax-record class
        record.className = `tax-record ${status}`;
        daysRemainingElement.innerHTML = '';

        // Update status badge and date text
        if (status === "pending") {
            statusBadge.textContent = "Laukiama";
            statusBadge.style.backgroundColor = "#f59e0b";
            dateSpan.textContent = `Mokjimas iki: ${paymentDueDate}`;
            let daysRemainingEnding;
            if (daysRemaining === 1) {
                daysRemainingEnding = 'diena';
            } else {
                daysRemainingEnding = 'dienos';
            }
            daysRemainingElement.innerHTML = `Liko ${daysRemaining} ${daysRemainingEnding}`;
        } else if (status === "paid") {
            statusBadge.textContent = "Sumokta";
            statusBadge.style.backgroundColor = "#10b981";
            dateSpan.textContent = `Kitas mokjimas: ${paymentDueDate}`;
        } else if (status === "overdue") {
            statusBadge.textContent = "Nesumokta";
            statusBadge.style.backgroundColor = "#ef4444";
            dateSpan.textContent = `Mokjimas iki: ${paymentDueDate}`;
        }

        // Update button safely (remove old listeners)
        if (payBtn) {
            const newBtn = payBtn.cloneNode(true); // clone resets event listeners
            payBtn.replaceWith(newBtn);

            if (status === "pending" || status === "overdue") {
                newBtn.textContent = "Mokti";
                newBtn.disabled = false;
                newBtn.addEventListener("click", () => payTax(taxKey));
            } else if (status === "paid") {
                newBtn.classList.add("paid");
                newBtn.textContent = "Mokti";
                newBtn.disabled = true;
            }
        }
    });
}

async function payTax(taxType) {
    const originalMoney = userMoney;
    const totalCost = taxPrice[taxType];
    
    // Check if user has enough money
    if (userMoney < totalCost) {
        messageToTheUser("Nepakanka pinig!", 'error');
        return;
    }

    // Deduct money from server first
    const moneySuccess = await sendMoneyTransactionToDatabase(totalCost, 'subtract');
    
    if (!moneySuccess) {
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        return;
    }
    
    // Update local money only after server confirms
    userMoney -= totalCost;
    updateCoinAmounts(userMoney);

    const currentTime = Math.floor(Date.now() / 1000 / 60);
    
    // Update the specific tax locally
    taxesData[taxType].date = currentTime;
    taxesData[taxType].paid = true;
    
    // Create array with updated tax date for server
    const taxesArray = [taxesData.waterTax.date, taxesData.electricityTax.date];
    
    // Send to server
    try {
        await sendTaxUpdate(taxesArray);
        
        // Re-render the taxes section
        renderTaxesSection();
        taxesNavChoiceIndicator();
    } catch (error) {
        // Tax update failed - try to refund
        await sendMoneyTransactionToDatabase(totalCost, 'add');
        userMoney = originalMoney;
        updateCoinAmounts(userMoney);
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
    }
}

async function sendTaxUpdate(taxesArray) {

    const response = await apiFetch(apiBase + 'petGame/taxes', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': userData.token
        },
        body: JSON.stringify({studentId: userData.userId, taxes: taxesArray})
    });

    if (!response) {
        return;
    }

    if (!response.ok) {
        throw new Error(`Error ${response.status}: ${response.statusText}`);
    }
}

function bonusFromDailySupplyItems() {
    let continiousStatsBonus = {};

    // Loop through all placed user objects
    for (const [objId, objData] of Object.entries(userObjectAssets)) {
        // Skip items that are not placed (no position)
        if (!objData.position || objData.position.length === 0) continue;

        const asset = gameAssetIndex[objData.assetIndex];
        if (!asset || !asset.provides || asset.provides.length !== 3) continue;

        const [stat, pets, value] = asset.provides; // e.g. ["love", ["cat", "dog"], 2]

        pets.forEach(pet => {
            if (!continiousStatsBonus[pet]) {
                continiousStatsBonus[pet] = { food: 0, water: 0, love: 0 };
            }
            continiousStatsBonus[pet][stat] += value;
        });
    }

    return continiousStatsBonus;
}


function editPetName(petId, buttonEl) {
    const petNameSpan = document.getElementById(`pet-name-${petId}`);

    const input = document.createElement('input');
    input.type = 'text';
    input.value = petNameSpan.textContent;
    input.maxLength = 10;
    input.id = `pet-name-input-${petId}`;
    input.className = 'pet-name-field';
    petNameSpan.replaceWith(input);
    input.focus();

    input.addEventListener('input', () => {
        input.style.width = Math.max(input.value.length - 1, 5) + 'ch';
    });

    // Trigger once to set initial width
    input.dispatchEvent(new Event('input'));

    buttonEl.innerHTML = '<span class="edit-icon"><img src="../images/icons/icon-check-black.svg"></span>';
    buttonEl.setAttribute('onclick', `savePetName('${petId}', this)`);
}

function savePetName(petId, buttonEl) {
  const input = document.getElementById(`pet-name-input-${petId}`);
  const newName = input.value.trim();

  if (!newName) {
    messageToTheUser("Augintiniui reikia vardo!");
    return;
  }

  for (const otherId in userPetAssets["pets"]) {
    if (otherId !== petId && userPetAssets["pets"][otherId].name === newName) {
      messageToTheUser("Toks vardas jau uimtas!");
      return;
    }
  }

  changePetName(petId, newName);

  const newSpan = document.createElement('span');
  newSpan.id = `pet-name-${petId}`;
  newSpan.textContent = newName;
  input.replaceWith(newSpan);

  buttonEl.innerHTML = '<span class="edit-icon"><img src="../images/icons/icon-edit.svg"></span>';
  buttonEl.setAttribute('onclick', `editPetName('${petId}', this)`);
}

function changePetName(petId, newName) {
  userPetAssets["pets"][petId].name = newName;
  sendPetAssetsUpdateToDatabase();
}


function calculateHappinesIndexForPet (petId) {
    pet = document.getElementById(petId)
    const foodAmount = pet._stats.food
    const waterAmount = pet._stats.water
    const loveAmount = pet._stats.love

    const happinesIndex = Math.round(((foodAmount + waterAmount + loveAmount) / 30) * 100) / 100;

    const indicator = document.getElementById(`pet-stats-selection-button-indicator-${petId}`)

    if (foodAmount === 0 || waterAmount === 0) {
        indicator.style.display = "flex";
        return false
    } else if (happinesIndex < 0.35) {
        indicator.style.display = "flex";
        return false
    } else {
        indicator.style.display = "none";
        return true
    }
}

let holdInterval = null;
let holdTimeout = null;
let holdSpeed = 200; // initial speed in ms
const minSpeed = 50; // fastest speed in ms
const speedIncrease = 0.9; // multiplier to speed up (lower = faster)

function incrementValue(inputId, min = 1, max = 999, callback) {
    const input = document.getElementById(inputId);
    let value = parseInt(input.value) || min;
    if (value < max) {
        input.value = value + 1;
        if (callback) callback(); // call updatePrice here
    }
}

function decrementValue(inputId, min = 1, max = 999, callback) {
    const input = document.getElementById(inputId);
    let value = parseInt(input.value) || min;
    if (value > min) {
        input.value = value - 1;
        if (callback) callback(); // call updatePrice here
    }
}

function startHold(inputId, min, max, isIncrement, callback) {
    if (isIncrement) incrementValue(inputId, min, max, callback);
    else decrementValue(inputId, min, max, callback);

    holdSpeed = 200;

    holdTimeout = setTimeout(() => {
        const repeat = () => {
            if (isIncrement) incrementValue(inputId, min, max, callback);
            else decrementValue(inputId, min, max, callback);

            if (holdSpeed > minSpeed) {
                holdSpeed = Math.max(minSpeed, holdSpeed * speedIncrease);
            }

            clearInterval(holdInterval);
            holdInterval = setInterval(repeat, holdSpeed);
        };

        holdInterval = setInterval(repeat, holdSpeed);
    }, 300);
}


// Stop hold
function stopHold() {
    clearTimeout(holdTimeout);
    clearInterval(holdInterval);
    holdInterval = null;
    holdTimeout = null;
    holdSpeed = 200;
}


// Validate manual input (optional)
document.querySelectorAll('input.purchase-quantity').forEach(input => {
    input.addEventListener('change', function() {
        const min = parseInt(this.min) || 1;
        const max = parseInt(this.max) || 999;
        let value = parseInt(this.value) || min;
        if (value < min) this.value = min;
        else if (value > max) this.value = max;

    });
});

function initShopHeaderCollapse() {
    const shopHeader = document.getElementById('shopHeader');
    const shopHeaderMain = document.querySelector('.header-main');
    const shopItems = document.getElementById('shop-items');
    const expandToggle = document.getElementById('expandToggle');

    if (!shopHeader || !shopItems || !expandToggle) return;

    let isManuallyExpanded = false;
    let lastScrollTop = 0;
    let userScrolling = false;

    const expandThreshold = 50;

    function handleScroll() {
        if (!userScrolling) return;

        const scrollTop = shopItems.scrollTop;
        const scrollingDown = scrollTop > lastScrollTop;
        const scrollingUp = scrollTop < lastScrollTop;

        const headerIsCompact = shopHeader.classList.contains('compact');

        if (scrollingDown && !headerIsCompact) {
            shopHeader.classList.add('compact');
        } else if (scrollingUp && scrollTop < expandThreshold && headerIsCompact) {
            //shopHeader.classList.remove('compact');
        }

        lastScrollTop = scrollTop;
    }

    // Scroll container user events
    shopItems.addEventListener('wheel', () => { 
        userScrolling = true; 
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });

    shopItems.addEventListener('touchstart', () => { userScrolling = true; });
    shopItems.addEventListener('touchmove', () => { userScrolling = true; handleScroll(); });
    shopItems.addEventListener('touchend', () => { userScrolling = false; });

    shopItems.addEventListener('scroll', handleScroll);

    // Manual toggle
    shopHeaderMain.addEventListener('click', () => {
        const isCompact = shopHeader.classList.toggle('compact');
        isManuallyExpanded = !isCompact;
        if (isManuallyExpanded) {
            setTimeout(() => { isManuallyExpanded = false; }, 5000);
        }
    });

    // Header inputs/buttons/toggles
    shopHeader.querySelectorAll('button, input[type="checkbox"], input[type="radio"], input[type="range"]').forEach(el => {
        el.addEventListener('click', () => {
            shopItems.scrollTop = 0;
        });
    });

    // Dropdowns (<select>) trigger scroll on change
    shopHeader.querySelectorAll('select').forEach(el => {
        el.addEventListener('change', () => {
            shopItems.scrollTop = 0;
        });
    });

    // Proxy scroll from header (wheel)
    shopHeader.addEventListener('wheel', (e) => {
        e.preventDefault();
        userScrolling = true;
        shopItems.scrollTop += e.deltaY;
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });

    // Proxy scroll from header (touch)
    let lastTouchY = null;
    shopHeader.addEventListener('touchstart', (e) => {
        lastTouchY = e.touches[0].clientY;
        userScrolling = true;
    });
    shopHeader.addEventListener('touchmove', (e) => {
        if (lastTouchY === null) return;
        const currentY = e.touches[0].clientY;
        const deltaY = lastTouchY - currentY;
        shopItems.scrollTop += deltaY;
        lastTouchY = currentY;
        userScrolling = true;
        handleScroll();
        e.preventDefault();
    });
    shopHeader.addEventListener('touchend', () => {
        lastTouchY = null;
        userScrolling = false;
    });
}

function initPetAssetHeaderCollapse() {
    const header = document.getElementById('petAssetHeader');
    const headerMain = header?.querySelector('.header-main');
    const container = document.getElementById('pet-supplies') || document.getElementById('pet-skins');
    const expandToggle = document.getElementById('petAssetExpandToggle');

    if (!header || !container || !expandToggle) return;

    let isManuallyExpanded = false;
    let lastScrollTop = 0;
    let userScrolling = false;
    const expandThreshold = 50;

    function handleScroll() {
        if (!userScrolling || isManuallyExpanded) return;
        const scrollTop = container.scrollTop;
        const scrollingDown = scrollTop > lastScrollTop;
        const scrollingUp = scrollTop < lastScrollTop;
        const headerIsCompact = header.classList.contains('compact');

        if (scrollingDown && !headerIsCompact) {
            header.classList.add('compact');
        } else if (scrollingUp && scrollTop < expandThreshold && headerIsCompact) {
            //header.classList.remove('compact');
        }
        lastScrollTop = scrollTop;
    }

    container.addEventListener('wheel', () => { 
        userScrolling = true; 
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });

    container.addEventListener('touchstart', () => { userScrolling = true; });
    container.addEventListener('touchmove', () => { userScrolling = true; handleScroll(); });
    container.addEventListener('touchend', () => { userScrolling = false; });
    container.addEventListener('scroll', handleScroll);

    headerMain?.addEventListener('click', () => {
        const isCompact = header.classList.toggle('compact');
        isManuallyExpanded = true;
        if (isManuallyExpanded) {
            setTimeout(() => { isManuallyExpanded = false; }, 3000);
        }
    });

    header.querySelectorAll('button, input, select').forEach(el => {
        el.addEventListener('click', () => { container.scrollTop = 0; });
        if (el.tagName === 'SELECT') {
            el.addEventListener('change', () => { container.scrollTop = 0; });
        }
    });

    header.addEventListener('wheel', (e) => {
        e.preventDefault();
        userScrolling = true;
        container.scrollTop += e.deltaY;
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });
}

function initFurnitureHeaderCollapse() {
    const header = document.getElementById('furnitureHeader');
    const headerMain = header?.querySelector('.header-main');
    const container = document.querySelector('.object-assets');
    const expandToggle = document.getElementById('furnitureExpandToggle');

    if (!header || !container || !expandToggle) return;

    let isManuallyExpanded = false;
    let lastScrollTop = 0;
    let userScrolling = false;
    const expandThreshold = 50;

    function handleScroll() {
        if (!userScrolling || isManuallyExpanded) return;
        const scrollTop = container.scrollTop;
        const scrollingDown = scrollTop > lastScrollTop;
        const scrollingUp = scrollTop < lastScrollTop;
        const headerIsCompact = header.classList.contains('compact');

        if (scrollingDown && !headerIsCompact) {
            header.classList.add('compact');
        } else if (scrollingUp && scrollTop < expandThreshold && headerIsCompact) {
            //header.classList.remove('compact');
        }
        lastScrollTop = scrollTop;
    }

    container.addEventListener('wheel', () => { 
        userScrolling = true; 
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });

    container.addEventListener('touchstart', () => { userScrolling = true; });
    container.addEventListener('touchmove', () => { userScrolling = true; handleScroll(); });
    container.addEventListener('touchend', () => { userScrolling = false; });
    container.addEventListener('scroll', handleScroll);

    headerMain?.addEventListener('click', () => {
        const isCompact = header.classList.toggle('compact');
        isManuallyExpanded = true;
        if (isManuallyExpanded) {
            setTimeout(() => { isManuallyExpanded = false; }, 3000);
        }
    });

    header.querySelectorAll('button, input, select').forEach(el => {
        el.addEventListener('click', () => { container.scrollTop = 0; });
        if (el.tagName === 'SELECT') {
            el.addEventListener('change', () => { container.scrollTop = 0; });
        }
    });

    header.addEventListener('wheel', (e) => {
        e.preventDefault();
        userScrolling = true;
        container.scrollTop += e.deltaY;
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });
}

function initTaxesHeaderCollapse() {
    const header = document.getElementById('taxesHeader');
    const headerMain = header?.querySelector('.header-main');
    const container = document.querySelector('.tax-records');
    const expandToggle = document.getElementById('taxesExpandToggle');

    if (!header || !container || !expandToggle) return;

    let isManuallyExpanded = false;
    let lastScrollTop = 0;
    let userScrolling = false;
    const expandThreshold = 50;

    function handleScroll() {
        if (!userScrolling || isManuallyExpanded) return;
        const scrollTop = container.scrollTop;
        const scrollingDown = scrollTop > lastScrollTop;
        const scrollingUp = scrollTop < lastScrollTop;
        const headerIsCompact = header.classList.contains('compact');

        if (scrollingDown && !headerIsCompact) {
            header.classList.add('compact');
        } else if (scrollingUp && scrollTop < expandThreshold && headerIsCompact) {
            //header.classList.remove('compact');
        }
        lastScrollTop = scrollTop;
    }

    container.addEventListener('wheel', () => { 
        userScrolling = true; 
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });

    container.addEventListener('touchstart', () => { userScrolling = true; });
    container.addEventListener('touchmove', () => { userScrolling = true; handleScroll(); });
    container.addEventListener('touchend', () => { userScrolling = false; });
    container.addEventListener('scroll', handleScroll);

    headerMain?.addEventListener('click', () => {
        const isCompact = header.classList.toggle('compact');
        isManuallyExpanded = true;
        if (isManuallyExpanded) {
            setTimeout(() => { isManuallyExpanded = false; }, 3000);
        }
    });

    header.addEventListener('wheel', (e) => {
        e.preventDefault();
        userScrolling = true;
        container.scrollTop += e.deltaY;
        handleScroll();
        requestAnimationFrame(() => userScrolling = false);
    });
}

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        initShopHeaderCollapse();
        initPetAssetHeaderCollapse();
        initFurnitureHeaderCollapse();
        initTaxesHeaderCollapse();
    }, 100);
});

window.onload = function () {
    const savedController = localStorage.getItem('controller');
    if (savedController) {
        controller = JSON.parse(savedController);
        redirectToAppropriateLanguage(controller.language);
        resetControllerTaskSettings();
    } else {
        controller.language = "LT";
        localStorage.setItem('controller', JSON.stringify(controller));
    }
    navigationResponsiveLayout();
    document.querySelector('#gameContainer').removeAttribute('hidden');
};

async function fetchMessageGiftsFromServer() {
    try {
        const response = await apiFetch(apiBase + 'petGame/deliverMessages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': userData.token // must match your backend auth
            },
            body: JSON.stringify({ studentId: userData.userId })
        });

        if (!response) return;

        if (response.ok) {
            const data = await response.json();
            if (data.success && data.gifts.length > 0) {
                handleReceivedMessagesAndGifts(data.gifts);
            }
        } else {
            console.error(`Failed to fetch message gifts: ${response.status}`);
        }
    } catch (error) {
        console.error('Error fetching message gifts:', error);
    }
}

async function handleReceivedMessagesAndGifts(gifts) {
  if (!receivedMessages) receivedMessages = [];
  if (!userPetAssets) userPetAssets = {};
  if (!userPetAssets.pets) userPetAssets.pets = {};
  if (!userPetAssets.supplies) userPetAssets.supplies = {};
  if (!userObjectAssets) userObjectAssets = {};

  for (const gift of gifts) {
    try {
      const quantity = gift.quantity || 1;

      // If theres no giftId, its just a message
      if (gift.giftId == null) {
        receivedMessages.push({ id: gift.giftId, message: gift.message });
        continue;
      }

      const itemDetails = gameAssetIndex[gift.giftId];
      if (!itemDetails) {
        console.warn(`Gift item ID ${gift.giftId} not found in gameAssetIndex`);
        continue;
      }

      const item = itemDetails;
      const cssClasses = item['css-class'].split(' ');
      const isPetAsset = item.petAsset === true;
      const isSkin = cssClasses.includes('skin');
      const isPet = item.pet === true;

      if (isPetAsset) {
        // PET ASSET LOGIC
        if (isSkin) {
          // SKIN logic
          const petType = cssClasses[0];
          if (!userPetAssets.pets[petType]) {
            userPetAssets.pets[petType] = { skins: {}, name: item.petName };
          }
          if (!userPetAssets.pets[petType].skins)
            userPetAssets.pets[petType].skins = {};

          // Add as unique skin (not stackable)
          const existingSkins = Object.keys(userPetAssets.pets[petType].skins);
          const skinNumber = existingSkins.length + 1;
          const newSkinKey = `${petType}-${skinNumber}`;
          userPetAssets.pets[petType].skins[newSkinKey] = {
            assetIndex: gift.giftId,
            equiped: false,
          };
        } else {
          // SUPPLY logic (can be stackable)
          if (!userPetAssets.supplies) userPetAssets.supplies = {};

          if (item.stackable && !item.oneOfKind) {
            // Stack with existing
            let existingSupplyKey = null;
            for (const key in userPetAssets.supplies) {
              if (userPetAssets.supplies[key].assetIndex === gift.giftId) {
                existingSupplyKey = key;
                break;
              }
            }

            if (existingSupplyKey) {
              userPetAssets.supplies[existingSupplyKey].quantity += quantity;
            } else {
              const newSupplyKey = getNextSupplyKey();
              userPetAssets.supplies[newSupplyKey] = {
                assetIndex: gift.giftId,
                quantity: quantity,
              };
            }
          } else {
            // Non-stackable pet item
            for (let i = 0; i < quantity; i++) {
              const newSupplyKey = getNextSupplyKey();
              userPetAssets.supplies[newSupplyKey] = {
                assetIndex: gift.giftId,
                quantity: 1,
              };
            }
          }
        }

        // Update pet assets
        await sendPetAssetsUpdateToDatabase();

        // If its a pet, trigger pet-related updates
        if (isPet) {
          updateStatsBeforeRerunningInitGameAndRenderPets();
          renderPets();
          enablePetDragging();
          createPetButtons();
        }

      } else {
        // OBJECT ASSET LOGIC
        if (item.oneOfKind) {
          const newKey = getNextObjectKey();
          userObjectAssets[newKey] = { assetIndex: gift.giftId, position: [] };
        } else {
          for (let i = 0; i < quantity; i++) {
            const newKey = getNextObjectKey();
            userObjectAssets[newKey] = { assetIndex: gift.giftId, position: [] };
          }
        }
        await sendObjectAssetsUpdateToDatabase();
      }

      // Show message + notification
      receivedMessages.push({ id: gift.giftId, message: gift.message });

    } catch (err) {
      console.error('Error handling gift:', err, gift);
    }
  }

  displayReceivedMessages();
}

// Add this function near the top of your script (after line 100 or so):
function getNextObjectKey() {
    let maxNum = 0;
    for (const key in userObjectAssets) {
        const num = parseInt(key.substring(1)); // Extract number from "O5"
        if (num > maxNum) maxNum = num;
    }
    return `O${maxNum + 1}`;
}

function displayReceivedMessages () {
    if (receivedMessages.length > 0) {
        const message = receivedMessages.shift();
        
        const messageTextDiv = document.createElement('div');
        messageTextDiv.innerHTML = message.message;

        const finalMessage = document.createElement('div');
        finalMessage.appendChild(messageTextDiv)

        if (message.id) {
            const item = gameAssetIndex[message.id];

             // Assume `item` has a 'css-class' property and `message` has a 'message' property
            const previewContainer = document.createElement('div');
            previewContainer.className = 'preview';

            // Create the gift box
            const giftBox = document.createElement('div');
            giftBox.className = 'gift-box';
            previewContainer.appendChild(giftBox);

            // Pick a random gift image
            const gifts = ['../images/pet-game/gift-box-1.png', '../images/pet-game/gift-box-2.png', '../images/pet-game/gift-box-3.png'];
            const randomGift = gifts[Math.floor(Math.random() * gifts.length)];
            giftBox.style.backgroundImage = `url('${randomGift}')`;

            // Create the item preview holder
            const previewHolder = document.createElement('div');
            previewHolder.className = 'item-preview-holder gift-preview-holder';

            // Create the item preview div
            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']} gift-preview`;

            previewHolder.appendChild(previewDiv);
            previewContainer.appendChild(previewHolder);

            const previewContainerOuter = document.createElement('div');
            previewContainerOuter.className = 'preview-outer';

            previewContainerOuter.appendChild(previewContainer)

            finalMessage.appendChild(previewContainerOuter)
        }

        openObjectPopup(content=finalMessage, title='inut nuo SUDEDU', subtitle = '', functionToTrigger=displayReceivedMessages, saferClosing=true)
    }
}

// Apply translation + scale
function applyViewportTransform() {
    const scaleWrapper = document.getElementById('scale-wrapper');
    const translateWrapper = document.getElementById('room-transform-wrapper');
    
    if (scaleWrapper && translateWrapper) {
        scaleWrapper.style.transform = `scale(${viewportState.scale})`;
        translateWrapper.style.transform = `translate(${viewportState.x}px, ${viewportState.y}px)`;
    }
}

// Screen  room coordinate conversions
function screenToRoom(screenX, screenY) {
    const viewport = document.getElementById('viewport-container');
    const rect = viewport.getBoundingClientRect();
    return {
        x: (screenX - rect.left - viewportState.x) / viewportState.scale,
        y: (screenY - rect.top - viewportState.y) / viewportState.scale
    };
}

function roomToScreen(roomX, roomY) {
    return {
        x: roomX * viewportState.scale + viewportState.x,
        y: roomY * viewportState.scale + viewportState.y
    };
}

// ------------------ Desktop zoom ------------------
function handleViewportZoom(e) {
    // Check if zoom is locked
    if (viewportState.zoomLocked) {
        e.preventDefault();
        return;
    }
    
    e.preventDefault();

    const delta = e.deltaY * -0.001;
    const newScale = Math.min(
        Math.max(viewportState.scale + delta, viewportState.minScale),
        viewportState.maxScale
    );

    const viewport = document.getElementById('viewport-container');
    const rect = viewport.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const roomX = (mouseX / viewportState.scale - viewportState.x);
    const roomY = (mouseY / viewportState.scale - viewportState.y);

    viewportState.x = mouseX / newScale - roomX;
    viewportState.y = mouseY / newScale - roomY;
    viewportState.scale = newScale;

    applyViewportTransform();
}

// ------------------ Mobile pinch zoom ------------------
let initialPinchDistance = null;
let initialPinchScale = 1;
let initialPinchX = 0;
let initialPinchY = 0;
let initialViewportX = 0;
let initialViewportY = 0;
const PINCH_DEADZONE = 15; // Increased for better stability
let multiTouchCooldown = null;

function getDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx*dx + dy*dy);
}

function handleTouchMove(e) {
    if (e.touches.length === 2) {
        // Check if zoom is locked
        if (viewportState.zoomLocked) {
            e.preventDefault();
            return;
        }
        
        e.preventDefault();
        
        const currentDistance = getDistance(e.touches);
        const viewport = document.getElementById('viewport-container');
        const rect = viewport.getBoundingClientRect();
        
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

        if (!initialPinchDistance) {
            initialPinchDistance = currentDistance;
            initialPinchScale = viewportState.scale;
            initialPinchX = midX;
            initialPinchY = midY;
            initialViewportX = viewportState.x;
            initialViewportY = viewportState.y;
            viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();
            return;
        }

        // Deadzone
        const distanceChange = Math.abs(currentDistance - initialPinchDistance);
        if (distanceChange < PINCH_DEADZONE) {
            const deltaX = (midX - initialPinchX) / viewportState.scale;
            const deltaY = (midY - initialPinchY) / viewportState.scale;
            
            viewportState.x = initialViewportX + deltaX;
            viewportState.y = initialViewportY + deltaY;
            viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();
            
            applyViewportTransform();
            return;
        }

        // Direct scale calculation - no damping
        const scaleFactor = currentDistance / initialPinchDistance;
        let newScale = initialPinchScale * scaleFactor;
        newScale = Math.min(Math.max(newScale, viewportState.minScale), viewportState.maxScale);

        const scaleChange = newScale / initialPinchScale;
        viewportState.x = initialViewportX * scaleChange + initialPinchX * (1 - scaleChange);
        viewportState.y = initialViewportY * scaleChange + initialPinchY * (1 - scaleChange);
        viewportState.scale = newScale;
        viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();

        applyViewportTransform();
    }
}

function handleTouchEnd(e) {
    if (e.touches.length < 2) {
        initialPinchDistance = null;
        initialPinchX = 0;
        initialPinchY = 0;
        initialViewportX = 0;
        initialViewportY = 0;
    }

    if (isDragging && currentObject) {
        validateAndResetPosition(currentObject);
    }
    
    // When ALL touches end after multi-touch
    if (e.touches.length === 0 && multiTouchActive) {
        // ADD THIS: Validate position before clearing
        if (currentObject) {
            validateAndResetPosition(currentObject);
        }
        
        // Clear everything including object dragging
        if (holdTimer) {
            clearInterval(holdTimer);
            holdTimer = null;
        }
        
        currentObject = null;
        isDragging = false;
        
        document.querySelectorAll('.dragging').forEach(el => {
            el.classList.remove('dragging');
        });
        
        // Clear placement highlights
        clearPlacementHighlights();
        
        if (multiTouchCooldown) {
            clearTimeout(multiTouchCooldown);
        }
        
        multiTouchCooldown = setTimeout(() => {
            multiTouchActive = false;
            multiTouchCooldown = null;
        }, 300);
    }
}

function handleViewportPanStart(e) {
    const isTouchMultiFinger = e.touches?.length >= 2;
    
    //  SET THIS FIRST, before any other logic
    if (isTouchMultiFinger) {
        multiTouchActive = true;
        e.preventDefault();
        e.stopPropagation();
        
        // Clear all object ready states and highlights
        document.querySelectorAll('.room-object').forEach(obj => {
            obj._readyToDrag = false;
            if (obj._longPressTimeout) {
                clearTimeout(obj._longPressTimeout);
                obj._longPressTimeout = null;
            }
        });
        clearPlacementHighlights();
    }
    
    const isMiddleClick = e.button === 1;
    const isLeftClickWithSpace = viewportState.spacePressed && e.button === 0 && e.pointerType === "mouse";

    if (isMiddleClick || isLeftClickWithSpace || isTouchMultiFinger) {
        e.preventDefault();
        e.stopPropagation();
        viewportState.isDragging = true;
        document.body.classList.add('panning');

        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;

        viewportState.dragStartX = clientX - viewportState.x * viewportState.scale;
        viewportState.dragStartY = clientY - viewportState.y * viewportState.scale;
        viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();
    }
}

function handleViewportPanMove(e) {
    // Handle space + trackpad movement (no click needed)
    if (viewportState.spacePressed && !viewportState.isDragging && e.pointerType !== "touch") {
        // Initialize on first move after space is pressed
        if (viewportState.lastMouseX === 0 && viewportState.lastMouseY === 0) {
            viewportState.lastMouseX = e.clientX;
            viewportState.lastMouseY = e.clientY;
            return; // Skip the first move to avoid jump
        }
        
        const deltaX = e.clientX - viewportState.lastMouseX;
        const deltaY = e.clientY - viewportState.lastMouseY;
        
        // Only pan if there's actual movement
        if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
            viewportState.x += deltaX / viewportState.scale;
            viewportState.y += deltaY / viewportState.scale;
            viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();
            applyViewportTransform();
        }
        
        viewportState.lastMouseX = e.clientX;
        viewportState.lastMouseY = e.clientY;
        return;
    }
    
    if (!viewportState.isDragging) {
        // Update last mouse position even when not dragging
        if (e.pointerType !== "touch") {
            viewportState.lastMouseX = e.clientX;
            viewportState.lastMouseY = e.clientY;
        }
        return;
    }
    
    // Don't pan if we're dragging an object
    if (isDragging && currentObject) return;

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    viewportState.x = (clientX - viewportState.dragStartX) / viewportState.scale;
    viewportState.y = (clientY - viewportState.dragStartY) / viewportState.scale;
    viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();

    applyViewportTransform();
}

function handleViewportPanEnd(e) {
    viewportState.isDragging = false;
    document.body.classList.remove('panning');

    if (e?.type.startsWith('touch')) {
        if (e.touches?.length === 0 && multiTouchActive) {
            // ADD THIS: Validate position
            if (currentObject) {
                validateAndResetPosition(currentObject);
            }
            
            if (holdTimer) {
                clearInterval(holdTimer);
                holdTimer = null;
            }
            
            currentObject = null;
            isDragging = false;
            
            document.querySelectorAll('.dragging').forEach(el => {
                el.classList.remove('dragging');
            });
            
            // Clear placement highlights
            clearPlacementHighlights();
            
            if (multiTouchCooldown) {
                clearTimeout(multiTouchCooldown);
            }
            
            multiTouchCooldown = setTimeout(() => {
                multiTouchActive = false;
                multiTouchCooldown = null;
            }, 300);
        }
    }
}

// ------------------ Keyboard ------------------
function handleKeyDown(e) {
    if (e.code === 'Space' && !viewportState.spacePressed) {
        e.preventDefault();
        viewportState.spacePressed = true;
        document.body.classList.add('pan-mode-active');
        document.getElementById('pan-mode-indicator')?.classList.add('active');
    }
}

function handleKeyUp(e) {
    if (e.code === 'Space') {
        e.preventDefault();
        viewportState.spacePressed = false;
        viewportState.lastMouseX = 0;  // ADD THIS
        viewportState.lastMouseY = 0;  // ADD THIS
        document.body.classList.remove('pan-mode-active');
        document.getElementById('pan-mode-indicator')?.classList.remove('active');

        if (viewportState.isDragging) handleViewportPanEnd();
    }
}

// ------------------ Initialize ------------------
function initViewportControls() {
    const viewport = document.getElementById('viewport-container');
    if (!viewport) return;

    // Desktop zoom
    viewport.addEventListener('wheel', handleViewportZoom, { passive: false });

    // Pan/drag
    viewport.addEventListener('pointerdown', handleViewportPanStart);
    viewport.addEventListener('touchstart', handleViewportPanStart, { passive: false });

    window.addEventListener('pointermove', handleViewportPanMove);
    window.addEventListener('pointerup', handleViewportPanEnd);
    window.addEventListener('touchmove', handleViewportPanMove, { passive: false });
    window.addEventListener('touchend', handleViewportPanEnd);

    // Mobile pinch zoom
    viewport.addEventListener('touchmove', handleTouchMove, { passive: false });
    viewport.addEventListener('touchend', handleTouchEnd);

    // Keyboard
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // Prevent context menu
    viewport.addEventListener('contextmenu', (e) => e.preventDefault());

    // Initial transform
    applyViewportTransform();
}


function blockTopHalfOfSelectedDivsClickEvents() { //To prevent clicking of objects that take up some empty space, usually reserved for animation, click still goes to objects under, like a pet
  // For each class in the list
  topHalfClickBlockedItemClasses.forEach(className => {
    // Find all elements with this class
    const elements = document.querySelectorAll(`.${className}`);
    
    // Apply click blocking to each element
    elements.forEach(div => {
      // Create an invisible overlay for the bottom half only
      const overlay = document.createElement('div');
      overlay.style.position = 'absolute';
      overlay.style.top = '50%';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.pointerEvents = 'auto';
      overlay.style.zIndex = '1';
      
      // Make the main div pass-through
      div.style.pointerEvents = 'none';
      
      // Make children also pass-through
      Array.from(div.children).forEach(child => {
        child.style.pointerEvents = 'none';
      });
      
      // Add the overlay
      div.style.position = 'relative';
      div.appendChild(overlay);
      
      // Forward events from overlay to the div
      overlay.addEventListener('click', (e) => {
        e.stopPropagation();
        div.dispatchEvent(new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          clientX: e.clientX,
          clientY: e.clientY
        }));
      });
    });
  });
}

function makeSelectedClickThrough() {
  // For each class in the list
  clickPassesTroughClasses.forEach(className => {
    const elements = document.querySelectorAll(`.${className}`);

    elements.forEach(div => {
      // Make the main div fully pass-through
      div.style.pointerEvents = 'none';

      // Make all children pass-through too
      Array.from(div.children).forEach(child => {
        child.style.pointerEvents = 'none';
      });
    });
  });
}

function makeSelectedClickable() {
  // For each class in the list
  clickPassesTroughClasses.forEach(className => {
    const elements = document.querySelectorAll(`.${className}`);

    elements.forEach(div => {
      // Restore pointer events on the main div
      div.style.pointerEvents = 'auto';

      // Restore pointer events on all children too
      Array.from(div.children).forEach(child => {
        child.style.pointerEvents = 'auto';
      });
    });
  });
}

const toggleZoomLockBtn = document.getElementById("toggle-zoom-lock-btn");

toggleZoomLockBtn.addEventListener("click", () => {
    viewportState.zoomLocked = !viewportState.zoomLocked;
    updateZoomLockButton();
});

function updateZoomLockButton() {
    const btn = document.getElementById("toggle-zoom-lock-btn");

    if (viewportState.zoomLocked) {
        btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                <path d="M240-80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h40v-80q0-83 58.5-141.5T480-920q83 0 141.5 58.5T680-720v80h40q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Zm0-80h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM360-640h240v-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80ZM240-160v-400 400Z"/>
            </svg>`;
        btn.classList.add("locked");
    } else {
        btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                <path d="M240-160h480v-400H240v400Zm240-120q33 0 56.5-23.5T560-360q0-33-23.5-56.5T480-440q-33 0-56.5 23.5T400-360q0 33 23.5 56.5T480-280ZM240-160v-400 400Zm0 80q-33 0-56.5-23.5T160-160v-400q0-33 23.5-56.5T240-640h280v-80q0-83 58.5-141.5T720-920q83 0 141.5 58.5T920-720h-80q0-50-35-85t-85-35q-50 0-85 35t-35 85v80h120q33 0 56.5 23.5T800-560v400q0 33-23.5 56.5T720-80H240Z"/>
            </svg>`;
        btn.classList.remove("locked");
    }
}



// Sidebar functionality
const sidebarWrapper = document.getElementById('sidebarWrapper');
const toggleTab = document.getElementById('toggleTab');
const sidebarOverlay = document.getElementById('sidebarOverlay');

// Toggle sidebar function
function toggleSidebar() {
  sidebarWrapper.classList.toggle('open');
}

// Open sidebar function
function openSidebar() {
  sidebarWrapper.classList.add('open');
}

// Close sidebar function
function closeSidebar() {
    sidebarWrapper.classList.remove('open');
}

function displaySidebar() {
    const sidebarWrapper = document.querySelector('.sidebar-wrapper');
    const width = sidebarWrapper.offsetWidth;

    const isSmallScreen = window.innerWidth <= 768;

    const isPortraitTablet = window.matchMedia(
    "(min-width: 768px) and (max-width: 1024px) and (orientation: portrait)"
    ).matches;

    if (isSmallScreen || isPortraitTablet) {
        sidebarWrapper.style.transform = `translateX(${(width)*-1}px)`;
    } else {
        sidebarWrapper.style.transform = `translateX(0px)`;
    }
}

function hideSidebar() {
    document.querySelector(".object-sidebar-assets").innerHTML = '';
    document.querySelector("#object-sidebar-category-select").innerHTML = '';

    const sidebarWrapper = document.querySelector('.sidebar-wrapper');
    const width = sidebarWrapper.offsetWidth;

    sidebarWrapper.style.transform = `translateX(${(width+35)*-1}px)`;

    closeSidebar();
}


// Event listeners
if (toggleTab) {
    toggleTab.addEventListener('click', toggleSidebar);
}

// Close sidebar on window resize if it becomes desktop size
window.addEventListener('resize', () => {
    hideSidebar()
});


function moveSidebarToEnableBackdropFilterEffect () {
    const element = document.getElementById('sidebarWrapper');
    const mobileParent = document.body;
    const desktopParent = document.getElementById('gameContainer');

    if (window.innerWidth < 768) {
        mobileParent.appendChild(element);
    } else {
        desktopParent.appendChild(element);
    }
}

// Run on load
moveSidebarToEnableBackdropFilterEffect();

// Run on resize
window.addEventListener('resize', moveSidebarToEnableBackdropFilterEffect);

function getRoomCenterCoordinatesClosestToViewportCenter() {
  const viewport = document.getElementById('viewport-container');
  const scaleWrapper = document.getElementById('scale-wrapper');
  const transformWrapper = document.getElementById('room-transform-wrapper');
  
  // Get viewport center
  const viewportRect = viewport.getBoundingClientRect();
  const viewportCenterX = viewportRect.width / 2;
  const viewportCenterY = viewportRect.height / 2;
  
  // Extract transform values
  const scaleMatch = scaleWrapper.style.transform.match(/scale\(([\d.]+)\)/);
  const scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
  
  const translateMatch = transformWrapper.style.transform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
  const translateX = translateMatch ? parseFloat(translateMatch[1]) : 0;
  const translateY = translateMatch ? parseFloat(translateMatch[2]) : 0;
  
  // Convert viewport center to room-container coordinates
  const roomX = (viewportCenterX / scale) - translateX;
  const roomY = (viewportCenterY / scale) - translateY;
  
  // Get grid bounds
  const gridHeight = roomLayout.length;
  const gridWidth = roomLayout[0]?.length || 0;
  
  // Calculate center tile
  let gridX = Math.max(0, Math.min(gridWidth - 1, Math.floor(roomX / unitSize)));
  let gridY = Math.max(0, Math.min(gridHeight - 1, Math.floor(roomY / unitSize)));
  
  // Valid tile types for placement
  const validTypes = new Set([1.0, 2.0, 3.0]);
  
  // Move left until we hit an invalid tile or edge
  let leftX = gridX;
  while (leftX > 0) {
    const tileType = roomLayout[gridY][leftX - 1];
    const type = tileType?.type ?? tileType;
    if (!validTypes.has(type)) break;
    leftX--;
  }
  
  // Move up until we hit an invalid tile or edge
  let topY = gridY;
  while (topY > 0) {
    const tileType = roomLayout[topY - 1][leftX];
    const type = tileType?.type ?? tileType;
    if (!validTypes.has(type)) break;
    topY--;
  }
  
  return [leftX, topY];
}

function isObjectVisibleInViewport(objectId) {
  const viewport = document.getElementById('viewport-container');
  const object = document.getElementById(objectId);
  
  if (!viewport || !object) return false;
  
  // Get viewport bounds
  const viewportRect = viewport.getBoundingClientRect();
  
  // Get object bounds (already transformed)
  const objectRect = object.getBoundingClientRect();
  
  // Check if rectangles overlap
  const isVisible = !(
    objectRect.right < viewportRect.left ||    // Object is left of viewport
    objectRect.left > viewportRect.right ||    // Object is right of viewport
    objectRect.bottom < viewportRect.top ||    // Object is above viewport
    objectRect.top > viewportRect.bottom       // Object is below viewport
  );
  
  return isVisible;
}

function centerViewportOnObject(objectId) {
  const viewport = document.getElementById('viewport-container');
  const transformWrapper = document.getElementById('room-transform-wrapper');
  const scaleWrapper = document.getElementById('scale-wrapper');
  const object = document.getElementById(objectId);
  
  if (!object) return;
  
  // Get viewport dimensions
  const viewportRect = viewport.getBoundingClientRect();
  const viewportCenterX = viewportRect.width / 2;
  const viewportCenterY = viewportRect.height / 2;
  
  // Extract current scale
  const scaleMatch = scaleWrapper.style.transform.match(/scale\(([\d.]+)\)/);
  const scale = scaleMatch ? parseFloat(scaleMatch[1]) : viewportState.scale;
  
  // Get object's position and center
  const objectRect = object.getBoundingClientRect();
  const roomContainerRect = document.getElementById('room-container').getBoundingClientRect();
  
  // Calculate object center relative to room-container (in room coordinates)
  const objectCenterX = (objectRect.left - roomContainerRect.left) / scale + objectRect.width / (2 * scale);
  const objectCenterY = (objectRect.top - roomContainerRect.top) / scale + objectRect.height / (2 * scale);
  
  // Calculate required translate to center object
  const translateX = viewportCenterX / scale - objectCenterX;
  const translateY = viewportCenterY / scale - objectCenterY;
  
  // Update viewportState and apply transform
  viewportState.x = translateX;
  viewportState.y = translateY;
  
  transformWrapper.style.transform = `translate(${translateX}px, ${translateY}px)`;
  
  // Update closest tile after viewport moves
  viewportState.closestTile = getRoomCenterCoordinatesClosestToViewportCenter();
}

function toggleRoomExpansion() {
    const containerExpanded = "container-expanded";

    const game = document.querySelector("#gameContainer");
    const petButtons = document.querySelector("#pet-buttons-outer");
    const statsBars = document.querySelector(".pet-stats-bars");
    const upperControls = document.querySelector(".stats-and-upper-controls-holder");
    const expandBtnSpan = document.querySelector("#toggle-expand-btn span");
    const gameNavigation = document.querySelector(".game-navigation");
    const contentContainer = document.querySelector("#content-outer-container");
    const sidebarWrapper = document.querySelector(".sidebar-wrapper");
    const mainCoinDisplay = document.querySelector(".main-coin-display-holder .coin-display");
    const gameContentPanel = document.querySelector(".game-content-panel");

    const isExpanded = game.classList.contains(containerExpanded);

    if (isExpanded) {
        game.classList.remove(containerExpanded);
        petButtons.classList.remove(containerExpanded);
        mainCoinDisplay.classList.remove(containerExpanded);
        statsBars.classList.remove(containerExpanded);
        upperControls.classList.remove(containerExpanded);
        gameNavigation.classList.remove(containerExpanded);
        contentContainer.classList.remove(containerExpanded);
        sidebarWrapper.classList.remove(containerExpanded);
        gameContentPanel.classList.remove(containerExpanded);

        expandBtnSpan.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                <path d="M120-120v-320h80v184l504-504H520v-80h320v320h-80v-184L256-200h184v80H120Z"/>
            </svg>`;
        if (!editing) {
            hideSidebar();
        }
    } else {
        displaySidebar();
        game.classList.add(containerExpanded);
        petButtons.classList.add(containerExpanded);
        statsBars.classList.add(containerExpanded);
        upperControls.classList.add(containerExpanded);
        gameNavigation.classList.add(containerExpanded);
        contentContainer.classList.add(containerExpanded);
        sidebarWrapper.classList.add(containerExpanded);
        mainCoinDisplay.classList.add(containerExpanded);
        gameContentPanel.classList.add(containerExpanded);

        expandBtnSpan.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960">
                <path d="m136-80-56-56 264-264H160v-80h320v320h-80v-184L136-80Zm344-400v-320h80v184l264-264 56 56-264 264h184v80H480Z"/>
            </svg>
            `;
    }
}



// FUNCTIONS TO HELP DEVELOPMENT START

function highlightWalkabilityMap() {
    const walkabilityMap = globalWalkabilityMap;
    if (!walkabilityMap) return;

    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const container = document.getElementById('room-container');

    for (let row = 0; row < walkabilityMap.length; row++) {
        for (let col = 0; col < walkabilityMap[0].length; col++) {
            const tile = walkabilityMap[row][col];
            if (!tile) continue;

            // Determine color based on allowedDirections
            let color;
            if (!tile.walkable) {
                color = 'rgba(50,50,50,0.5)'; // Non-walkable
            } else {
                const dirs = tile.allowedDirections;
                const vertical = dirs[0] && dirs[2];
                const horizontal = dirs[1] && dirs[3];
                const all = vertical && horizontal;

                if (all) color = 'rgba(0, 255, 0, 0.2)';         // All directions green
                else if (vertical) color = 'rgba(0, 0, 255, 0.2)'; // Up/Down only purple
                else if (horizontal) color = 'rgba(255, 255, 0, 0.2)'; // Left/Right only yellow
                else color = 'rgba(255, 165, 0, 0.2)';           // Single or other peach
            }

            createTileHighlight(container, col, row, unitSize, color);
        }
    }
}

// Standalone function to create a tile highlight
function createTileHighlight(container, col, row, size, color) {
    const div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.width = `${size}px`;
    div.style.height = `${size}px`;
    div.style.left = `${col * size}px`;
    div.style.top = `${row * size}px`;
    div.style.backgroundColor = color;
    div.style.pointerEvents = 'none';
    div.style.zIndex = 9999
    container.appendChild(div);
    return div;
}

// Overlay directional triangles inside a tile
function createDirectionOverlay(tileDiv, direction, color) {
    const overlay = document.createElement('div');
    overlay.style.position = 'absolute';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.backgroundColor = color; // use rgba for transparency
    overlay.style.pointerEvents = 'none';

    // Use clip-path to form triangle
    switch(direction) {
        case 0: overlay.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)'; break; // Up
        case 1: overlay.style.clipPath = 'polygon(0% 0%, 100% 50%, 0% 100%)'; break; // Right
        case 2: overlay.style.clipPath = 'polygon(0% 0%, 100% 0%, 50% 100%)'; break; // Down
        case 3: overlay.style.clipPath = 'polygon(100% 0%, 100% 100%, 0% 50%)'; break; // Left
    }

    tileDiv.appendChild(overlay);
}

/*
setTimeout(() => {
    highlightWalkabilityMap(globalWalkabilityMap);
}, 2000);
*/

// Z-Index Assignment System for Room Layout

/*
function assignZIndexesToLayout(roomLayout) {
    const rows = roomLayout.length;
    const cols = roomLayout[0].length;
    
    // Create z-index map (same dimensions as roomLayout)
    const zIndexMap = Array(rows).fill(null).map(() => Array(cols).fill(null));
    
    // Simply assign z-index based on row number
    // Row 0 = z-index 1, Row 1 = z-index 2, etc.
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const tileType = roomLayout[row][col];
            const type = tileType?.type ?? tileType;
            
            // Only assign z-index to floor (1.0) and boundary (3.0) tiles
            if (type === 1.0 || type === 3.0) {
                zIndexMap[row][col] = row + 1; // Start from 1 instead of 0
            }
        }
    }
    
    return zIndexMap;
}

// Visualization function
function highlightZIndexMap(zIndexMap) {
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const container = document.getElementById('room-container');
    
    if (!container) return;
    
    // Clear any existing highlights
    container.querySelectorAll('.z-index-highlight').forEach(el => el.remove());
    
    // Find min and max z-indexes for color scaling
    let minZ = Infinity;
    let maxZ = -Infinity;
    
    for (let row = 0; row < zIndexMap.length; row++) {
        for (let col = 0; col < zIndexMap[0].length; col++) {
            const z = zIndexMap[row][col];
            if (z !== null) {
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }
        }
    }
    
    // Create highlights
    for (let row = 0; row < zIndexMap.length; row++) {
        for (let col = 0; col < zIndexMap[0].length; col++) {
            const z = zIndexMap[row][col];
            if (z === null) continue;
            
            // Color gradient from blue (low z) to red (high z)
            const normalized = maxZ === minZ ? 0 : (z - minZ) / (maxZ - minZ);
            const hue = (1 - normalized) * 240; // 240 = blue, 0 = red
            const color = `hsla(${hue}, 70%, 50%, 0.4)`;
            
            // Create tile highlight
            const div = document.createElement('div');
            div.className = 'z-index-highlight';
            div.style.position = 'absolute';
            div.style.width = `${unitSize}px`;
            div.style.height = `${unitSize}px`;
            div.style.left = `${col * unitSize}px`;
            div.style.top = `${row * unitSize}px`;
            div.style.backgroundColor = color;
            div.style.pointerEvents = 'none';
            div.style.zIndex = '10000';
            div.style.border = '1px solid rgba(0,0,0,0.2)';
            
            // Add z-index label
            const label = document.createElement('span');
            label.textContent = z;
            label.style.position = 'absolute';
            label.style.top = '50%';
            label.style.left = '50%';
            label.style.transform = 'translate(-50%, -50%)';
            label.style.fontSize = '10px';
            label.style.fontWeight = 'bold';
            label.style.color = '#fff';
            label.style.textShadow = '1px 1px 2px #000';
            label.style.pointerEvents = 'none';
            
            div.appendChild(label);
            container.appendChild(div);
        }
    }
    
    console.log(`Z-Index Range: ${minZ} to ${maxZ}`);
}

// Usage example
function applyAndVisualizeZIndexes() {
    if (!roomLayout) {
        console.error('roomLayout not available');
        return;
    }
    
    const zIndexMap = assignZIndexesToLayout(roomLayout);
    highlightZIndexMap(zIndexMap);
    
    return zIndexMap;
}

// Call after a delay to ensure room is loaded
setTimeout(() => {
    const zIndexMap = applyAndVisualizeZIndexes();
    console.log('Z-Index map generated:', zIndexMap);
}, 3000);

*/
// FUNCTIONS TO HELP DEVELOPMENT END

    </script>
</body>
</html>