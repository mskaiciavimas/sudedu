<!DOCTYPE html>
<html lang="lt">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Word Info Display</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
	<link href="https://cdn.jsdelivr.net/npm/dragula@3.7.3/dist/dragula.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
	<style>
	body {
		background-color: #FFC074;
		font-family: 'Andika', sans-serif;
		overscroll-behavior: none;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
		justify-content: center;
		align-items: center;
		display: flex;
		height: 100vh;
		width: 100vw;
		margin: 0;
	}

	:root {
		--font-size: 22px; /* Set the base font size */
	}

	.container {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 90%;
		height: 90%;
		max-width: 95% !important;
	}

	.field {
		color: gray;
		background-color: #FAF1E6;
		box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
		border-radius: 10px;

		max-width: 90vw;
		padding: 15px;
		padding-left: 30px;
		padding-right: 30px;
		counter-reset: div-counter;
	}

	.sakiniai {
		padding-top: 5px;
		padding-bottom: 5px;
		font-size: var(--font-size);
		color: black;
		counter-increment: div-counter;
		position: relative;
		margin-bottom: 10px;
	}

	.sakiniai::before {
		content: counter(div-counter) ". "; /* Display the number */
	}

	.question-input {
		padding: 0;
		border: none;
		border-bottom: 2px solid black;
		background: transparent;
		outline: none;        
		font-size: var(--font-size);       
  	color: black; 
		width: 23ch;
		min-width: 0.5ch; 
		text-align: center;
		max-width: 70px;  
	}

	input:disabled {
  user-select: none; /* Prevent text selection */
  pointer-events: none; /* Ensure the input is not interactable */
	}	

	.question-word-span.middle {
		margin-left: 5px;
	}

	.correct-answer {
		color: #01937C;
		text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
		caret-color: black;
	}

	.wrong-answer {
		color: #D57E7C;
		text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
		caret-color: black;
	}

	.row {
		width: 100%;
	}

	.check-next-question-row {
		padding-top: 20px;
		padding-bottom: 50px;
	}
	
	.btn-primary {
          font-size: 1rem;
          align-items: center;
          justify-content: center;
          width: 11.5vw;
          margin: 10px 0 10px 0;
          background-color: #B6C867;
          border-color: #B6C867;
          color: black;
          font-weight: bold;
          box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
        }

	.btn-primary:focus,
	.btn-primary:active,
	.btn-primary:hover,
	.btn-primary:disabled {
		background-color: #01937C;
		border-color: #01937C;
		color: black;
	}

	#next-question {
		display: none;
	}

	.pagalba-span{
		color: gray;
		font-size: calc(var(--font-size)*0.8);
	}

	#warning {
		font-size: 18px;
		margin-right: 10px;

	}

	.stop-reset-button-div {
  padding-top: 10px;
}

.reset-button-div {
  display: flex;
  justify-content: flex-end;
  z-index: 3;
}

.stop-button-div {
  display: flex;
  justify-content: flex-start;
  z-index: 3;
}

.reset-button {
  width: 5rem;
  height: 5rem;
  border-radius: 0.25rem;
  background-color: #B6C867;
  border-color: #B6C867;
  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 3;
}

.stop-button {
  width: 5rem;
  height: 5rem;
  border-radius: 0.25rem;
  background-color: #B6C867;
  border-color: #B6C867;
  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 3;
}

.material-symbols-rounded {
  font-variation-settings:
    'FILL' 0,
    'wght' 500,
    'GRAD' 0,
    'opsz' 48;
  font-size: 3.5rem;
  color: black;
}

.reset-button:hover,
.reset-button:active,
.reset-button:focus {
  background-color: #01937C;
  border-color: #01937C;
  color: black;
}

.stop-button:hover,
.stop-button:active,
.stop-button:focus {
  background-color: #01937C;
  border-color: #01937C;
  color: black;
}

.col-2 {
	padding: 0;
}

.trackers-row {
	padding-bottom: 10px;
}

@media (max-width: 767px) {
	#help-button {
		width: 20vw;
	}
	#check-answers{
		width: 20vw;
	}

	.container {
		height: 90%;
		width: 100%;
		margin-left: 0;
		margin-right: 0;
	}

}

@media (max-width: 575px) {
	#help-button {
		width: 30vw;
	}
	#check-answers{
		width: 30vw;
	}
}
	</style>
</head>

<body>
	<div class="container" style="display: flex; flex-direction: column; justify-content: space-between;">
		<div class="row justify-content-center align-items-center trackers-row">
			<div class="col-6 d-flex justify-content-start align-items-left">
				<h3 id="mistake-tracker">Teisingai: 0/0</h3>
		</div>
		<div class="col-6 d-flex justify-content-end align-items-left">
			<h3>
				<div id="timer"></div>
			</h3>
		</div>
		</div>
		<div class="row justify-content-center align-items-center">
			<div class="col-12 justify-content-center align-items-center">
				<div id="text" class="field">
				</div>
			</div>
		</div>
		<div class="row justify-content-center align-items-center">
		<div class="row justify-content-center align-items-center check-next-question-row">
			<div class="col-6 d-flex justify-content-start align-items-left">
				<button id="help-button" class="btn btn-primary">Pagalba</button>
			</div>
			<div class="col-6 d-flex justify-content-end align-items-center">
				<div id="warning"></div>
				<button id="check-answers" class="btn btn-primary">Tikrinti</button>
				<button id="next-question" class="btn btn-primary">Toliau</button>
			</div>
		</div>

		<div class="row justify-content-center align-items-center">
			<div class="row d-flex d-flex align-items-end justify-content-center stop-reset-button-div">
				<div class="col-2">
					<div class="stop-button-div">
						<button id="stopButton" class="btn btn-primary stop-button"><span id="stop-button-span"
								class="material-symbols-rounded">close</span></button>
					</div>
				</div>
				<div class="col-8"></div>
				<div class="col-2">
					<div class="reset-button-div">
						<button class="btn btn-primary reset-button"><span class="material-symbols-rounded">roofing</span></button>
					</div>
				</div>
			</div>
		</div>
	</div>
	</div>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/dragula@3.7.3/dist/dragula.min.js"></script>
	<script src="../mental-arithmetic.js"></script>

	<script>
	// Define an array of URLs for the JSON files you want to fetch
	const jsonFiles = ['sentence_library.json'];
	Promise.all(jsonFiles.map(file => fetch(file).then(response => {
		if(!response.ok) {
			throw new Error(`Network error while fetching ${file}`);
		}
		return response.json();
	}).catch(error => {
		console.error('Error:', error);
		return null; // Return null or empty object in case of error
	}))).then(([sentenceLibrary]) => {

		controller = JSON.parse(localStorage.getItem('controller')) 
		let sakiniai = [];
		let atsakymai = {};
		let questionsToDisplay = Number(controller.modeChoice2);
		let firstTimeChecking = true;
		let totalAttemptedQuestions = 0;
		let totalCorrectAnswers = 0;
		const maximumQuestionFrequencyPerWord = 1;

		if(sentenceLibrary) {
			const conditions = controller.modeChoice3

			const categoriesToCheck = ["prv", "bdv", "vks", "dkt", "įsi-r", "įvr", "skt"]
			const categoriesThatNeedEndings = ["prv", "bdv", "vks", "dkt"]
			const categoryMatchingRules = {
				// Default case: category matches only itself
				"default": [],
				// Allow certain categories to match each other (e.g., įvr matches įvr)
				"bdv": ["prv"],
				"vks": [],
				"dkt": [],
				"prv": ["bdv"],
				"įvr": [],
				"skt": [],
				"įsi-r": ["prv", "bdv", "vks", "dkt"],
				"prš": ["prv", "bdv", "vks", "dkt"],
				"prs": ["prv", "bdv", "vks", "dkt"],
				"asim": ["prv", "bdv", "vks", "dkt"],
				"md": ["prv", "bdv", "vks", "dkt"],
			};
			const subCategoryMatchingRules = {
				"dkt": {
					// Default case: category matches only itself
					"default": [],
					// Allow certain categories to match each other (e.g., įvr matches įvr)
					"v": ["k", "n", "g", "įn", "vt", "š"],
					"k": ["v", "n", "g", "įn", "vt", "š"],
					"n": ["v", "k", "g", "įn", "vt", "š"],
					"g": ["v", "k", "n", "įn", "vt", "š"],
					"įn": ["v", "k", "n", "g", "vt", "š"],
					"vt": ["v", "k", "n", "g", "įn", "š"],
					"š": ["v", "k", "n", "g", "įn", "vt"],
				},
				"bdv": {
					// Default case: category matches only itself
					"default": [],
					// Allow certain categories to match each other (e.g., įvr matches įvr)
					"v": ["k", "n", "g", "įn", "vt", "š"],
					"k": ["v", "n", "g", "įn", "vt", "š"],
					"n": ["v", "k", "g", "įn", "vt", "š"],
					"g": ["v", "k", "n", "įn", "vt", "š"],
					"įn": ["v", "k", "n", "g", "vt", "š"],
					"vt": ["v", "k", "n", "g", "įn", "š"],
				},
				"vks": {
					// Default case: category matches only itself
					"default": [],
					"būs-l": [],
					"es-l": [],
					"b-k-l": [],
					"b-d-l": []
				},
				"įsi-r": {
					"1kl": [],
					"2kl": ["1kl"],
					"3kl": ["1kl", "2kl"],
					"4kl": ["1kl", "2kl", "3kl"],
				}
			}
			const subCategoriesToCheck = {
				"dkt": ["v", "k", "n", "g", "įn", "vt", "š"],
				"bdv": ["v", "k", "n", "g", "įn", "vt"],
				"vks": ["būs-l", "es-l", "b-k-l", "b-d-l"],
				"įsi-r": ["1kl", "2kl", "3kl", "4kl"]
			}

			// Function to get allowed matching categories
			function getAllowedMatchingCategories(category, rules) {
					// Check if category is an array or a single string
					if (Array.isArray(category)) {
							// If category is an array, iterate over the array
							return category.reduce((acc, cat) => {
									if (rules[cat] && rules[cat].length > 0) {
											return [...acc, ...[cat], ...rules[cat]];
									} else {
											return [...acc, cat];
									}
							}, []);
					} else {
							// If category is a single string, handle as before
							if (rules[category] && rules[category].length > 0) {
									return [...[category], ...rules[category]];
							} else {
									return [category];
							}
					}
			}

			function checkCategories(wordInfo, categoriesToCheck, allowedPairs) {
				function ensureStrings(array) {
					return array.map(item => {
						if(typeof item === "object" && Array.isArray(item)) {
							return item.map(innerItem => innerItem.toString()); // Flatten nested lists into strings
						} else if(typeof item === "object") {
							return JSON.stringify(item); // Handle generic objects
						} else {
							return item.toString(); // Convert primitives to strings
						}
					}).flat(); // Flatten the result in case of nested arrays
				}
				allowedPairs = ensureStrings(allowedPairs)
				// Loop through each category to check
				for(let category of categoriesToCheck) {
					// If the category is in allowedPairs, we skip the check
					if(allowedPairs.includes(category)) {
						continue;
					}
					// If the value for the current category is not false, return false
					if(wordInfo[category] !== false) {
						return false;
					}
				}
				// If all checks pass, return true
				return true;
			}

			function shuffleArray(array) {
				for(let i = array.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1)); // Random index
					[array[i], array[j]] = [array[j], array[i]]; // Swap elements
				}
			}

			let tempfilteredSentenceLibrary = [];
			let filteredSentenceLibrary = []

			function filterSentenceLibrary() {
				filteredSentenceLibrary = sentenceLibrary.filter(entry => Object.entries(conditions).some(([key, values]) => {
					if(!(key in entry.metadata)) {
						return false; // Key must exist in metadata
					}
					if(values.length === 0) {
						return true; // Key existence alone satisfies the condition
					}
					return values.some(value => entry.metadata[key].includes(value)); // At least one value must match
				}));
				tempfilteredSentenceLibrary = [...filteredSentenceLibrary];
				shuffleArray(tempfilteredSentenceLibrary);
			}

			let noOfQuestionsGeneratedPerRound = questionsToDisplay * Object.keys(conditions).length;

			function assembleAndFormatSentences() {
				sakiniai = [];
				atsakymai = {};
				let questionId = 1;
				while(sakiniai.length < noOfQuestionsGeneratedPerRound) {
					for(const [condition, subcondition] of Object.entries(conditions)) {
						if(tempfilteredSentenceLibrary.length === 0) {
							tempfilteredSentenceLibrary = [...filteredSentenceLibrary];
							shuffleArray(tempfilteredSentenceLibrary);
						}
						for(let i = 0; i < tempfilteredSentenceLibrary.length; i++) {
							const sentence = tempfilteredSentenceLibrary[i];
							const metadata = sentence.metadata;
							// Check if the condition key exists in metadata
							if(metadata.hasOwnProperty(condition)) {
								const metadataValues = metadata[condition];
								// If subcondition is empty, or at least one required value matches metadata values
								if(subcondition.length === 0 || subcondition.some(value => metadataValues.includes(value))) {
									tempfilteredSentenceLibrary.splice(i, 1);
									const sentenceLength = sentence["sentence"].length;
									let questionQuota = Math.floor(sentenceLength / maximumQuestionFrequencyPerWord);
									let wordsThatCanBeUsedForQuestions = {};
									let wordsOneMustBeUsed = {};
									// Loop through sentence and process word information
									sentence["sentence"].map(([beforePunctuation, word, afterPunctuation, wordInfo]) => {
										if(wordInfo) {
											let matchesCondition = false;
											let matchesSubCondition = false;
											// Check if the condition key exists in the wordInfo

											if(!!wordInfo[condition]) {
												
												// If subcondition is empty, match all, otherwise check for matching values
												if(subcondition.length === 0 || subcondition.some(value => {
														if(!(subcondition[0] === undefined)) {
															return true;
														}
														return false;
													})) {
													matchesCondition = true;
												}
												if(matchesCondition) {
													if(checkCategories(wordInfo, categoriesToCheck, getAllowedMatchingCategories(condition, categoryMatchingRules))) {
														if (!(subcondition[0] === undefined)) {
														if(checkCategories(wordInfo, subCategoriesToCheck[condition], getAllowedMatchingCategories(subcondition, subCategoryMatchingRules[condition]))) {
															if (
																			(categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(condition)
																	) {
																			const isNounOrAdjective = (condition === "dkt") ||  (condition === "bdv");
																			const isVerb = condition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																					wordsOneMustBeUsed[word] = condition;
																			}
																	}
														}
													} else {
														if (
																			(categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(condition)
																	) {
																			const isNounOrAdjective = (condition === "dkt") ||  (condition === "bdv");
																			const isVerb = condition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																wordsOneMustBeUsed[word] =  condition;
																}
															}
													}
												}
												} else {
													// Check remaining conditions
													for(const [otherCondition, otherSubconditions] of Object.entries(conditions)) {
														if(otherCondition === condition) continue;
														if(!!wordInfo[otherCondition]) {
															let otherMatchesCondition = false;
															if(otherSubconditions.length === 0 || otherSubconditions.some(value => {
																	return !!wordInfo[value];
																})) {
																otherMatchesCondition = true;
															}
															if(otherMatchesCondition) {
																if(checkCategories(wordInfo, categoriesToCheck, getAllowedMatchingCategories(otherCondition, categoryMatchingRules))) {
																	if (!(otherSubconditions[0] === undefined)) {
																	if(checkCategories(wordInfo, subCategoriesToCheck[otherCondition], getAllowedMatchingCategories(otherSubconditions, subCategoryMatchingRules[otherCondition]))) {
																		if (
																			(categoriesThatNeedEndings.includes(otherCondition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																		wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																		break;
																			}
															}
																	}
																} else {
																	if (
																			(categoriesThatNeedEndings.includes(otherCondition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																	wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																	break;
															}
														}
																}
																}
															}
														}
													}
												}
											} else {
												for(const [otherCondition, otherSubconditions] of Object.entries(conditions)) {
													if(otherCondition === condition) {
														continue
													} else {
														if(wordInfo[otherCondition] === true) {
															let otherMatchesCondition = false;
															if(otherSubconditions.length === 0 || otherSubconditions.some(value => {
																	return wordInfo[value] === true;
																})) {
																otherMatchesCondition = true;
															}
															if(otherMatchesCondition) {
																if(checkCategories(wordInfo, categoriesToCheck, getAllowedMatchingCategories(otherCondition, categoryMatchingRules))) {
																	if (!(otherSubconditions[0] === undefined)) {
																	if(checkCategories(wordInfo, subCategoriesToCheck[otherCondition], getAllowedMatchingCategories(otherSubconditions, subCategoryMatchingRules[otherCondition]))) {
																		if (
																			(categoriesThatNeedEndings.includes(otherCondition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																		wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																		break;
																			}
															}
																	}
																} else {
																	if (
																			(categoriesThatNeedEndings.includes(otherCondition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																	wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																	break;
																			}
																	}
																}
															}
															}
														}
													}
												}
											}
										}
									});
									// Randomly select words that must be used and other words for the question
									let wordsToBeUsed = {};
									if (Object.keys(wordsOneMustBeUsed).length > 0) {
										let randomWord = Object.keys(wordsOneMustBeUsed)[Math.floor(Math.random() * Object.keys(wordsOneMustBeUsed).length)];
										wordsToBeUsed[randomWord] = wordsOneMustBeUsed[randomWord];
									}
									while (Object.keys(wordsToBeUsed).length < questionQuota && Object.keys(wordsThatCanBeUsedForQuestions).length > 0) {
										let randomWord = Object.keys(wordsThatCanBeUsedForQuestions)[Math.floor(Math.random() * Object.keys(wordsThatCanBeUsedForQuestions).length)];
										wordsToBeUsed[randomWord] = wordsThatCanBeUsedForQuestions[randomWord];
										delete wordsThatCanBeUsedForQuestions[randomWord];
									}
									
									if (Object.keys(wordsToBeUsed).length === 0) {
											continue;
									} else {
									// Now loop through the sentence again and build the final formatted sentence
									
									const formattedSentence = sentence["sentence"].map(([beforePunctuation, word, afterPunctuation, wordInfo]) => {
										if (word in wordsToBeUsed) {
											if (categoriesThatNeedEndings.includes(wordsToBeUsed[word])) {
												if (wordInfo["gal-s"]) {
													let pagalbaText = "";
													let valuesToShow = [];
													const pagalbaIndex = {
															"vns": "vns.",
															"dgs": "dgs.",
															"1-a": "Ia.",
															"2-a": "IIa.",
															"3-a": "IIIa.",
															"es-l": "es.l.",
															"b-k-l": "būt.k.l.",
															"b-d-l": "būt.d.l.",
															"būs-l": "būs.l."
													};

													// Assuming wordInfo is provided, e.g., wordInfo = { "vks": true, "dkt": false, "bdv": false }
													if (wordInfo["vks"] === true) {
														if (wordInfo["3-a"] === true) {
															valuesToCheck = ["es-l", "b-k-l", "b-d-l", "būs-l", "3-a"];
														} else {
															valuesToCheck = ["es-l", "b-k-l", "b-d-l", "būs-l", "vns", "dgs", "1-a", "2-a", "3-a"];
														}
															valuesToCheck.forEach(value => {
																	if (wordInfo[value]) {  // If wordInfo has the specific value set to true
																			valuesToShow.push(pagalbaIndex[value]);
																	}
															});
													} else if (wordInfo["dkt"] === true || wordInfo["bdv"] === true) {
															valuesToCheck = ["vns", "dgs"];
															valuesToCheck.forEach(value => {
																	if (wordInfo[value]) {  // If wordInfo has the specific value set to true
																			valuesToShow.push(pagalbaIndex[value]);
																	}
															});
															if (valuesToShow.length === 2) {
																valuesToShow = ["vns.?", "dgs.?"]
															}
															if (wordInfo["prv"] === true) {
																valuesToShow = valuesToShow.map(item => {
																// Check if the item does not already end with '?'
																if (!item.endsWith('?')) {
																	return item + '?';
																}
																return item;
															});
																valuesToShow.push("prv.?")
															}
													}

													// Join the results into a single string separated by commas
													const valuesToShowString = valuesToShow.join(', ');
												formattedWord = `${beforePunctuation}<span class="question-word-span end" style="display: inline; white-space: nowrap;">${wordInfo["gal-c"][0][0][0]}<input type="text" autocapitalize="none" autocomplete="off" id="id-${questionId}" class="question-input end"> <span class="pagalba-span">(${valuesToShowString})</span>${afterPunctuation}</span>`;
												atsakymai[`id-${questionId}`] = wordInfo["gal-c"][0][1][0];
												questionId++;
												return formattedWord
												}
											
											} else {
												var combinations = wordInfo[`${wordsToBeUsed[word]}-c`];
												if (combinations && combinations.length > 0) {
														let randomIndex = Math.floor(Math.random() * combinations.length);
														let randomElement = combinations[randomIndex];
														formattedWord = `${beforePunctuation}<span class="question-word-span middle" style="display: inline; white-space: nowrap;">${randomElement[0][0]}<input type="text" autocapitalize="none" autocomplete="off" id="id-${questionId}" class="question-input middle"><span class="pagalba-div"></span>${randomElement[2][0]}${afterPunctuation}</span>`;
														atsakymai[`id-${questionId}`] = randomElement[1][0];
														questionId++;
														return formattedWord
												}
										}
									 } else {
											return `${beforePunctuation}${word}${afterPunctuation}`;
										}
									}).join(' '); // Join the words after all processing
									const output = `<div class="sakiniai">${formattedSentence}</div>`;
									sakiniai.push(output);
									break; // Stop processing further sentences once one has been added
								}
							}
							}
						}
					}
				}
			}
		}

		function displaySentences() {
				// Ensure questionsToDisplay doesn't exceed the number of sentences
				if (questionsToDisplay > sakiniai.length) {
					assembleAndFormatSentences();
				}

				// Select random unique indices
				const selectedIndices = new Set();
				while (selectedIndices.size < questionsToDisplay) {
					const randomIndex = Math.floor(Math.random() * sakiniai.length);
					selectedIndices.add(randomIndex);
				}

				// Create sublist for selected sentences
				const subSakiniai = [];

				// Sort indices in descending order to avoid modifying the list while iterating
				const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);

				// Store selected items in subSakiniai
				for (const index of sortedIndices) {
					subSakiniai.push(sakiniai[index]);
				}

				// Create the remaining sentences by filtering out the selected ones
				const remainingSakiniai = sakiniai.filter((_, index) => !selectedIndices.has(index));
				sakiniai = remainingSakiniai;

				// Set the inner HTML of the text container
				document.getElementById("text").innerHTML = subSakiniai.join('');

				// Restrict input to Lithuanian letters and spaces for the question inputs
				document.querySelectorAll('.question-input').forEach(input => {
					input.addEventListener('input', function () {
						// Replace any character that isn't a Lithuanian letter or space
						this.value = this.value.replace(/[^a-zA-ZąčęėįšųūžĄČĘĖĮŠŲŪŽ\s]/g, '');
					});
				});
				document.querySelectorAll('input, textarea').forEach(input => {
					input.setAttribute('spellcheck', 'false');
    input.addEventListener('input', () => resizeInput(input));
    resizeInput(input);
  });

	focusFirstInput();

	document.querySelectorAll('.question-input').forEach(input => {
        // Add event listener to remove 'wrong-answer' class on focus
        input.addEventListener('focus', () => {
            input.classList.remove('wrong-answer');
        });
			});
			}


		function initiateTheProgram() {
		filterSentenceLibrary();
		assembleAndFormatSentences();
		displaySentences();
		if (localStorage.getItem("startTime")) {
      localStorage.removeItem("startTime");
    };
		helpToggle();
		startTimer();
	}


		initiateTheProgram();

		function resizeInput(inputElement) {
    // Create a temporary span element to measure the width of the input text
    const span = document.createElement('span');
    const style = window.getComputedStyle(inputElement);

    // Set the span to match the input's styling (same font, padding, etc.)
    span.style.font = style.font;
    span.style.padding = style.padding;
    span.style.margin = style.margin;
    span.style.whiteSpace = 'nowrap'; // Make sure the text does not wrap

    // Set the span's text to the input's current value
    span.textContent = inputElement.value || inputElement.placeholder;

    // Append the span to the document (it will be invisible)
    document.body.appendChild(span);

    // Get the width of the span and update the input width
    const width = span.getBoundingClientRect().width;

    // Remove the temporary span from the document
    document.body.removeChild(span);

		
    if (inputElement.value === '') {
      inputElement.style.width = `1.5ch`; // Dynamic width based on placeholder
    } else {
      inputElement.style.width = `${width+0.25}px`;
    }
  }

	function checkAnswers() {
    const inputs = document.querySelectorAll('.question-input');
		const NumberOfQuestionsInRound = inputs.length;
    const warning = document.getElementById('warning'); // Use `querySelector` to get the single element
    const nextQuestionButton = document.getElementById('next-question');
    warning.innerHTML = ""; // Clear previous warnings
    let answersCorrect = true;
    let allFilled = true; // Check if all fields are filled

		inputs.forEach(input => {
			let inputValue = input.value.trim().toLowerCase();
			if (inputValue === "") {
            allFilled = false; // Mark as not all filled
						warning.innerHTML = "įrašyk visas raides";
            return;
			}
		})
		if (allFilled)  {
    inputs.forEach(input => {
        const inputId = input.id;
        let inputValue = input.value.trim().toLowerCase();

        // Strip input value of spaces before comparing with the dictionary
        inputValue = inputValue.replace(/\s+/g, '');

        // Compare the stripped value with the corresponding value from atsakymai
        if (inputValue === atsakymai[inputId].replace(/\s+/g, '')) {
            input.classList.add('correct-answer');
            input.classList.remove('wrong-answer');
						input.disabled = true;
						if (firstTimeChecking) {
							totalCorrectAnswers++
						}
        } else {
            input.classList.add('wrong-answer');
            input.classList.remove('correct-answer');
            answersCorrect = false; // Mark as incorrect due to wrong answer
        }
				
    // Show "Next Question" button only if all answers are correct
    nextQuestionButton.style.display = answersCorrect ? "flex" : "none";
		document.getElementById('check-answers').style.display = answersCorrect ? "none" : "flex";

		
    });
		if (firstTimeChecking) {
					totalAttemptedQuestions = totalAttemptedQuestions + NumberOfQuestionsInRound
					document.getElementById('mistake-tracker').innerHTML = `Teisingai: ${totalCorrectAnswers}/${totalAttemptedQuestions}`;
				}
				firstTimeChecking = false;

	}
		
}

function helpToggle() {
	const elements = document.querySelectorAll('.pagalba-span');
    
    // Loop through each element and toggle the display property
    elements.forEach(element => {
        if (element.style.display === 'none') {
            element.style.display = 'inline-block'; // Set display to flex if it's none
        } else {
            element.style.display = 'none'; // Set display to none if it's not none
        }
    });
}


			function nextQuestion() {
				displaySentences()
				document.getElementById('check-answers').style.display = "flex"
				nextQuestionButton.style.display = "none";
				document.querySelectorAll('.pagalba-span').forEach(element => {
            element.style.display = 'none';
        
    });
				firstTimeChecking = true;
			}

			function stopQuestions() {
				const stopButtonSpanElement = document.querySelector('#stop-button-span');
				document.getElementById('warning').innerHTML = "";
				if (stopButtonSpanElement.innerHTML === "close") {
					clearInterval(timerInterval);
					stopButtonSpanElement.innerHTML = "refresh";
				} else if (stopButtonSpanElement.innerHTML === "refresh") {
					stopButtonSpanElement.innerHTML = "close";
					document.getElementById('mistake-tracker').innerHTML = `Teisingai: 0/0`;
					firstTimeChecking = true;
					totalAttemptedQuestions = 0;
					totalCorrectAnswers = 0;
					initiateTheProgram();
				}

				
			}

			function focusFirstInput() {
    const inputs = document.querySelectorAll('input[type="text"].question-input');
    if (inputs.length > 0) {
        inputs[0].focus();
    }
}

			function enableEnterNavigation() {
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault(); // Prevent default behavior like form submission
            const inputs = Array.from(document.querySelectorAll('input[type="text"].question-input'));
            const currentIndex = inputs.indexOf(document.activeElement);
            if (currentIndex !== -1 && currentIndex < inputs.length - 1) {
                inputs[currentIndex + 1].focus();
            }
        }
    });
}

enableEnterNavigation();

// Add event listener to the button
nextQuestionButton = document.getElementById('next-question')

document.getElementById('check-answers').addEventListener('click', checkAnswers);
document.getElementById('next-question').addEventListener('click', nextQuestion);
document.getElementById('help-button').addEventListener('click', helpToggle);

const stopButtonElement = document.querySelector('.stop-button');
stopButtonElement.addEventListener("click", stopQuestions)

const resetButtonElement = document.querySelector('.reset-button');
resetButtonElement.addEventListener("click", redirectToIndex);


	}).catch(error => {
		console.error('Error in fetching multiple JSON files:', error);
	});
	</script>
</body>

</html>