<!DOCTYPE html>
<html lang="lt">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>sudedu - rašyba</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
	<link href="https://cdn.jsdelivr.net/npm/dragula@3.7.3/dist/dragula.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
	<style>
	html {
		display: flex;
		justify-content: center;
		align-items: center;
		background-image: linear-gradient(to top, #ffbf9c, #ffbf92, #ffbf89, #ffbf7e, #ffc074);
  		min-height: 100dvh;
	}

	body {
		font-family: 'Andika', sans-serif;
		overscroll-behavior: none;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
		justify-content: center;
		align-items: center;
		display: flex;
  		background: transparent;
		width: 100vw;
		margin: 0;
	}

	:root {
		--font-size: 26px; /* Set the base font size */
	}

	.container {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 90%;
  		min-height: 95dvh;
		max-width: 95% !important;
	}

	.field {
		color: gray;
		background-color: #FAF1E6;
		box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
		border-radius: 10px;

		max-width: 90vw;
		padding: 15px;
		padding-left: 30px;
		padding-right: 30px;
		counter-reset: div-counter;
	}

	.sakiniai {
		padding-top: 5px;
		padding-bottom: 5px;
		font-size: var(--font-size);
		color: black;
		counter-increment: div-counter;
		position: relative;
		margin-bottom: 10px;
	}

	.sakiniai::before {
		content: counter(div-counter) ". "; /* Display the number */
	}

	.question-input {
		padding: 0;
		border: none;
		border-bottom: 2px solid black;
		background: transparent;
		outline: none;        
		font-size: var(--font-size);       
  		color: black; 
		width: 23ch;
		min-width: 0.5ch; 
		text-align: center;
		max-width: 70px;  
	}

	input:disabled {
  user-select: none; /* Prevent text selection */
  pointer-events: none; /* Ensure the input is not interactable */
	}	

	.question-word-span.middle {
		margin-left: 5px;
	}

	.correct-answer {
		color: #32ac93;
		text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
		caret-color: black;
	}

	.wrong-answer {
		color: #D57E7C;
		text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
		caret-color: black;
	}

	.row {
		width: 100%;
	}

	#task-saving-message:empty {
		min-height: 0;
	}

	#task-saving-message {
		font-size: 1.35rem;
		text-align: center;
		min-height: 200px;
		color: black;
		display: flex;
		justify-content: center;
		align-items: center;
	}

	.btn-primary {
          font-size: 1rem;
          align-items: center;
          justify-content: center;
          width: 11.5vw;
          margin: 10px 0 10px 0;
          background-color: #40c9a9;
          border-color: #40c9a9;
          color: black;
          font-weight: bold;
          box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
        }

	.btn-primary:focus,
	.btn-primary:active,
	.btn-primary:hover,
	.btn-primary:disabled {
		background-color: #32ac93;
		border-color: #32ac93;
		color: black;
	}

	#next-question {
		display: none;
	}

	.pagalba-span,
	.pagalba-span-perm {
		color: gray;
		font-size: calc(var(--font-size)*0.8);
	}

	#warning {
		font-size: 18px;
		padding-top: 20px;
	}

	.stop-reset-button-div {
  padding-top: 10px;
}

.reset-button-div {
  display: flex;
  justify-content: flex-end;
  z-index: 3;
}

.stop-button-div {
  display: flex;
  justify-content: flex-start;
  z-index: 3;
}

.reset-button {
  width: 5rem;
  height: 5rem;
  border-radius: 0.25rem;
  background-color: #40c9a9;
  border-color: #40c9a9;
  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 3;
}

.stop-button {
  width: 5rem;
  height: 5rem;
  border-radius: 0.25rem;
  background-color: #40c9a9;
  border-color: #40c9a9;
  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 3;
}

.material-symbols-rounded {
  font-variation-settings:
    'FILL' 0,
    'wght' 500,
    'GRAD' 0,
    'opsz' 48;
  font-size: 3.5rem;
  color: black;
}

.reset-button:hover,
.reset-button:active,
.reset-button:focus {
  background-color: #32ac93;
  border-color: #32ac93;
  color: black;
}

.stop-button:hover,
.stop-button:active,
.stop-button:focus {
  background-color: #32ac93;
  border-color: #32ac93;
  color: black;
}

.col-2 {
	padding: 0;
}

.trackers-row {
	padding-bottom: 10px;
}

#field-for-final-message {
    color: black;
    font-size: 4rem;
    text-align: center;
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.summary-button {
	min-width: 120px;
}

@media (max-width: 767px) {
	#help-button,
	#next-question,
	#show-answers {
		width: 20vw;
	}

	#check-answers{
		width: 20vw;
	}

	.container {
		height: 90%;
		width: 100%;
		margin-left: 0;
		margin-right: 0;
	}
	:root {
        --font-size: 22px; /* Smaller font size for tablets */
    }

	#field-for-final-message {
		font-size: 3rem;
	}

}

@media (max-width: 575px) {
	#help-button,
	#check-answers,
	#show-answers,
	#next-question {
		width: 30vw;
	}
	:root {
        --font-size: 22px; /* Smaller font size for tablets */
    }

	#field-for-final-message {
		font-size: 2rem;
	}
	.stop-button {
		width: 4.25rem;
		height: 4.25rem;
	}

	.reset-button {
		width: 4.25rem;
		height: 4.25rem;
	}
}
	</style>
</head>

<body>
	<div class="container" style="display: flex; flex-direction: column; justify-content: space-between;">
		<div class="row justify-content-center align-items-center trackers-row">
			<div class="col-6 d-flex justify-content-start align-items-left">
				<div class="trackers">
					<div>
						<h3 id="answer-tracker"></h3>
					</div>
					<div>
						<h3 id="mistake-tracker">Teisingai: 0/0</h3>
					</div>
				</div>
		</div>
		<div class="col-6 d-flex justify-content-end align-items-left">
			<h3>
				<div id="timer"></div>
			</h3>
		</div>
		</div>
		<div class="row justify-content-center align-items-center">
			<div class="col-12 justify-content-center align-items-center">
				<div id="field-for-text" class="field">
				<div id="field-for-sentences"></div>
				<div id="field-for-final-message"></div>
				<div id="task-saving-message"></div>
				<div id="restart-reset-button-row" class="row justify-content-center align-items-center" style="display: none;">
					<div class="col-12 submit-button-div d-flex justify-content-center align-items-center">
						<div id="reset-mistake-buttons" class="col-12 d-flex justify-content-center align-items-center">
								<div id="fireworks-div" class="position-absolute image-container bottom-0 end-0 fireworks-div"></div>
							<div class="col-12 d-flex position-relative justify-content-center align-items-center">
								<div class="d-flex justify-content-end align-items-center summary-div">
									<button class="btn btn-primary summary-button">Klaidos</button>
								</div>
	
							</div>
						</div>
					</div>
				</div>
			</div>
			</div>
		</div>
		<div class="row justify-content-center align-items-center">
      <div class="row justify-content-center align-items-center">
        <div class="col-12 d-flex justify-content-end align-items-center">
        <div id="warning" style="visibility: hidden;">įrašyk visas raides</div>
      </div>
      </div>
		<div class="row justify-content-center align-items-center check-next-question-row">
			<div class="col-6 d-flex justify-content-start align-items-left">
				<button id="help-button" class="btn btn-primary">Pagalba</button>
			</div>
			<div class="col-6 d-flex justify-content-end align-items-center">
				<button id="check-answers" class="btn btn-primary">Tikrinti</button>
				<button id="next-question" class="btn btn-primary">Toliau</button>
			</div>
		</div>
		<div class="row justify-content-center align-items-center">
			<div class="col-12 d-flex justify-content-end align-items-center">
        <button id="show-answers" class="btn btn-primary" style="visibility: hidden;">Atsakymai</button>
		</div>
		</div>

		<div class="row justify-content-center align-items-center">
			<div class="row d-flex d-flex align-items-end justify-content-center stop-reset-button-div">
				<div class="col-2">
					<div class="stop-button-div">
						<button id="stopButton" class="btn btn-primary stop-button"><span id="stop-button-span"
								class="material-symbols-rounded">close</span></button>
					</div>
				</div>
				<div class="col-8"></div>
				<div class="col-2">
					<div class="reset-button-div">
						<button class="btn btn-primary reset-button"><span class="material-symbols-rounded">roofing</span></button>
					</div>
				</div>
			</div>
		</div>
	</div>
	</div>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/dragula@3.7.3/dist/dragula.min.js"></script>
	<script src="../parameter_dictionary.js"></script>
	<script src="../mental-arithmetic.js"></script>

	<script>

window.onload = function () {
    if (localStorage.getItem('controller') === null) {
        window.location.href = "./";
    } else {
      controller = JSON.parse(localStorage.getItem('controller')) 
      if (controller.modeChoice1 !== "C50") {
			window.location.href = "./";
		}
    }
  }

  controller = JSON.parse(localStorage.getItem('controller'))

  let jsonFiles = [];

	// Define an array of URLs for the JSON files you want to fetch
	if (controller.classChoice === "C75") {
		jsonFiles = ['../databases/1_2_klase_rasyba.json'];
	} else if (controller.classChoice === "C76") {
		jsonFiles = ['../databases/3_4_klase_rasyba.json'];
	}
	Promise.all(jsonFiles.map(file => fetch(file).then(response => {
		if(!response.ok) {
			throw new Error(`Network error while fetching ${file}`);
		}
		return response.json();
	}).catch(error => {
		console.error('Error:', error);
		return null; // Return null or empty object in case of error
	}))).then(([sentenceLibrary]) => {

		let sakiniai = [];
		window.atsakymai = {};
		let questionId = 1;
		window.mistakeRecords = {};
		let questionsToDisplay = Number(controller.modeChoice2);
		let totalSentencesCompleted = 0;
		let firstTimeChecking = true;
		let totalCorrectAnswers = 0;
    	let currentAnswerAttempts = 0;
		const maximumQuestionFrequencyPerWord = controller.questionFrequency;
		let allowAdjacentEndlessWords;
		if (controller.modeChoice5 === "C73") {
			allowAdjacentEndlessWords = false;
		} else if (controller.modeChoice5 === "C74") {
			allowAdjacentEndlessWords = true;
		}
		let allAnswersCorrect = false;

		if(sentenceLibrary) {
			const codedConditions = controller.modeChoice3
			let conditions = {}

			Object.entries(codedConditions).forEach(([key, value]) => {
				let decodedKey = parameterDictionary[key]["parameter"];
				conditions[decodedKey] = value;
			});

			const categoriesToCheck = ["prv", "bdv", "vks", "dkt", "įsi-r", "įvr", "skt"]
			const categoriesThatNeedEndings = ["prv", "bdv", "vks", "dkt", "fsc-gal"]
			const categoryMatchingRules = {
				// Default case: category matches only itself
				"default": [],
				// Allow certain categories to match each other (e.g., įvr matches įvr)
				"bdv": ["prv"],
				"vks": [],
				"dkt": [],
				"fsc-gal": ["dkt"],
				"fsc-con": ["prv", "bdv", "vks", "dkt", "įvr", "skt", "įsi-r"],
				"fsc-vow": ["prv", "bdv", "vks", "dkt", "įvr", "skt", "įsi-r"],
				"prv": ["bdv"],
				"įvr": [],
				"skt": [],
				"įsi-r": ["prv", "bdv", "vks", "dkt"],
				"prš": ["prv", "bdv", "vks", "dkt"],
				"prs": ["prv", "bdv", "vks", "dkt"],
				"asim": ["prv", "bdv", "vks", "dkt"],
				"md": ["prv", "bdv", "vks", "dkt"],
			};
			const subCategoryMatchingRules = {
				"dkt": {
					// Default case: category matches only itself
					"default": [],
					// Allow certain categories to match each other (e.g., įvr matches įvr)
					"v": ["k", "n", "g", "įn", "vt", "š"],
					"k": ["v", "n", "g", "įn", "vt", "š"],
					"n": ["v", "k", "g", "įn", "vt", "š"],
					"g": ["v", "k", "n", "įn", "vt", "š"],
					"įn": ["v", "k", "n", "g", "vt", "š"],
					"vt": ["v", "k", "n", "g", "įn", "š"],
					"š": ["v", "k", "n", "g", "įn", "vt"],
				},
				"bdv": {
					// Default case: category matches only itself
					"default": [],
					// Allow certain categories to match each other (e.g., įvr matches įvr)
					"v": ["k", "n", "g", "įn", "vt", "š"],
					"k": ["v", "n", "g", "įn", "vt", "š"],
					"n": ["v", "k", "g", "įn", "vt", "š"],
					"g": ["v", "k", "n", "įn", "vt", "š"],
					"įn": ["v", "k", "n", "g", "vt", "š"],
					"vt": ["v", "k", "n", "g", "įn", "š"],
				},
				"vks": {
					// Default case: category matches only itself
					"default": [],
					"būs-l": [],
					"es-l": [],
					"b-k-l": [],
					"b-d-l": []
				},
				"įsi-r": {
					"1kl": ["2kl", "3kl", "4kl"],
					"2kl": ["1kl", "3kl", "4kl"],
					"3kl": ["1kl", "2kl", "4kl"],
					"4kl": ["1kl", "2kl", "3kl"],
				}
			}
			const subCategoriesToCheck = {
				"dkt": ["v", "k", "n", "g", "įn", "vt", "š"],
				"bdv": ["v", "k", "n", "g", "įn", "vt"],
				"vks": ["būs-l", "es-l", "b-k-l", "b-d-l"],
				"įsi-r": ["1kl", "2kl", "3kl", "4kl"]
			}

			// Function to get allowed matching categories

			function getAllowedMatchingCategories(category, rules) {
					// Check if category is an array or a single string
					if (Array.isArray(category)) {
							// If category is an array, iterate over the array
							return category.reduce((acc, cat) => {
									if (rules[cat] && rules[cat].length > 0) {
											return [...acc, ...[cat], ...rules[cat]];
									} else {
											return [...acc, cat];
									}
							}, []);
					} else {
							// If category is a single string, handle as before
							if (rules[category] && rules[category].length > 0) {
									return [...[category], ...rules[category]];
							} else {
									return [category];
							}
					}
			}

			function checkCategories(wordInfo, categoriesToCheck, allowedPairs) {
				function ensureStrings(array) {
					return array.map(item => {
						if(typeof item === "object" && Array.isArray(item)) {
							return item.map(innerItem => innerItem.toString()); // Flatten nested lists into strings
						} else if(typeof item === "object") {
							return JSON.stringify(item); // Handle generic objects
						} else {
							return item.toString(); // Convert primitives to strings
						}
					}).flat(); // Flatten the result in case of nested arrays
				}
				allowedPairs = ensureStrings(allowedPairs)
				// Loop through each category to check
				for(let category of categoriesToCheck) {
					// If the category is in allowedPairs, we skip the check
					if(allowedPairs.includes(category)) {
						continue;
					}
					// If the value for the current category is not false, return false
					if(wordInfo[category] !== false) {
						return false;
					}
				}
				// If all checks pass, return true
				return true;
			}

			function shuffleArray(array) {
				for(let i = array.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1)); // Random index
					[array[i], array[j]] = [array[j], array[i]]; // Swap elements
				}
			}

			let tempfilteredSentenceLibrary = [];
			let filteredSentenceLibrary = []

			function filterSentenceLibrary() {
				filteredSentenceLibrary = sentenceLibrary.filter(entry => Object.entries(conditions).some(([key, values]) => {
					if(!(key in entry.metadata)) {
						return false; // Key must exist in metadata
					}
					if(values.length === 0) {
						return true; // Key existence alone satisfies the condition
					}
					return values.some(value => entry.metadata[key].includes(value)); // At least one value must match
				}));
				tempfilteredSentenceLibrary = [...filteredSentenceLibrary];
				shuffleArray(tempfilteredSentenceLibrary);
			}

			let noOfQuestionsGeneratedPerRound = questionsToDisplay * Object.keys(conditions).length;

			function assembleAndFormatSentences() {
				sakiniai = [];
				while(sakiniai.length < noOfQuestionsGeneratedPerRound) {
					for(const [condition, subcondition] of Object.entries(conditions)) {
						if(tempfilteredSentenceLibrary.length === 0) {
							tempfilteredSentenceLibrary = [...filteredSentenceLibrary];
							shuffleArray(tempfilteredSentenceLibrary);
						}
						for(let i = 0; i < tempfilteredSentenceLibrary.length; i++) {
							const sentence = tempfilteredSentenceLibrary[i];
							const metadata = sentence.metadata;
							// Check if the condition key exists in metadata
							if(metadata.hasOwnProperty(condition)) {
								const metadataValues = metadata[condition];
								// If subcondition is empty, or at least one required value matches metadata values
								if(subcondition.length === 0 || subcondition.some(value => metadataValues.includes(value))) {
									tempfilteredSentenceLibrary.splice(i, 1);
									const sentenceLength = sentence["sentence"].length;
									let questionQuota = Math.floor(sentenceLength / maximumQuestionFrequencyPerWord);
									let wordsThatCanBeUsedForQuestions = {};
									let wordsOneMustBeUsed = {};
									// Loop through sentence and process word information
									sentence["sentence"].map(([wordData, id]) => {
										const [beforePunctuation, word, afterPunctuation, wordInfo] = wordData
										if(wordInfo) {
											let matchesCondition = false;
											let matchesSubCondition = false;
											// Check if the condition key exists in the wordInfo
											if(!!wordInfo[condition]) {
												// If subcondition is empty, match all, otherwise check for matching values
												if(subcondition.length === 0 || subcondition.some(value => {
														if(!(subcondition[0] === undefined)) {
															return true;
														}
														return false;
													})) {
													matchesCondition = true;
												}
												if(matchesCondition) {
													if(checkCategories(wordInfo, categoriesToCheck, getAllowedMatchingCategories(condition, categoryMatchingRules))) {
														if (!(subcondition[0] === undefined)) {
														if(checkCategories(wordInfo, subCategoriesToCheck[condition], getAllowedMatchingCategories(subcondition, subCategoryMatchingRules[condition]))) {
															if (
																			(controller.classChoice === "C75" && categoriesThatNeedEndings.includes(condition) && wordInfo["fsc-gal"]) ||
																			(controller.classChoice === "C76" && categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(condition)
																	) {
																			const isNounOrAdjective = (condition === "dkt") ||  (condition === "bdv");
																			const isVerb = condition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																					wordsOneMustBeUsed[word] = condition;
																			}
																	}
														}
													} else {
														if (
																			(controller.classChoice === "C75" && categoriesThatNeedEndings.includes(condition) && wordInfo["fsc-gal"]) ||
																			(controller.classChoice === "C76" && categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(condition)
																	) {
																			const isNounOrAdjective = (condition === "dkt") ||  (condition === "bdv");
																			const isVerb = condition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																wordsOneMustBeUsed[word] =  condition;
																}
															}
													}
												}
												} else {
													// Check remaining conditions
													for(const [otherCondition, otherSubconditions] of Object.entries(conditions)) {
														if(otherCondition === condition) continue;
														if(!!wordInfo[otherCondition]) {
															let otherMatchesCondition = false;
															if(otherSubconditions.length === 0 || otherSubconditions.some(value => {
																	return !!wordInfo[value];
																})) {
																otherMatchesCondition = true;
															}
															if(otherMatchesCondition) {
																if(checkCategories(wordInfo, categoriesToCheck, getAllowedMatchingCategories(otherCondition, categoryMatchingRules))) {
																	if (!(otherSubconditions[0] === undefined)) {
																	if(checkCategories(wordInfo, subCategoriesToCheck[otherCondition], getAllowedMatchingCategories(otherSubconditions, subCategoryMatchingRules[otherCondition]))) {
																		if (
																			(controller.classChoice === "C75" && categoriesThatNeedEndings.includes(condition) && wordInfo["fsc-gal"]) ||
																			(controller.classChoice === "C76" && categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																		wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																		break;
																			}
															}
																	}
																} else {
																	if (
																			(controller.classChoice === "C75" && categoriesThatNeedEndings.includes(condition) && wordInfo["fsc-gal"]) ||
																			(controller.classChoice === "C76" && categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																	wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																	break;
															}
														}
																}
																}
															}
														}
													}
												}
											} else {
												for(const [otherCondition, otherSubconditions] of Object.entries(conditions)) {
													if(otherCondition === condition) {
														continue
													} else {
														if(wordInfo[otherCondition] === true) {
															let otherMatchesCondition = false;
															if(otherSubconditions.length === 0 || otherSubconditions.some(value => {
																	return wordInfo[value] === true;
																})) {
																otherMatchesCondition = true;
															}
															if(otherMatchesCondition) {
																if(checkCategories(wordInfo, categoriesToCheck, getAllowedMatchingCategories(otherCondition, categoryMatchingRules))) {
																	if (!(otherSubconditions[0] === undefined)) {
																	if(checkCategories(wordInfo, subCategoriesToCheck[otherCondition], getAllowedMatchingCategories(otherSubconditions, subCategoryMatchingRules[otherCondition]))) {
																		if (
																			(controller.classChoice === "C75" && categoriesThatNeedEndings.includes(condition) && wordInfo["fsc-gal"]) ||
																			(controller.classChoice === "C76" && categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																		wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																		break;
																			}
															}
																	}
																} else {
																	if (
																			(controller.classChoice === "C75" && categoriesThatNeedEndings.includes(condition) && wordInfo["fsc-gal"]) ||
																			(controller.classChoice === "C76" && categoriesThatNeedEndings.includes(condition) && wordInfo["gal-s"]) ||
																			!categoriesThatNeedEndings.includes(otherCondition)
																	) {
																			const isNounOrAdjective = (otherCondition === "dkt") ||  (otherCondition === "bdv");
																			const isVerb = otherCondition === "vks";

																			const nounCondition = isNounOrAdjective && (
																					(wordInfo["vns"] === true && wordInfo["dgs"] !== false) ||
																					(wordInfo["vns"] === false && wordInfo["dgs"] !== true)
																			);

																			const verbCondition = isVerb && (
																					wordInfo["dalc"] === false
																			);

																			if (((isNounOrAdjective && wordInfo["dalc"] === false)|| !isVerb) || nounCondition || verbCondition) {
																	wordsThatCanBeUsedForQuestions[word] =  otherCondition;
																	break;
																			}
																	}
																}
															}
															}
														}
													}
												}
											}
										}
									});
									// Randomly select words that must be used and other words for the question
									let wordsToBeUsed = {};
									if (Object.keys(wordsOneMustBeUsed).length > 0) {
										let randomWord = Object.keys(wordsOneMustBeUsed)[Math.floor(Math.random() * Object.keys(wordsOneMustBeUsed).length)];
										wordsToBeUsed[randomWord] = wordsOneMustBeUsed[randomWord];
										delete wordsOneMustBeUsed[randomWord];
									}
									let combinedWordsThatCanBeUsed = Object.assign({}, wordsOneMustBeUsed, wordsThatCanBeUsedForQuestions);
									while (Object.keys(wordsToBeUsed).length < questionQuota && (Object.keys(combinedWordsThatCanBeUsed).length > 0)) {
										
										let randomWord = Object.keys(combinedWordsThatCanBeUsed)[Math.floor(Math.random() * Object.keys(combinedWordsThatCanBeUsed).length)];
										wordsToBeUsed[randomWord] = combinedWordsThatCanBeUsed[randomWord];
										delete combinedWordsThatCanBeUsed[randomWord];
									}
									
									if (Object.keys(wordsToBeUsed).length === 0) {
											continue;
									} else {
									// Now loop through the sentence again and build the final formatted sentence
									
									const formattedSentence = sentence["sentence"].reduce((acc, [wordData, id]) => {
										const [beforePunctuation, word, afterPunctuation, wordInfo] = wordData;
										if (word in wordsToBeUsed) {
											let pagalbaText = "";
											let valuesToShow = [];
											if (categoriesThatNeedEndings.includes(wordsToBeUsed[word])) {
												if ((controller.classChoice === "C76" && wordInfo["gal-s"]) || (controller.classChoice === "C75" && wordInfo["fsc-gal"])) {
													if (controller.classChoice === "C76") {
													const pagalbaIndex = {
															"vns": "vns.",
															"dgs": "dgs.",
															"1-a": "Ia.",
															"2-a": "IIa.",
															"3-a": "IIIa.",
															"es-l": "es.l.",
															"b-k-l": "būt.k.l.",
															"b-d-l": "būt.d.l.",
															"būs-l": "būs.l.",
															"vyr-g": "vyr.g.",
															"mot-g": "mot.g.",
													};

													// Assuming wordInfo is provided, e.g., wordInfo = { "vks": true, "dkt": false, "bdv": false }
													if (wordInfo["vks"] === true) {
														if (wordInfo["3-a"] === true) {
															valuesToCheck = ["es-l", "b-k-l", "b-d-l", "būs-l", "3-a"];
														} else {
															valuesToCheck = ["es-l", "b-k-l", "b-d-l", "būs-l", "vns", "dgs", "1-a", "2-a", "3-a"];
														}
															valuesToCheck.forEach(value => {
																	if (wordInfo[value]) {  // If wordInfo has the specific value set to true
																			valuesToShow.push(pagalbaIndex[value]);
																	}
															});
													} else if (wordInfo["dkt"] === true || wordInfo["bdv"] === true) {
															valuesToCheck = ["vns", "dgs"];
															valuesToCheck.forEach(value => {
																	if (wordInfo[value]) {  // If wordInfo has the specific value set to true
																			valuesToShow.push(pagalbaIndex[value]);
																	}
															});
															if (valuesToShow.length === 2) {
																valuesToShow = ["vns.?", "dgs.?"]
															}
															if (wordInfo["prv"] === true) {
																valuesToShow = valuesToShow.map(item => {
																// Check if the item does not already end with '?'
																if (!item.endsWith('?')) {
																	return item + '?';
																}
																return item;
															});
																valuesToShow.push("prv.?")
															}
															if (wordInfo['vyr-g']) {
																valuesToShow.push(pagalbaIndex["vyr-g"]);
															}
															if (wordInfo['mot-g']) {
																valuesToShow.push(pagalbaIndex["mot-g"]);
															}
													}
													} else if (controller.classChoice === "C75") {
														if (wordInfo['g'] === true) {
															valuesToShow.push("ką vieną?")
														} else if (wordInfo['k'] === true) {
															valuesToShow.push("ko daug?")
														} else if (wordInfo['vt'] === true) {
															valuesToShow.push("kur?")
														}
													}

												// Join the results into a single string separated by commas
												const valuesToShowString = valuesToShow.join(', ');
												formattedWord = [`${beforePunctuation}<span class="question-word-span end" style="display: inline; white-space: nowrap;">${wordInfo["gal-c"][0][0][0]}<input type="text" autocapitalize="none" autocomplete="off" id="id-${questionId}" class="question-input end" maxlength="6"> <span class="pagalba-span">(${valuesToShowString})</span>${afterPunctuation}</span>`, wordsToBeUsed[word], `${beforePunctuation}${word}${afterPunctuation}`, false];
												atsakymai[`id-${questionId}`] = {};
												atsakymai[`id-${questionId}`]["klausimas"] = [wordInfo["gal-c"][0][0][0], '']
												atsakymai[`id-${questionId}`]["atsakymas"] = [wordInfo["gal-c"][0][1]];
												atsakymai[`id-${questionId}`]["kl-grupe"] = wordsToBeUsed[word];
												atsakymai[`id-${questionId}`]["zodzio-id"] = id;
												questionId++;
												
												}
											
											} 
											
											if ((controller.classChoice === "C75" && (wordsToBeUsed[word] === "fsc-con" || wordsToBeUsed[word] === "fsc-vow")) ||
												(controller.classChoice === "C76" && wordsToBeUsed[word] === "fsc-vow")
											) {
												removedLetterOptionIndex = {
													"k": ["k", "g"],
													"g": ["k", "g"],
													"p": ["p", "b"],
													"b": ["p", "b"],
													"t": ["t", "d"],
													"d": ["t", "d"],
													"ž": ["ž", "š"],
													"z": ["z", "s"],
													"s": ["z", "s"],
													"š": ["ž", "š"],
													"e": ["e", "ė"],
													"ė": ["e", "ė"],
													"i": ["i", "y"],
													"y": ["i", "y"],
													"u": ["u", "ū"],
													"ū": ["u", "ū"],
												}
												var combinations = wordInfo[`${wordsToBeUsed[word]}-c`];
												if (combinations && combinations.length > 0) {
														let randomIndex = Math.floor(Math.random() * combinations.length);
														let randomElement = combinations[randomIndex];
														if (randomElement[1][0].toLowerCase() in removedLetterOptionIndex) {
															valuesToShow = removedLetterOptionIndex[randomElement[1][0].toLowerCase()];
														}
														const valuesToShowString = valuesToShow.join('/');
														if (wordsToBeUsed[word] === "fsc-vow") {
															formattedWord = [`${beforePunctuation}<span class="question-word-span middle" style="display: inline; white-space: nowrap;">${randomElement[0][0]}<input type="text" autocapitalize="none" autocomplete="off" maxlength="6" id="id-${questionId}" class="question-input middle">${randomElement[2][0]}<span class="pagalba-span">(${valuesToShowString})</span>${afterPunctuation}</span>`, wordsToBeUsed[word], `${beforePunctuation}${word}${afterPunctuation}`, false];
														} else if (wordsToBeUsed[word] === "fsc-con" ) {
															formattedWord = [`${beforePunctuation}<span class="question-word-span middle" style="display: inline; white-space: nowrap;">${randomElement[0][0]}<input type="text" autocapitalize="none" autocomplete="off" maxlength="6" id="id-${questionId}" class="question-input middle">${randomElement[2][0]}<span class="pagalba-span-perm">(${valuesToShowString})</span>${afterPunctuation}</span>`, wordsToBeUsed[word], `${beforePunctuation}${word}${afterPunctuation}`, false];															
														}
														atsakymai[`id-${questionId}`] = {};
														atsakymai[`id-${questionId}`]["klausimas"] = [randomElement[0][0], randomElement[2][0]]
														atsakymai[`id-${questionId}`]["atsakymas"] = [randomElement[1]];
														atsakymai[`id-${questionId}`]["kl-grupe"] = wordsToBeUsed[word];
														atsakymai[`id-${questionId}`]["zodzio-id"] = id;
														questionId++;
													}
											} else {
												var combinations = wordInfo[`${wordsToBeUsed[word]}-c`];
												if (combinations && combinations.length > 0) {
														let randomIndex = Math.floor(Math.random() * combinations.length);
														let randomElement = combinations[randomIndex];
														formattedWord = [`${beforePunctuation}<span class="question-word-span middle" style="display: inline; white-space: nowrap;">${randomElement[0][0]}<input type="text" autocapitalize="none" autocomplete="off" maxlength="6" id="id-${questionId}" class="question-input middle"><span class="pagalba-div"></span>${randomElement[2][0]}${afterPunctuation}</span>`, wordsToBeUsed[word], `${beforePunctuation}${word}${afterPunctuation}`, false];
														atsakymai[`id-${questionId}`] = {};
														atsakymai[`id-${questionId}`]["klausimas"] = [randomElement[0][0], randomElement[2][0]]
														atsakymai[`id-${questionId}`]["atsakymas"] = [randomElement[1]];
														atsakymai[`id-${questionId}`]["kl-grupe"] = wordsToBeUsed[word];
														atsakymai[`id-${questionId}`]["zodzio-id"] = id;
														questionId++;
														
												}
										}
									 } else {
										formattedWord = [`${beforePunctuation}${word}${afterPunctuation}`, "none"];
										}
										if (allowAdjacentEndlessWords) {
											acc.push(formattedWord)
										} else {
											if (acc.length > 0) {
											if ((formattedWord[1] === "bdv" || formattedWord[1] ==="dkt") && (acc[acc.length - 1][1] === "bdv" || acc[acc.length - 1][1] === "dkt") && acc[acc.length - 1][3] === false) {
												if (Math.random() <= 0.5) {
													var temp = acc[acc.length - 1][0]
													acc[acc.length - 1][0] = acc[acc.length - 1][2]
													acc[acc.length - 1][2] = temp
													if (acc.length >= 3) {
													if (acc[acc.length - 2][3] === true) {
														var temp2 = acc[acc.length - 2][0]
														acc[acc.length - 2][0] = acc[acc.length - 2][2]
														acc[acc.length - 2][2] = temp2	
													}
													acc.push(formattedWord)
												} else {
													acc.push(formattedWord)
												}
											 } else {
													// This code will run the other 50% of the time
													var temp = formattedWord[0]
													formattedWord[0] = formattedWord[2]
													formattedWord[2] = temp
													formattedWord[3] = true
													acc.push(formattedWord)
												}
											} else {
												acc.push(formattedWord)
											}
										} else {
											acc.push(formattedWord)
										}

										}
										return acc;
									}, [])
									const output = `<div class="sakiniai">${formattedSentence.map(item => item[0]).join(' ')}</div>`;
									sakiniai.push(output);
									break; // Stop processing further sentences once one has been added
								}
							}
							}
						}
					}
				}
			}
		}

		let answerTrackerElement = document.querySelector('#answer-tracker');
		let stopButtonSpanElement = document.querySelector('#stop-button-span');
		const resetMistakeButtonsElement = document.querySelector('#restart-reset-button-row');

		if (controller.modeChoice4 === "C40") {
			answerTrackerElement.innerHTML = `Atlikta: ${totalSentencesCompleted}/${controller.questionNumber}`;
		}


		function displaySentences() {
			allAnswersCorrect = false;
			currentAnswerAttempts = 0;
			document.getElementById('check-answers').disabled = false;
			document.getElementById('show-answers').style.visibility = "hidden";
			document.getElementById('field-for-final-message').innerHTML = '';
			taskSavingMessageDiv.innerHTML = ''

			if (controller.modeChoice4 === "C39") {
				if (questionsToDisplay > sakiniai.length) {
					assembleAndFormatSentences();
				}
			} else if (controller.modeChoice4 === "C40") {
				if ((controller.questionNumber - totalSentencesCompleted) < questionsToDisplay) {
					questionsToDisplay = controller.questionNumber - totalSentencesCompleted
				}
				totalSentencesCompleted = totalSentencesCompleted + questionsToDisplay
				if (questionsToDisplay > sakiniai.length) {
					assembleAndFormatSentences();
				}
			}

			let subSakiniai = [];

			if (controller.randomSelection.length === 0) {
				// Select random unique indices
				const selectedIndices = new Set();
				while (selectedIndices.size < questionsToDisplay) {
					const randomIndex = Math.floor(Math.random() * sakiniai.length);
					selectedIndices.add(randomIndex);
				}

				// Sort indices in descending order to avoid modifying the list while iterating
				const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);

				// Store selected items in subSakiniai
				for (const index of sortedIndices) {
					subSakiniai.push(sakiniai[index]);
				}

				// Create the remaining sentences by filtering out the selected ones
				const remainingSakiniai = sakiniai.filter((_, index) => !selectedIndices.has(index));
				sakiniai = remainingSakiniai;

				controller.randomSelection = [subSakiniai, atsakymai]
				localStorage.setItem("controller", JSON.stringify(controller));
			} else {
				subSakiniai = controller.randomSelection[0];
				atsakymai = controller.randomSelection[1]
			}

			// Set the inner HTML of the text container
			document.getElementById("field-for-sentences").innerHTML = subSakiniai.join('');

			// Restrict input to Lithuanian letters and spaces for the question inputs
			document.querySelectorAll('.question-input').forEach(input => {
				input.addEventListener('input', function () {
					// Replace any character that isn't a Lithuanian letter or space
					this.value = this.value.replace(/[^a-zA-ZąčęėįšųūžĄČĘĖĮŠŲŪŽ\s]/g, '');
				});
			});
			document.querySelectorAll('input, textarea').forEach(input => {
				input.setAttribute('spellcheck', 'false');
				input.addEventListener('input', () => resizeInput(input));
				resizeInput(input);
			});

			focusFirstInput();

			document.querySelectorAll('.question-input').forEach(input => {
				// Add event listener to remove 'wrong-answer' class on focus
				input.addEventListener('focus', () => {
					input.classList.remove('wrong-answer');
				});
					});

			setupDynamicListeners();

		}

		function toggleHelpButton() {
			const helpButton = document.getElementById("help-button");
			const pagalbaSpans = document.querySelectorAll(".pagalba-span");

			let isAnySpanNonEmpty = Array.from(pagalbaSpans).some(span => span.innerHTML.trim() !== "");

			helpButton.style.visibility = isAnySpanNonEmpty ? "visible" : "hidden";
		}


		function initiateTheProgram() {
			if (!controller.questionsStopped) {
				filterSentenceLibrary();
				assembleAndFormatSentences();
				displaySentences();
				toggleHelpButton();
				helpToggle();

				if (!controller.questionsStopped) {
				if (controller.modeChoice4 === "C39") {
					countDown();
				} else if (controller.modeChoice4 === "C40") {
					startTimer();
				}
				}
			} else {
				formatFinalMessageForGrammar();
			}
	}


		initiateTheProgram();

		function resizeInput(inputElement) {
    // Create a temporary span element to measure the width of the input text
    const span = document.createElement('span');
    const style = window.getComputedStyle(inputElement);

    // Set the span to match the input's styling (same font, padding, etc.)
    span.style.font = style.font;
    span.style.padding = style.padding;
    span.style.margin = style.margin;
    span.style.whiteSpace = 'nowrap'; // Make sure the text does not wrap

    // Set the span's text to the input's current value
    span.textContent = inputElement.value || inputElement.placeholder;

    // Append the span to the document (it will be invisible)
    document.body.appendChild(span);

    // Get the width of the span and update the input width
    const width = span.getBoundingClientRect().width;

    // Remove the temporary span from the document
    document.body.removeChild(span);

		
    if (inputElement.value === '') {
      inputElement.style.width = `1.5ch`; // Dynamic width based on placeholder
    } else {
      inputElement.style.width = `${width+0.25}px`;
    }
  }

// Function to set up listeners for all inputs
function setupDynamicListeners() {
    const inputs = document.querySelectorAll('.question-input');
    const checkAnswersButton = document.getElementById('check-answers');

    inputs.forEach(input => {
        input.addEventListener('input', () => {
            // Recheck inputs with 'wrong-answer' class
            const wrongInputs = document.querySelectorAll('.wrong-answer');
            const modified = [...wrongInputs].some(wrongInput => wrongInput.value.trim() !== "");
            
            // Re-enable the button if any wrong answer has been modified
            checkAnswersButton.disabled = modified;
						if (!modified) {
						warning.style.visibility = "hidden";
						}
        });
    });
}

function recordGrammarMistakes (inputId, userInput) {
	if (!mistakeRecords[inputId]) {
		mistakeRecords[inputId] = {};
		mistakeRecords[inputId] = {
		"mistakesCounter": 0,
		"wrongAnswer": []
		};
	}
	mistakeRecords[inputId]["mistakesCounter"]+=1
	if (mistakeRecords[inputId]["wrongAnswer"].length < 3) {
		mistakeRecords[inputId]["wrongAnswer"].push(userInput);
	}
}

function checkAnswers() {
    const inputs = document.querySelectorAll('.question-input');
    const NumberOfQuestionsInRound = inputs.length;
    const warning = document.getElementById('warning');
    const nextQuestionButton = document.getElementById('next-question');
    const checkAnswersButton = document.getElementById('check-answers');
    warning.style.visibility = "hidden";
    let answersCorrect = true;
    let allFilled = true; // Check if all fields are filled

    checkAnswersButton.disabled = true; // Disable the button initially

    inputs.forEach(input => {
        let inputValue = input.value.trim().toLowerCase();
        if (inputValue === "") {
            allFilled = false; // Mark as not all filled
            warning.innerHTML = "įrašyk visas raides"
            warning.style.visibility = "visible";
            return;
        }
    });

    if (allFilled) {
        inputs.forEach(input => {
            const inputId = input.id;
            let inputValue = input.value.trim();

            // Strip input value of spaces before comparing with the dictionary
            inputValue = inputValue.replace(/\s+/g, '');

            // Compare the stripped value with the corresponding value from atsakymai
			if (atsakymai[inputId] && atsakymai[inputId]["atsakymas"] && atsakymai[inputId]["atsakymas"].some(answerArray => {
				return answerArray.some(answer => inputValue === answer.replace(/\s+/g, ''));
			})) {
				input.classList.add('correct-answer');
				input.classList.remove('wrong-answer');
				input.disabled = true;
				if (firstTimeChecking) {
					totalCorrectAnswers++;
				}
			} else {
				input.classList.add('wrong-answer');
				input.classList.remove('correct-answer');
				answersCorrect = false;
				controller.mistakesTracker+=1;
				recordGrammarMistakes(input.id, inputValue);
			}


            // Show "Next Question" button only if all answers are correct
            nextQuestionButton.style.display = answersCorrect ? "flex" : "none";
            checkAnswersButton.style.display = answersCorrect ? "none" : "flex";
        });

        if (firstTimeChecking) {
            controller.answeredQuestionTracker += NumberOfQuestionsInRound;
			localStorage.setItem('controller', JSON.stringify(controller));
            document.getElementById('mistake-tracker').innerHTML = `Teisingai: ${totalCorrectAnswers}/${controller.answeredQuestionTracker}`;
			localStorage.setItem('controller', JSON.stringify(controller));
        }

        if (answersCorrect) {
            allAnswersCorrect = true;
			if (controller.modeChoice4 === "C40") {
				answerTrackerElement.innerHTML = `Atlikta: ${totalSentencesCompleted}/${controller.questionNumber}`;
			}

			controller.correctAnswerTracker = totalCorrectAnswers

			controller.randomSelection = [];
			localStorage.setItem("controller", JSON.stringify(controller));

        } else {
            currentAnswerAttempts += 1;
            warning.innerHTML = "pataisyk visas klaidas";
            warning.style.visibility = "visible";
        }

        firstTimeChecking = false;

        if (currentAnswerAttempts >= 3) {
            document.getElementById('show-answers').style.visibility = "visible";
        }
    }
}

function showAnswers() {
  const inputs = document.querySelectorAll('.question-input');
  
  // Iterate over each input field
  inputs.forEach(input => {
    const inputId = input.id;
    
    // Ensure that the answer exists in the atsakymai object
    if (atsakymai[inputId]) {
      // Set the value of the input field to the correct answer, stripping spaces
      input.value = atsakymai[inputId]["atsakymas"][0][0].replace(/\s+/g, '');
      resizeInput(input);
    }
  });
  checkAnswers();
}

function helpToggle() {
	const elements = document.querySelectorAll('.pagalba-span');
    
    // Loop through each element and toggle the display property
    elements.forEach(element => {
        if (element.style.display === 'none') {
            element.style.display = 'inline-block'; // Set display to flex if it's none
        } else {
            element.style.display = 'none'; // Set display to none if it's not none
        }
    });
}


			function nextQuestion() {
				if (controller.modeChoice4 === "C40") {
					if (totalSentencesCompleted === controller.questionNumber) {
						localStorage.setItem("elapsedTime", timerDisplay.textContent);
						controller.taskCompleted = true;
						formatFinalMessageForGrammar();
						controller.questionsStopped = true;
						localStorage.setItem('controller', JSON.stringify(controller));
					}
				}
				
				if (!controller.questionsStopped) {
					displaySentences()
					toggleHelpButton();
					document.getElementById('check-answers').style.display = "flex"
					nextQuestionButton.style.display = "none";
					document.querySelectorAll('.pagalba-span').forEach(element => {
					element.style.display = 'none';
					});
					firstTimeChecking = true;
				}
			}

			function stopQuestions() {
				document.getElementById('warning').style.visibility = "hidden";
				if (stopButtonSpanElement.innerHTML === "close") {

					controller.questionsStopped = true;
					clearInterval(timerInterval);
					stopButtonSpanElement.innerHTML = "refresh";
					document.getElementById('check-answers').disabled = true;
					document.getElementById('check-answers').style.display = "inline-block";
					document.getElementById('help-button').disabled = true;
					document.getElementById('next-question').style.display = "none";
					document.getElementById('show-answers').style.visibility = "hidden";

					document.querySelectorAll('.question-input').forEach(input => {
						input.disabled = true;
					});

					resetMistakeButtonsElement.style.display = "flex";
					localStorage.setItem("elapsedTime", timerDisplay.textContent);
					localStorage.setItem('controller', JSON.stringify(controller))
					formatFinalMessageForGrammar();
				} else if (stopButtonSpanElement.innerHTML === "refresh") {
					stopButtonSpanElement.innerHTML = "close";
					controller.questionsStopped = false;
					if (localStorage.getItem("startTime")) {
					localStorage.removeItem("startTime");
					};
					if (localStorage.getItem("remainingTime")) {
					localStorage.removeItem("remainingTime");
					};
					document.getElementById('check-answers').disabled = false;
					document.getElementById('help-button').disabled = false;

					document.getElementById('check-answers').style.display = "inline-block";
					document.getElementById('check-answers').style.visibility = "visible";
					document.getElementById('help-button').style.visibility = "visible";

					document.querySelectorAll('.question-input').forEach(input => {
						input.disabled = false;
					});

					document.getElementById('mistake-tracker').innerHTML = `Teisingai: 0/0`;
					totalSentencesCompleted = 0;
					questionsToDisplay = Number(controller.modeChoice2);
					if (controller.modeChoice4 === "C40") {
						answerTrackerElement.innerHTML = `Atlikta: ${totalSentencesCompleted}/${controller.questionNumber}`;
					}
					firstTimeChecking = true;
					controller.randomSelection = [];
					controller.currentMistakes = [];
					controller.mistakesTracker = 0;
					controller.answeredQuestionTracker = 0;
					totalCorrectAnswers = 0;
					atsakymai = {};
					questionId = 1;
					resetMistakeButtonsElement.style.display = "none";
					localStorage.setItem('controller', JSON.stringify(controller));
					initiateTheProgram();
				}
			}

			function focusFirstInput() {
				const inputs = document.querySelectorAll('input[type="text"].question-input');
				if (inputs.length > 0) {
					inputs[0].focus();
				}
			}

function enableEnterNavigation() {
    // Ensure the event listener is added only once
    document.removeEventListener('keydown', handleEnterKey);
    document.addEventListener('keydown', handleEnterKey);
}

function handleEnterKey(event) {
    if (event.key === 'Enter') {
        event.preventDefault(); // Prevent default behavior like form submission
        const inputs = Array.from(document.querySelectorAll('input[type="text"].question-input'));
        const currentIndex = inputs.indexOf(document.activeElement);

        if (currentIndex !== -1 && currentIndex < inputs.length - 1) {
            // Move to the next input field
            inputs[currentIndex + 1].focus();
				
        } else if (currentIndex === inputs.length - 1) {
            // Autofocus the "check-answers" button when the last input field is reached
            const checkAnswersButton = document.getElementById('check-answers');
            if (checkAnswersButton) {
                checkAnswersButton.focus();
                checkAnswersButton.click(); // Trigger the button click if focused and Enter is pressed
					}
        } else {
					if (allAnswersCorrect) {
							document.getElementById('next-question').focus();
							document.getElementById('next-question').click();
						} 
				}
    }
}

// Call the function after rendering the inputs and button
enableEnterNavigation();

// Add event listener to the button
nextQuestionButton = document.getElementById('next-question')

document.getElementById('check-answers').addEventListener('click', checkAnswers);
document.getElementById('next-question').addEventListener('click', nextQuestion);
document.getElementById('show-answers').addEventListener('click', showAnswers);
document.getElementById('help-button').addEventListener('click', helpToggle);

const stopButtonElement = document.querySelector('.stop-button');
stopButtonElement.addEventListener("click", stopQuestions)

const resetButtonElement = document.querySelector('.reset-button');
resetButtonElement.addEventListener("click", redirectToIndex);

if (controller.questionsStopped) {
	if (localStorage.getItem("elapsedTime") !== null) {
		timerDisplay.textContent = localStorage.getItem("elapsedTime");
	} else {
		timerDisplay.textContent = "00:00:00";
	}
}

window.addEventListener("beforeunload", () => {
	if (!redirectingToAuthentication) {
		controller.taskId = 0;
		controller.taskCompleted = false;
	}
    localStorage.setItem("controller", JSON.stringify(controller));
	localStorage.setItem("elapsedTime", timerDisplay.textContent);
	localStorage.setItem("elapsedTime", timerDisplay.textContent);
});

const mistakesButtonElement = document.querySelector('.summary-button');
	mistakesButtonElement.addEventListener("click", () => {
		localStorage.setItem("elapsedTime", timerDisplay.textContent);
	})
	mistakesButtonElement.addEventListener("click", redirectToSummary);

	mistakesButtonElement.addEventListener("click", () => {
		localStorage.setItem("elapsedTime", timerDisplay.textContent);
	})
	mistakesButtonElement.addEventListener("click", redirectToSummary);

	}).catch(error => {
		console.error('Error in fetching multiple JSON files:', error);
	});
	</script>
</body>

</html>