<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Pixel Art Room</title>
    <link rel="stylesheet" type="text/css" href="../index.css">
    <link rel="stylesheet" href="../main-nav-bar.css">
    <link rel="stylesheet" href="../pet-game-pets.css">
    <link rel="stylesheet" href="../pet-game-items.css">
    <script src="../refresh-token.js"></script>
    <style>

      @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Regular.otf") format("opentype");
        font-weight: 400;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-RegularItalic.otf") format("opentype");
        font-weight: 400;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Light.otf") format("opentype");
        font-weight: 300;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-LightItalic.otf") format("opentype");
        font-weight: 300;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Semibold.otf") format("opentype");
        font-weight: 600;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-SemiboldItalic.otf") format("opentype");
        font-weight: 600;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Bold.otf") format("opentype");
        font-weight: 700;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-BoldItalic.otf") format("opentype");
        font-weight: 700;
        font-style: italic;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-Heavy.otf") format("opentype");
        font-weight: 800;
        font-style: normal;
        }

        @font-face {
        font-family: "SFpro";
        src: url("../fonts/SF-Pro-Text-HeavyItalic.otf") format("opentype");
        font-weight: 800;
        font-style: italic;
        }

        * {
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            box-sizing: border-box;
        }

        html {
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: linear-gradient(to top, #ffbf9c, #ffbf92, #ffbf89, #ffbf7e, #ffc074);
            width: 100vw;
            height: 100svh;
            overflow: hidden;
            user-select: none;         /* Standard */
            -webkit-user-select: none; /* Chrome, Safari, Edge */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE/older Edge */
        }

        body {
            margin: 0;
            font-family: 'SFpro', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* Chrome, Edge, Safari */
        ::-webkit-scrollbar {
        width: 12px;
        }

        ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);  /* translucent track */
        backdrop-filter: blur(6px);            /* frosted blur effect */
        border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.4);  /* semi-transparent thumb */
        backdrop-filter: blur(6px);
        border-radius: 10px;

        /* inset effect */
        border: 3px solid rgba(255, 255, 255, 0.2); 
        background-clip: content-box;
        }

        ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.6);
        }

        /* Firefox (limited support) */
        * {
        scrollbar-width: thin;                         
        scrollbar-color: rgba(255,255,255,0.4) transparent;
        }

        select:focus,
        select:active {
            outline: none;
            border: none;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .room-grid {
            display: grid;
            gap: 0;
            position: relative;
        }

        .tile {
            width: var(--unit-size);
            height: var(--unit-size);
            border: 1px dashed rgba(139, 115, 85, 0.3);
            box-sizing: border-box;
        }

        .tile.wall {
            background-color:  var(--wall-base-color);
        }

        .tile.boundary {
            position: relative;
            border: none;
            background: linear-gradient(
                to bottom,
                var(--wall-base-color) 0%,
                var(--wall-base-color) 60%,
                black 60%,
                black 66%,
                var(--baseboard-base-color) 66%,
                var(--baseboard-base-color) 94%,
                black 94%,
                black 100%
            );
        }

        .tile.boundary::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px dashed rgba(139, 115, 85, 0.3);
            pointer-events: none;
        }

        .tile.floor {
            background-color: var(--floor-base-color);
        }

        .room-object {
            position: absolute;
            cursor: pointer;
            user-select: none;
            touch-action: none;    /* prevents browser scroll/zoom during drag */
        }

        .room-object-edit:hover {
            transform: scale(1.05);
        }

        .room-object-edit.wallpaper:hover {
            transform: scale(1);
        }

        .room-object-edit.flooring:hover {
            transform: scale(1);
        }

        .pet {
            width: var(--pet-size);
            height: var(--pet-size);
            position: absolute;
            cursor: pointer;
            user-select: none;
            z-index: 20;
            touch-action: none;    /* prevents browser scroll/zoom during drag */
        }

        .pet.dragging {
            z-index: 1000 !important;
        }

        .room-object.dragging {
            z-index: 1000 !important;
            cursor: grabbing;
            outline: 2px solid red;
        }

        .pet-left {
        transform: scaleX(1);
        }

        .pet-right {
        transform: scaleX(-1);
        }

        .pet.pet-right:hover {
            transform: scaleX(-1) scale(1.05);
        }

        .pet.pet-left:hover {
            transform: scaleX(1) scale(1.05);
        }

        .message {
            position: fixed;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #F5F5F7;
            padding: 10px 20px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .message.show {
            opacity: 1;
        }

        button {
            padding: 8px 16px;
            margin: 4px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
        }
        .edit { 
            background-color: #3b82f6; color: #F5F5F7; 
        }
        .save { 
            background-color: #16a34a; color: #F5F5F7; 
        }
        .cancel { 
            background-color: #9ca3af; color: #F5F5F7; 
        }

        .hidden { 
            display: none; 
        }

        #roomGridContainer,
        #petContainer,
        #roomObjectsContainer {
            position: absolute;
        }

        #gameContainer {
            flex: 1;
            height: calc(100% - 80px - (2*16px));
            width: calc(100% - (2*16px));
            display: flex;
            background: rgba(255, 255, 255, 0.08);
            margin: 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.1);
        }

        #gameContainer[hidden] {
            display: none !important;
        }

        .game-navigation {
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            height: 100%;
            width: 200px;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.15);
            border-top-left-radius: 20px;
            border-bottom-left-radius: 20px;
        }


        
.game-navigation.mobile .nav-item {
    display: flex;
    flex-direction: column; /* stack icon above label */
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease; /* smooth movement for icon */
    min-width: 17vw;
    min-height: 64px;
    width: 17vw;
    gap: 0.25rem;
    padding: 8px;
}

.game-navigation.mobile .nav-item.active {
    max-width: none;
    max-height: none;
    width: auto;
}

.game-navigation.mobile .nav-item .nav-label {
    opacity: 0;          /* hide label */
    height: 0;           /* remove space */
    overflow: hidden;    
    transition: opacity 0.3s ease, height 0.3s ease; /* animate label */
}

.game-navigation.mobile .nav-item.active .nav-label {
    opacity: 1;          /* show label */
    height: auto;        /* expand to fit */
}

.game-navigation.mobile .nav-item.active .nav-icon {
    transition: transform 0.3s ease;
}



#toggle-edit-save-btn,
.pet-stats-selection-button.active,
.department-btn.active,
.pet-btn.active,
.pet-supply-tab.active,
.pay-tax-btn:not(.paid) {
    border: none;
    /*border: #286D8A 1px solid;*/
}

.use-btn,
.purchase-btn,
.treat-use-btn,
.food-use-btn,
.fill-water-bowl-btn {
    border: none;
    /*border: #32ac93 1px solid;*/
}


#toggle-edit-save-btn,
#cancel-edit-btn,
#end-preview-button,
.pet-stats-selection-button.active,
.pet-btn.active,
.department-btn.active,
.use-btn,
.pet-supply-tab.active,
.purchase-btn,
.item-requires,
.pay-tax-btn,
.pet-delete-btn:hover,
#customConfirmNo,
#customConfirmYes,
.treat-use-btn,
.food-use-btn,
.fill-water-bowl-btn,
.fill-bath-btn  {
  letter-spacing: 0.01em;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  /*box-shadow: 
        0 1px 2px rgba(0, 0, 0, 0.2),
        0 4px 12px rgba(50, 136, 172, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);*/
  position: relative; /* required for :before absolute positioning */
}

#toggle-edit-save-btn::before,
#cancel-edit-btn::before,
#end-preview-button::before,
.pet-stats-selection-button.active::before,
.pet-btn.active::before,
.department-btn.active::before,
.use-btn::before,
.pet-supply-tab.active::before,
.purchase-btn::before,
.item-requires::before,
.pay-tax-btn::before,
.pet-delete-btn:hover::before,
#customConfirmNo::before,
#customConfirmYes::before,
.treat-use-btn::before,
.food-use-btn::before,
.fill-water-bowl-btn::before,
.fill-bath-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 100%);
  border-radius: 20px;
  pointer-events: none;
  transition: background 0.3s ease;
}

#toggle-edit-save-btn::after,
#cancel-edit-btn::after,
#end-preview-button::after,
.pet-stats-selection-button.active::after,
.pet-btn.active::after,
.department-btn.active::after,
.use-btn::after,
.pet-supply-tab.active::after,
.purchase-btn::after,
.item-requires::after,
.pay-tax-btn::after,
.pet-delete-btn:hover::after,
#customConfirmNo::after,
#customConfirmYes::after,
.treat-use-btn::after,
.food-use-btn::after,
.fill-water-bowl-btn::after,
.fill-bath-btn::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 20px;
  padding: 1px;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
}

#toggle-edit-save-btn:hover::before,
#cancel-edit-btn:hover::before,
#end-preview-button:hover::before,
.pet-stats-selection-button.active:hover::before,
.pet-btn.active:hover::before,
.use-btn:hover::before,
.purchase-btn:hover::before,
.item-requires:hover::before,
.pay-tax-btn:hover::before,
#customConfirmNo:hover::before,
#customConfirmYes:hover::before,
.treat-use-btn:hover::before,
.food-use-btn:hover::before,
.fill-water-bowl-btn:hover::before,
.fill-bath-btn:hover::before {
  background: rgba(255, 255, 255, 0.15);
}




        .nav-items {
            display: flex;
            padding: 16px;
            padding-top: 32px;
            flex-direction: column;
            gap: 0.75rem;
        }

        .nav-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 1rem 0.75rem;
            border: none;
            background: transparent;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            color: #4b5563;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            color: #212529;
            overflow: hidden;
        }

        .nav-item:focus {
            outline: none;
        }

        .nav-item.active {
            background: linear-gradient(135deg, #A0C58F, #32ac93) !important;
            color: #F5F5F7;
             /*box-shadow: 
                    0 1px 2px rgba(0, 0, 0, 0.2),
                    0 4px 12px rgba(50, 136, 172, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);*/
                        
        }

        .game-navigation:not(.mobile) .nav-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .game-navigation:not(.mobile) .nav-item:hover:before {
            left: 100%;
        }

        .game-navigation:not(.mobile) .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }

        .nav-icon {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            position: relative;
        }

        .nav-icon img {
            width: 24px; 
            height: 24px;
        }

        #game-content {
            flex: 1;
            overflow: auto;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 25px;
            margin-right: 10px;
        }
        
        #content-outer-container,
        #pet-room-container {
            min-height: 100%;
        }

        #pet-room-container {
            margin-top: auto;
            margin-bottom: auto;
            align-items: center;
            justify-content: center;
        }

        #content-outer-container {
            display: flex;
            align-items: start;
            justify-content: center;
        }

        #game-panel {
            margin: 20px 0;
        }

        #room-container {
            position: relative;
        }

        #room-container.dark::after {
            content: "";
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* semi-transparent dark */
            z-index: 100; /* on top of room content */
            pointer-events: all; /* blocks clicks if needed */
        }

        .game-content-panel {
            display: none;
            width: 100%;
            min-height: 100%;
            box-sizing: border-box;
        }

        .game-content-panel.active {
            display: flex;
            flex-direction: column;
        }

        #gameContainer.mobile {
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .game-navigation.mobile {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            z-index: 1000;
            border-radius: 0;
            background: #ffbf9c;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-right: 0;
        }

        .game-navigation.mobile .nav-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 8px;
            flex-direction: row;
            gap: 0;
        }

        #game-content.mobile {
            overflow-y: scroll;
        }

        #button-container {
            margin-top: 1svh;
        }

        #toggle-edit-save-btn,
        #cancel-edit-btn,
        #end-preview-button {
            align-items: center;
            gap: 0.5rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            border: none;
            /*border: 1px solid #32ac93;*/
            margin-left: 0;
            padding: 10px 16px
        }

        #toggle-edit-save-btn.edit {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            border: none;
            /*border: 1px solid #286D8A;*/
        }

        #cancel-edit-btn,
        #end-preview-button {
            background: linear-gradient(135deg, #ff8073, #e74c3c);
            border: none;
            /*border: 1px solid #e74c3c;*/
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .shop-header h2 {
            color: #212529;
            margin: 0;
            font-size: 2rem;
            font-weight: 800;
            margin: 3px 0;
        }
        

        .coin-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            background: #ffc074;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 2px 8px 2px 4px;
            border-radius: 15px;
            font-weight: 600;
            color: #92400e;
        }

        .coin-icon {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .coin-icon img {
            width: 34px;
            height: 34px;
        }

        .owned-badge-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .owned-badge-icon img {
            width: 14px;
            height: 14px;
        }

        .item-price-coin-icon {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .item-price-coin-icon img {
            width: 24px;
            height: 24px;
        }

        .item-description-icon {
            height: 20px;
            width: 20px;
        }

        .tax-price img {
            width: 32px;
            height: 32px;
        }

        .shop-categories-dropdown select,
        #pet-category-select {
            padding: 12px 16px;
            font-size: 1rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 150px;
            text-align: center;
            cursor: pointer;
        }

        .shop-items,
        .object-assets,
        #pet-skins,
        #pet-supplies {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }

 
        .food-options-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .no-item-message,
        .no-supplies-message {
            font-style: italic;
        }

        .food-item {
            display: flex;
            flex-wrap: wrap; 
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 20px;
            border: 1px solid #e9ecef;
            justify-content: space-between;
        }

        .food-item-preview-holder {
        width: 40px;
        height: 40px;
        background: #dee2e6;
        border-radius: 6px;
        flex-shrink: 0;
        }

        .food-item-preview-text-holder {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 15px;
            align-items: center;
            line-height: 1;
        }

        .food-item-quant-btn-holder {
            display: flex;
            flex-direction: row;
            flex: 1;
            gap: 15px;
            justify-content: end;
            align-items: center;
        }

        .food-item-name-description-holder {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .food-item-description {
            color: #6b7280;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            margin-top: 2px;
        }

        .food-item-name {
            font-size: 16px;
            font-weight: 500;
            margin: 0;
            color: #212529;
        }

        .item-quantity {
            font-weight: 400;
            color: #666;
            font-size: 14px;
        }

        .food-quantity-input {
            width: 60px;
            height: 20px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 1);
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }

        .shop-item {
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0px 1px 4px rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            transition: all 0.2s;
            align-items: center;
            justify-content: space-between;
            display: flex;
            flex-direction: column;
        }

        .purchase-btn,
        .use-btn {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            color: #F5F5F7;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            width: 60%;
            height: 40px;
        }

        .food-use-btn,
        .treat-use-btn {
            align-items: center;
            gap: 0.5rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            color: #F5F5F7;
            margin-left: 0;
            padding: 10px 16px;
        }

        .department-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .department-icon img {
            height: 24px;
            width: 24px;
        }

        .purchase-btn.owned,
        .use-btn.used,
        .use-btn.equipped,
        .pay-tax-btn.paid {
            background: #6b7280;
            color: #F5F5F7;
            cursor: not-allowed;
            transform: translateY(0px) !important;
            border: none;
            /*border: 1px solid #6b7280;*/
        }

        .purchase-btn.owned:hover::before,
        .use-btn.used:hover::before,
        .use-btn.equipped:hover::before,
        .pay-tax-btn.paid:hover::before {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 100%);
        }

        .pet-supply-use-quantity-holder {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }

        .item-requires {
            padding: 6px 12px;
            background: #10b981;
            background: #6b7280;
            color: #F5F5F7;
            cursor: not-allowed;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 40px;
            min-width: 60%;
            font-size: 1rem;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .owned-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #40c9a9, #32ac93);
            color: #F5F5F7;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            border: 2px solid #F5F5F7;
            z-index: 9999;
        }

        .item-preview-holder {
            position: relative;
            width: 125px;
            height: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgb(210, 180, 140);
            padding: 10px;
            border-radius: 10px;
        }

        .food-item-preview-holder {
            position: relative;
            width: 62.5px;
            height: 37.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgb(210, 180, 140);
            padding: 2px;
            border-radius: 10px;
        }

        .item-preview {
            background-size: contain; /* or cover, depending on behavior */
            background-position: center;
            max-height: 100%;
            max-width: 100%;
        }

        .item-preview.pet {
            background-size: calc(var(--pet-size) * 16) calc(var(--pet-size)*26); /* 16 number of columns in iamge, 25 number of rows*/
            background-position: 0 0;
        }

        #furniture-container,
        #shop-container,
        #taxes-container,
        #pet-asset-container {
            padding: 30px;
        }

        .department-btn.active,
        .pet-supply-tab.active {
            background: linear-gradient(135deg, #3288AC, #286D8A) !important;
            border: none;
            /*border: 1px solid #286D8A;*/
            transform: translateY(0px) !important;
            color: #F5F5F7;
        }
        
        .item-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #1f2937;
            margin: 0 0 0.5rem 0;
            text-align: center;
        }

        .item-description {
            color: #6b7280;
            font-size: 0.9rem;
            margin: 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .item-price {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            font-weight: bold;
            color: #92400e;
            text-align: center;
        }

        .item-price-and-quantity {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 12px;
        }

        .categories-dropdown-holder {
            margin-bottom: 28px;
        }


        @keyframes draw {
        0% {
            stroke-dashoffset: 1000;
        }
        100% {
            stroke-dashoffset: 0;
        }
        }

        .tick {
            fill: none;
            stroke: #F5F5F7;
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 24; /* length of path */
            stroke-dashoffset: 24;
        }

        .tick.draw {
        animation: draw 0.5s ease forwards;
        }

        @keyframes draw {
        to {
            stroke-dashoffset: 0;
        }
        }

        .summary-card {
            background: #F5F5F7;
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            padding: 1.5rem;
        }

        .summary-card h3 {
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: #f9fafb;
            border-radius: 6px;
        }

        .stat-value.owed {
            color: #ef4444;
        }

        .tax-records h3 {
            color: #1f2937;
            margin: 0 0 1rem 0;
        }

        .info-card h4 {
            display: flex;
            align-items: center;
            margin-bottom: 0;
        }

        .info-card p {
            margin-top: 8px;
        }

        .records-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .tax-record {
            background: #F5F5F7;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 15px 25px 15px 20px;
            margin: 0;
            border: 1px solid #F5F5F7;
        }

        .record-info {
            flex: 1;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            color: #F5F5F7;
            background-color: #f59e0b;
        }

        .tax-record.pending {
            border-left: 4px solid #f59e0b;
            border-color: #f59e0b;
            background: #f7e5be;
        }

        .tax-record.paid {
            border-left: 4px solid #10b981;
            border-color: #10b981;
            background: #d1edd4;
        }

        .tax-record.overdue {
            border-left: 4px solid #ef4444;
            border-color: #ef4444;
            background: #f7dfda;
        }

        .record-actions {
            display: flex;
            justify-content: center;
        }

        .pay-tax-btn {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            color: #F5F5F7;
            border: none;
            padding: 12px 18px;
            border-radius: 20px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            min-width: 120px;
            margin: 0;
        }

        .pay-tax-btn:active {
            transform: translateY(0);
        }

        .record-type {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 8px;
        }

        .type-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 35px;
            height: 35px;
            border-radius: 20px;
            background-color: #dbeafe;
            flex-shrink: 0;
        }

        .type-name {
            font-weight: 600;
            font-size: 1.25rem;
            color: #1e293b;
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .tax-info {
            margin-top: 20px;
        }

        #days-remaining-water,
        #days-remaining-electricity {
            color: #e74c3c;
            font-size: 1rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .record-details {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }

        .record-date {
            color: #64748b;
            font-size: 1rem;
        }

        .record-amount {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            font-size: 18px;
            color: #92400e;
        }

        .tax-status-and-pay-btn-holder {
            display: flex;
            flex-direction: row;
            justify-content: end;
            align-items: center;
            gap: 15px;
        }

        .record-status {
            display: flex;
            justify-content: center;
        }

        .shop-departments,
        .pet-asset-supply-tabs {
            display: flex;
            margin-bottom: 16px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .pet-supplies-tabs {
            display: flex;
            margin-bottom: 20px;
            gap: 10px;
            flex-wrap: wrap;
        }

        .department-btn,
        .pet-supply-tab {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 12px 18px 12px 18px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: background, transform 0.3s ease;
            margin: 0;
        }

        .pet-asset-supply-button,
        .pet-supply-tab {
            padding: 8px 14px 8px 12px;
        }

        .department-btn:hover,
        .pet-supply-tab:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .pet-btn {
            width: 90px;
            height: 90px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            transition: all 0.3s ease;
            margin: 0;
        }

        .pet-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .pet-preview {
            position: static;
            height: 75px;
            width: 75px;
            background-size: calc(75px * 16) calc(75px * 26);
        }

        .pet-btn.active {
                background: linear-gradient(135deg, #3288AC, #286D8A) !important;
        }

        #pet-list-shop,
        #pet-list-owned {
            flex: 1 1 auto;
            display: flex;
            flex-direction: row;
            margin-bottom: 16px;
            gap: 10px;
        }

        #pet-asset-buttons-departments-dropdown {
            display: flex;
            flex-direction: column;
            justify-content: end;
            align-items: start;
            flex: 0 0 auto;
        }

        /* Hide both checkboxes */
        #shop-not-owned-toggle,
        #object-usage-toggle,
        .pet-on-walk-toggle {
            height: 0;
            width: 0;
            visibility: hidden;
        }

        .item-description-icons {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
            gap: 4px;
        }

        .food-item .item-description-icons {
            justify-content: start;
        }

        /* Base switch style */
        #object-usage-toggle + span {
            cursor: pointer;
            width: 60px;
            height: 30px;
            background: grey;
            display: inline-block;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: 0.3s;
        }

        /* Knob */
        .pet-on-walk-toggle + span:after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: #F5F5F7;
            border-radius: 50%;
            transition: 0.3s;
        }

        #object-usage-toggle + span:after,
        #shop-not-owned-toggle + span:after {
            content: '';
            position: absolute;
            top: 3px;
            left: 4px;
            width: 29px;
            height: 29px;
            background: #F5F5F7;
            border-radius: 50%;
            transition: 0.3s;
        }

        .switch-slider,
        .shop-not-owned-toggle {
            margin-left: 0 !important;
        }

        .shop-not-owned-holder,
        .object-usage-toggle-holder {
            display: flex;
            align-items: center;
        }

        .shop-categories-dropdown select {
            width: 150px;
        }

        .pet-on-walk-toggle:checked + span:after {
            left: calc(100% - 3px);
            transform: translateX(-100%);
        }

        #object-usage-toggle:checked + span:after,
        #shop-not-owned-toggle:checked + span:after {
            left: calc(100% - 5px);
            transform: translateX(-100%);
        }

        /* Active animation */
        #shop-not-owned-toggle:active + span:after,
        #object-usage-toggle:active + span::after {
            width: 28px;
        }

        .pet-on-walk-toggle + span {
            cursor: pointer;
            width: 95px;
            height: 30px;
            background: rgba(33, 37, 41, 0.5);
            display: inline-block;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .shop-not-owned-toggle + span {
            cursor: pointer;
            width: 115px;
            height: 35px;
            background: rgba(33, 37, 41, 0.5);
            display: inline-block;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: width 0.3s ease, background 0.3s ease;
        }

        #object-usage-toggle + span {
            cursor: pointer;
            width: 118px;
            height: 35px;
            background: rgba(33, 37, 41, 0.5);
            display: flex;
            justify-content: end;
            align-items: center;
            border-radius: 30px;
            position: relative;
            margin-left: 10px;
            vertical-align: middle;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .shop-not-owned-toggle + .switch-slider {
            display: flex !important;
            justify-content: end;
            align-items: center;
        }

        .pet-on-walk-toggle + .switch-slider {
            display: flex !important;
            justify-content: end;
            align-items: center;
        }

        .switch-text {
            margin-right: 9px;
            color: #F5F5F7;
        }

        .switch,
        #pet-on-walk-checkbox-holder {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pet-on-walk-toggle:checked + span {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            width: 60px;
        }

        .shop-not-owned-toggle:checked + span {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            width: 70px;
        }

        #object-usage-toggle:checked + span {
            background: linear-gradient(135deg, #3288AC, #286D8A);
            width: 70px;
        }

        .modern-popup {
            position: fixed;
            top: 10vh;
            right: 20px;
            z-index: 10000;
            width: 90vw;
            max-width: 400px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            background-color: #F5F5F7;
            animation: slideInRight 0.3s ease-out;
        }

        .modern-popup.error {
            background: linear-gradient(145deg, rgba(220, 38, 38, 0.95), rgba(185, 28, 28, 0.95));
            color: #F5F5F7;
        }

        .modern-popup.success {
            background: linear-gradient(145deg, rgba(34, 197, 94, 0.95), rgba(22, 163, 74, 0.95));
            color: #F5F5F7;
        }

        .popup-content {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            gap: 12px;
        }

        .popup-icon {
            flex-shrink: 0;
            opacity: 0.9;
        }

        .popup-message {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            line-height: 1.4;
        }

        .popup-close {
            background: none;
            border: none;
            color: currentColor;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .popup-close:hover {
            opacity: 1;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }



#tax-indicator {
    position: absolute;
    height: 10px;
    width: 10px;
    border-radius: 10px;
    right: 0;
    bottom: 0;
}

.stats-bar-outer {
    display: flex;
    align-items: center;
}

.stats-bar-icon {
    margin-right: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.stats-icon {
    height: 24px;
    width: 24px;
}

 .pet-stats-bars {
    width: 250px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin: 5px 0 2svh 0;
  }

  .stat-bar {
    display: flex;
    border: 2px solid #212529;
    border-radius: 20px;
    height: 20px;
    box-sizing: border-box;
    gap: 2px;
    overflow: hidden;
  }

  .segments {
    display: flex;
    flex-direction: row;
    margin: 0 -21px 0 0 ;
    width: 400px;
    justify-content: center;
    align-items: center;
  }

  .segment {
    flex: 1;
    background: transparent;
    border: 0.5px solid rgba(33, 37, 41, 0.5);
    height: 101%;    
  }


  .pet-stats-selection-button {
    background-color: transparent;
    border: rgba(33, 37, 41, 0.5) 1px solid;
  }

  .pet-stats-selection-button.active {
    background: linear-gradient(135deg, #3288AC, #286D8A);
    border: none;
    /*border: #286D8A 1px solid;*/
    color: #F5F5F7;
  }

  .pet-stats-selection-button-text {
    position: relative;
  }

  .pet-stats-selection-button-indicator {
    position: absolute;
    width: 7px;
    height: 7px;
    border-radius: 25px;
    background: linear-gradient(135deg, #ff8073, #e74c3c);
    right: -7px;
    top: -2px;
    display: none;
  }

  .modal {
  display: none; /* hidden by default */
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.5);
  justify-content: center;
  align-items: center;
  z-index: 9999;
}

.modal-content {
  background: #F5F5F7;
  padding: 20px 30px;
  border-radius: 10px;
  text-align: center;
  max-width: 300px;
  width: 80%;
}

.modal-buttons {
  margin-top: 15px;
  display: flex;
  justify-content: space-around;
}

.btn-confirm {
  font-size: 1rem;
  background: linear-gradient(135deg, #ff8073, #e74c3c);
  color: #F5F5F7;border: none;
  /*border: 1px solid #e74c3c;*/
}

.btn-cancel {
  font-size: 1rem;
  background: linear-gradient(135deg, #95a5a6, #aeb4b5);
  color: #F5F5F7;
  border: none;
  /*border: 1px solid #95a5a6;*/
}

.item-delete-btn-holder {
    background: linear-gradient(135deg, #ff8073, #e74c3c);
    border-radius: 50%;
    z-index: 1000;
    position: absolute;
    top: -5px;
    right: -5px;
    width: 30px;
    height: 30px;
    display: flex;
    justify-content: center;
}

.item-delete-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 18px;
    padding: 0;
}

.pet-section-pet-button-container {
    display: flex;
    flex-direction: column;
    width: 90px;
}

.pet-name-field {
    background-color: #F5F5F7;
    font-size: 1.5rem;
    border: none;
    width: auto;
    min-width: 1ch;   /* at least 1 character wide */
    max-width: 10ch;  /* no wider than 10 characters */
}

.pet-name-field:focus,
.pet-name-field:active {
    border: none;
    outline: none;
}

.edit-name-button {
    background-color: transparent;
    padding: 8px;
}

.edit-icon img {
    height: 18px;
    width: 18px;
}

.pet-delete-btn {
    width: 90px;
    background: transparent;
    border: rgba(33, 37, 41, 0.5) 1px solid;
    border-radius: 20px;
    margin: 0 0 5px 0;
    transition: all 0.2s;
}

.pet-delete-btn:hover,
.pet-delete-btn:active {
    background: linear-gradient(135deg, #ff8073, #e74c3c);
    border: 1px solid transparent;
    /*border: #e74c3c 1px solid;*/
    color: #F5F5F7;
}

.title-subtitle-inline-button-wrapper {
    display: flex;
    flex-direction: row;
    align-items: center;
}

.water-bowl-options-container,
.bath-options-container {
    display: flex;
    justify-content: end;
}

.fill-water-bowl-btn,
.fill-bath-btn {
    align-items: center;
    gap: 0.5rem;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 1rem;
    background: linear-gradient(135deg, #40c9a9, #32ac93);
    color: #F5F5F7;
    margin: 0;
    padding: 10px 16px;
}

#pet-asset-buttons,
#shop-buttons {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: flex-end;
  gap: 10px;
}

.categories-dropdown-holder {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  gap: 10px;
}

#pet-buttons-outer {
    display: flex;
    width: 100%;
    flex-direction: row;
    justify-content: space-between;
}

.pet-on-walk-holder {
    display: flex;
    flex-direction: column;
}

.furniture-preview-button {
    border: 2px solid #F5F5F7;
    background: linear-gradient(135deg, #3288AC, #286D8A);
    padding: 0;
    width: 30px;
    height: 30px;
    position: absolute;
    top: -14px;
    right: -14px;
    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
}

.furniture-preview-button svg {
    height: 20px;
    width: 20px;
    color: #F5F5F7
}

.item-info {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.purchase-quantity-holder {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 1);
}

.purchase-quantity,
.pet-supply-use-quantity,
.food-quantity-input {
    width: 26px;              /* fixed width */
    height: 30px;             /* fixed height */
    padding: 0;               /* remove internal padding */
    border: none;
    text-align: center;       /* horizontally center text */
    line-height: 30px;        /* vertically center text */
    font-size: 1rem;
    box-sizing: border-box;   /* include border in width/height */
    -moz-appearance: textfield;  /* remove spinner in Firefox */
}

.purchase-quantity::-webkit-outer-spin-button,
.purchase-quantity::-webkit-inner-spin-button,
.pet-supply-use-quantity::-webkit-outer-spin-button,
.pet-supply-use-quantity::-webkit-inner-spin-button,
.food-quantity-input::-webkit-outer-spin-button,
.food-quantity-input::-webkit-inner-spin-button {
    -webkit-appearance: none; /* remove spinner in Chrome/Safari */
    margin: 0;
}

.control-btn {
    height: 20px;
    width: 20px;
}

/* GIFT CSS START */

.preview-outer {
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

.preview {
  width: 120px;
  height: 120px;
  position: relative;
  margin-top: 10px;
}

/* Gift box pop-out */
.gift-box {
  width: calc(var(--unit-size) * 4);
  height: calc(var(--unit-size) * 4);
  background-repeat: no-repeat;
  background-size: cover;
  border-radius: 8px;
  animation: fadeOut 0.3s forwards 1.2s;
  position: absolute;
  top: 0;
  left: 0;
}

@keyframes fadeOut {
  to { opacity: 0; transform: scale(0.8); }
}

/* Item preview pop-in */
.gift-preview-holder {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transform: scale(0.5);
  animation: revealPreview 0.6s ease-out forwards 1.3s;
  background-color: transparent !important;
  padding: 0 !important;
}

@keyframes revealPreview {
  0% { opacity: 0; transform: scale(0.5); }
  60% { opacity: 1; transform: scale(1.2); }
  80% { transform: scale(0.9); }
  100% { opacity: 1; transform: scale(1); }
}

.gift-preview {
  width: 100px;
  height: 100px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  text-align: center;
  font-size: 0.9rem;
}

/* GIFT CSS END */


@media (max-width: 1024px) {
    .nav-item {
        font-size: 0.9rem;
    }
}


@media (max-width: 767px) {
    #gameContainer {
        margin: 0;
        width: 100%;
        border-radius: 0;
        background: none;
    }

    .main-navbar {
        box-shadow: none;
    }
    
    #game-content {
        margin-right: 0;
        border-radius: 0;
    }

    #content-outer-container {
        min-height: 0;
        height: calc(100% - 81px);
        overflow-y: scroll;
    }

    #pet-room-container {
        height: auto;
        justify-content: start;
    }

    .game-content-panel.mobile {
        padding: 15px 15px !important;
    }

    .shop-header {
        padding: 20px;
    }

    #game-panel {
        margin: 0;
    }

    .pet-stats-bars {
        width: 200px;
    }

    .stat-bar {
        height: 16px;
    }

    .segments {
        margin: 0 -16px 0 0;
    }

    .pet-supply-tab,
    .pet-asset-supply-button {
        padding: 8px 14px 8px 12px;
    }

    #pet-category-select,
    .shop-categories-dropdown select {
        padding: 8px 8px;
    }
}

@media (max-width: 578px) {
    .pet-section-pet-button-container,
    .pet-delete-btn {
        width: 85px;
    }

    #pet-list-owned {
        gap: 10px;
    }

    .pet-btn {
        width: 85px;
        height: 85px;
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 0 10px;
    }

    .pet-preview {
        position: static;
        height: 70px;
        width: 70px;
        background-size: calc(70px * 16) calc(70px * 26);
    }

    .shop-header h2 {
        font-size: 1.65rem;
    }

    .coin-display {
        gap: 3px;
        font-size: 0.9rem;
        padding: 4px 8px 4px 6px;
    }

    .item-price-coin-icon .coin-icon img {
        width: 28px;
        height: 28px;
    }

    .tax-record {
        padding: 10px 15px 10px 15px;
    }

    #days-remaining-water,
    #days-remaining-electricity  {
        font-size: 0.9rem;
    }

    .record-type {
        margin-bottom: 12px;
    }

    .type-name {
        font-size: 1.15rem;
    }

    .record-date {
        font-size: 0.9rem;
    }

    .status-badge {
        font-size: 0.85rem;
        padding: 5px 9px;
    }

    .record-amount {
        font-size: 1rem;
    }

    .record-details {
        margin-bottom: 20px;
    }

    .pay-tax-btn {
        padding: 8px 16px 8px 16px;
        min-width: 100px;
    }

    .pet-stats-bars {
    margin-left: 8px;
  }

  #button-container {
    padding-left: 8px;
  }

  #pet-buttons {
    margin-left: 4px;
  }
    
}


@media (min-device-width: 768px) and (max-device-width: 1200px) and (orientation: portrait)  {
.game-navigation {
    min-height: 116px;
}

.game-navigation .nav-item {
    display: flex;
    flex-direction: column; /* stack icon above label */
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease; /* smooth movement for icon */
    min-width: 17vw;
    min-height: 100px;
    width: 17vw;
    gap: 0.25rem;
    padding: 8px;
}

.game-navigation img {
    width: 42px;
    height: 42px;
}

.game-navigation .nav-item.active {
    max-width: none;
    max-height: none;
    width: auto;
}

.game-navigation .nav-item .nav-label {
    opacity: 0;          /* hide label */
    height: 0;           /* remove space */
    overflow: hidden;    
    transition: opacity 0.3s ease, height 0.3s ease; /* animate label */
}

.game-navigation .nav-item.active .nav-label {
    font-size: 1.5rem;
    opacity: 1;          /* show label */
    height: auto;        /* expand to fit */
}

.game-navigation .nav-item.active .nav-icon {
    transition: transform 0.3s ease;
}

 .game-navigation:not() .nav-item:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
        }

        .game-navigation:not() .nav-item:hover:before {
            left: 100%;
        }

        .game-navigation:not() .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(4px);
        }
 #gameContainer {
            flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .game-navigation {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            z-index: 1000;
            border-radius: 0;
            background: #ffbf9c;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-right: 0;
        }

        .game-navigation .nav-items {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 8px;
            flex-direction: row;
            gap: 0;
        }

        #game-content {
            overflow-y: scroll;
        }
  .game-content-panel {
        padding: 35px !important;
    }

  #gameContainer {
        margin: 0;
        width: 100%;
        border-radius: 0;
        background: none;
    }

    #game-content {
        margin-right: 0;
        border-radius: 0;
    }

    #content-outer-container {
        min-height: 0;
        height: calc(100% - 116px);
        overflow-y: scroll;
    }

    #pet-room-container {
        height: calc(100% - 116px);
    }

    .game-content-panel.mobile {
        padding: 20px 15px !important;
    }

    .shop-header h2 {
        font-size: 2.75rem;
    }

    .coin-display {
        gap: 6px;
        font-size: 1.5rem;
        padding: 8px 16px 8px 12px;
    }

    .coin-icon img {
        width: 48px;
        height: 48px;
    }

    #pet-list-owned {
        gap: 10px;
    }

    .pet-section-pet-button-container {
        width: auto;
    }

    .pet-btn {
        width: 110px;
        height: 110px;
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 0 10px;
    }

    .pet-preview {
        position: static;
        height: 90px;
        width: 90px;
        background-size: calc(90px * 16) calc(90px * 26);
    }

    .pet-delete-btn {
        width: 110px;
        font-size: 1.25rem;
        padding: 8px 0;
    }

    .modal-content {
        max-width: 500px;
        font-size: 1.5rem;
    }
    
    .btn-confirm,
    .btn-cancel {
        font-size: 1.5rem;
    }

    .department-btn {
        font-size: 1.5rem;
    }

    #pet-category-select {
        font-size: 1.5rem;
    }

    .item-name {
        font-size: 1.65rem;
    }

    .item-description,
    .pet-supply-use-quantity-label,
    .item-price span {
        font-size: 1.35rem;
    }

    .use-btn,
    .purchase-btn {
        font-size: 1.25rem;
        height: 50px;
    }

    #game-panel {
        margin: 0;
    }

    .pet-stats-selection-button,
    #toggle-edit-save-btn, 
    #cancel-edit-btn,
    #end-preview-button {
        font-size: 1.5rem;
    }

    .stats-icon {
        height: 32px;
        width: 32px;
    }

    .stat-bar {
        height: 25px;
    }

    .pet-stats-bars {
        width: 300px;
    }

  .segments {
    margin: 0 -25px 0 0 ;
    width: 400px;
  }

  .pet-on-walk-toggle + span {
    height: 40px;
    width: 120px;
  }

  #shop-not-owned-toggle + span {
    height: 48px;
    width: 150px;
  }

  #object-usage-toggle + span {
    height: 48px;
    width: 150px;
  }

  #object-usage-toggle:checked + span {
    width: 100px;
  }

  #shop-not-owned-toggle:checked + span {
    width: 100px;
  }

  .pet-on-walk-toggle + span:after {
    top: 4px;
    left: 5px;
    width: 32px;
    height: 32px;
  }

    #object-usage-toggle + span:after, 
    #shop-not-owned-toggle + span:after {
        top: 4px;
        left: 6px;
        width: 40px;
        height: 40px;
    }

  .pet-on-walk-toggle:checked + span {
    width: 80px;
  }

  .switch-text {
    font-size: 1.25rem;
  }

  :root {
    --unit-size: 30px;
    --original-unit-size: 30px;
    }

    .pet-supply-tab,
    #shop-category-select,
    #object-category-select {
        font-size: 1.5rem;
    }

    .no-matching-supplies-message {
        font-size: 1.5rem;
    }

    .tax-records h3 {
        font-size: 2rem;
    }

    .type-icon {
        width: 45px;
        height: 45px;
    }

    .department-icon img {
        height: 32px;
        width: 32px;
    }

    .type-name {
        font-size: 1.75rem;
    }

    #days-remaining-water, 
    #days-remaining-electricity {
        font-size: 1.25rem;
    }

    .record-date {
        font-size: 1.35rem;
    }

    .status-badge {
        font-size: 1.15rem;
    }

    .pay-tax-btn  {
        font-size: 1.5rem;
        min-width: 150px;
    }

    .record-amount {
        font-size: 1.5rem;
    }

    .tax-info {
        font-size: 1.5rem;
    }

    .food-item-preview-holder {
        width: 120px;
        height: 65px;
    }

    .food-item-name-description-holder {
        min-width: 60%;
    }

    .food-item-name  {
        font-size: 1.35rem;
    }

    .item-quantity {
        font-size: 1.25rem;
    }

    .food-item-description {
        font-size: 1.15rem;
    }

    .food-quantity-input {
        height: 25px;
        font-size: 1.25rem;
    }

    .food-use-btn,
    .fill-water-bowl-btn,
    .fill-bath-btn
    .treat-use-btn {
        font-size: 1.25rem;
    }
}


    </style>
</head>
<body>
    <svg xmlns="http://www.w3.org/2000/svg" style="display:none;">

    <!-- water -->
    <symbol id="icon-water" viewBox="0 0 96 96">
        <g id="#64b5f6ff">
        <path fill="#64b5f6" opacity="1.00" d=" M 31.99 30.18 C 37.16 20.67 42.35 11.12 48.76 2.36 C 57.73 16.77 66.41 31.44 73.22 47.02 C 75.73 53.04 78.30 59.36 77.93 66.02 C 77.36 80.86 63.97 94.12 49.01 94.00 C 34.73 94.56 21.39 82.98 19.35 68.95 C 18.54 64.10 19.31 59.13 20.90 54.51 C 23.77 46.05 27.87 38.08 31.99 30.18 M 32.58 60.24 C 30.46 61.20 30.05 63.76 30.31 65.83 C 31.20 73.29 36.80 80.25 44.24 81.99 C 46.29 82.46 48.53 82.66 50.54 81.85 C 52.86 81.00 53.70 77.84 52.41 75.83 C 49.30 73.28 45.05 72.63 42.00 70.02 C 39.91 67.10 39.05 63.50 37.13 60.48 C 35.89 59.36 33.97 59.48 32.58 60.24 Z" />
        </g>
        <g id="#bbdefbff">
        <path fill="#bbdefb" opacity="1.00" d=" M 32.58 60.24 C 33.97 59.48 35.89 59.36 37.13 60.48 C 39.05 63.50 39.91 67.10 42.00 70.02 C 45.05 72.63 49.30 73.28 52.41 75.83 C 53.70 77.84 52.86 81.00 50.54 81.85 C 48.53 82.66 46.29 82.46 44.24 81.99 C 36.80 80.25 31.20 73.29 30.31 65.83 C 30.05 63.76 30.46 61.20 32.58 60.24 Z" />
        </g>
    </symbol>

    <!-- food -->
    <symbol id="icon-food" viewBox="0 0 96 96">
        <g id="#b95e29ff">
        <path fill="#b95e29" opacity="1.00" d=" M 52.26 5.24 C 60.21 1.07 69.72 -1.22 78.52 1.52 C 85.55 3.39 92.19 8.38 94.59 15.43 C 97.03 25.48 93.41 36.16 87.02 44.01 C 83.41 48.23 78.29 50.69 73.61 53.52 C 67.92 56.90 61.47 58.51 55.17 60.30 C 48.91 62.03 43.24 65.32 37.85 68.87 C 36.70 68.31 35.55 67.76 34.42 67.17 C 32.25 65.27 30.12 63.32 27.95 61.42 C 27.06 60.35 25.35 59.53 25.31 58.02 C 26.15 55.78 27.65 53.89 28.77 51.80 C 30.61 48.53 31.36 44.80 32.30 41.20 C 33.38 36.80 34.71 32.46 36.18 28.17 C 36.39 27.79 36.83 27.03 37.05 26.65 L 36.71 25.85 C 39.46 17.56 44.39 9.52 52.26 5.24 M 51.60 15.61 C 47.99 18.30 46.40 22.69 45.04 26.80 C 46.51 28.16 48.47 29.54 50.57 28.73 C 53.60 25.93 54.66 21.50 58.10 19.08 C 61.44 16.66 65.73 16.64 69.54 15.41 C 71.41 14.18 70.50 11.74 69.86 10.08 C 63.28 9.13 56.83 11.78 51.60 15.61 Z" />
        </g>
        <g id="#db824dff">
        <path fill="#db824d" opacity="1.00" d=" M 51.60 15.61 C 56.83 11.78 63.28 9.13 69.86 10.08 C 70.50 11.74 71.41 14.18 69.54 15.41 C 65.73 16.64 61.44 16.66 58.10 19.08 C 54.66 21.50 53.60 25.93 50.57 28.73 C 48.47 29.54 46.51 28.16 45.04 26.80 C 46.40 22.69 47.99 18.30 51.60 15.61 Z" />
        </g>
        <g id="#6a54477e">
        <path fill="#6a5447" opacity="0.49" d=" M 35.85 27.38 C 36.06 27.00 36.49 26.23 36.71 25.85 L 37.05 26.65 C 36.83 27.03 36.39 27.79 36.18 28.17 L 35.85 27.38 Z" />
        </g>
        <g id="#e3d3c3ff">
        <path fill="#e3d3c3" opacity="1.00" d=" M 19.32 69.28 C 22.64 67.18 25.11 64.06 27.95 61.42 C 30.12 63.32 32.25 65.27 34.42 67.17 C 31.71 70.05 28.14 72.47 26.64 76.26 C 26.68 79.79 28.09 83.20 27.80 86.75 C 27.44 89.96 26.23 92.98 25.15 96.00 L 18.13 96.00 C 15.37 93.87 13.83 90.68 12.34 87.62 C 9.99 87.05 7.63 86.45 5.37 85.59 C 1.86 84.46 -0.26 79.99 1.42 76.63 C 3.28 73.44 6.47 70.79 10.23 70.34 C 13.24 69.85 16.41 70.27 19.32 69.28 Z" />
        </g>
    </symbol>

    <!-- love -->
    <symbol id="icon-love" viewBox="0 0 96 96">
        <g id="#f44336ff">
        <path fill="#f44336" opacity="1.00" d=" M 1.83 30.69 C 4.28 21.68 12.15 14.48 21.25 12.55 C 26.95 11.50 33.09 12.04 38.23 14.85 C 42.07 16.91 45.09 20.13 48.01 23.30 C 50.41 20.65 52.83 17.94 55.85 15.97 C 60.32 13.06 65.75 11.81 71.04 12.10 C 80.83 12.50 89.88 19.30 93.43 28.34 C 96.19 35.79 95.26 44.38 91.31 51.22 C 83.77 64.63 71.19 74.09 58.79 82.71 C 55.34 84.91 52.02 87.65 47.98 88.65 C 45.38 88.09 43.15 86.53 40.91 85.16 C 30.80 78.49 20.89 71.27 12.76 62.22 C 8.68 57.68 4.92 52.71 2.73 46.97 C 0.74 41.82 0.49 36.04 1.83 30.69 M 25.25 19.50 C 17.30 20.01 9.63 26.54 9.30 34.77 C 10.25 36.16 11.84 37.42 13.63 37.03 C 16.21 34.83 17.92 31.79 20.53 29.61 C 23.35 27.48 26.86 26.50 29.68 24.36 C 31.03 21.44 28.02 19.08 25.25 19.50 Z" />
        </g>
        <g id="#f76b60ff">
        <path fill="#f76b60" opacity="1.00" d=" M 25.25 19.50 C 28.02 19.08 31.03 21.44 29.68 24.36 C 26.86 26.50 23.35 27.48 20.53 29.61 C 17.92 31.79 16.21 34.83 13.63 37.03 C 11.84 37.42 10.25 36.16 9.30 34.77 C 9.63 26.54 17.30 20.01 25.25 19.50 Z" />
        </g>
    </symbol>
</svg>


    
    <div id="customConfirmModal" class="modal">
    <div class="modal-content">
        <p id="customModalText"></p>
        <div class="modal-buttons">
        <button id="customConfirmYes" class="btn btn-confirm">Taip</button>
        <button id="customConfirmNo" class="btn btn-cancel">Ne</button>
        </div>
    </div>
    </div>

    <div id="object-popup" class="object-popup-overlay" style="display:none;">
    <div class="object-popup-panel">
        <button class="object-popup-close">&times;</button>
        <div class="title-subtitle-inline-button-wrapper">
        <div class="object-popup-title-subtitle-wrapper">
        <div class="object-popup-title" id="object-popup-title"></div>
        <div class="object-popup-subtitle" id="object-popup-subtitle"></div>
        </div>
        </div>
        <div class="object-popup-content" id="object-popup-content">
        <!-- Dynamic content goes here -->
        </div>
    </div>
    </div>

     <nav class="main-navbar" id="mainNavbar">
        <div class="main-nav-container">
            <!-- Logo -->
            <a href="#" class="main-nav-logo">
                <div class="main-nav-logo-icon">
                 <img id="sudedu-main-nav-bar-logo" src="../images/sudedu_logo.png" alt="sudEdu">
                </div>
            </a>

            <!-- Desktop Navigation -->
            <div class="main-nav-links invisible">
                <a href="index.html" class="main-nav-link">Praktika</a>
                <a href="uzduotys.html" class="main-nav-link">Uduotys</a>
                <a href="klase.html" class="main-nav-link">Klas</a>
                <a href="augintiniai.html" class="main-nav-link main-nav-link-active">Augintiniai</a>
                <a href="apie.html" class="main-nav-link">Apie Sudedu</a>
                
                <div class="main-nav-language-dropdown" id="languageDropdown">
                    <button class="main-nav-language-btn" id="languageBtn">
                        <span id="currentLanguage">LT</span>
                        <span class="main-nav-language-arrow"></span>
                    </button>
                    <div class="main-nav-language-menu">
                        <button class="main-nav-language-option selected" data-lang="LT">LT</button>
                        <button class="main-nav-language-option" data-lang="EN">EN</button>
                    </div>
                </div>
                
                
                <div class="main-nav-connect-wrapper">
                    <div class="main-nav-connect-glow"></div>
                    <button class="main-nav-log-out-btn">
                        <span class="main-nav-connect-text">Atsijungti</span>
                    </button>

                    <button class="main-nav-log-in-btn">
                        <span class="main-nav-connect-text">Prisijungti</span>
                    </button>
                </div>
            </div>

            <!-- Mobile Button -->
            <button class="main-nav-mobile-btn" id="mainNavMobileBtn">
                <span class="main-nav-hamburger"></span>
                <span class="main-nav-hamburger"></span>
                <span class="main-nav-hamburger"></span>
            </button>

            <!-- Mobile Menu -->
            <div class="main-nav-mobile-menu" id="mainNavMobileMenu">
                <a href="index.html" class="main-nav-mobile-link">Praktika</a>
                <a href="uzduotys.html" class="main-nav-mobile-link">Uduotys</a>
                <a href="klase.html" class="main-nav-mobile-link">Klas</a>
                <a href="augintiniai.html" class="main-nav-mobile-link active">Augintiniai</a>
                <a href="apie.html" class="main-nav-mobile-link">Apie Sudedu</a>
                
                <div class="main-nav-mobile-language">
                    <button class="language-option language-option-LT selected" onclick="setLanguage('LT')">LT</button>
                    <span class="language-separator">/</span>
                    <button class="language-option language-option-EN" onclick="setLanguage('EN')">EN</button>
                </div>
                
                <button class="main-nav-mobile-log-out-btn">
                    <span class="main-nav-connect-text">Atsijungti</span>
                </button>
                <button class="main-nav-mobile-log-in-btn">
                    <span class="main-nav-connect-text">Prisijungti</span>
                </button>
            </div>
        </div>
    </nav>

    <div id="gameContainer" class="" hidden>

    <nav class="game-navigation">
        <div class="nav-items">
            <button class="nav-item active" id="pet-room-button" data-target="pet-room-container">
                <span class="nav-icon">
                <img src="../images/icons/icon-home.svg">
                </span>
            <span class="nav-label">Namai</span>
            </button>
            <button class="nav-item" data-target="pet-asset-container"><span class="nav-icon">
                <span class="nav-icon">
                <img src="../images/icons/icon-pets.svg">
                </span>
            </span><span class="nav-label">Augintiniai</span></button>
            <button class="nav-item" data-target="furniture-container">
                <span class="nav-icon">
                <img src="../images/icons/icon-furniture.svg">
                </span>
            <span class="nav-label">Baldai</span></button>
            <button class="nav-item" data-target="shop-container">
                <span class="nav-icon">
                <img src="../images/icons/icon-shop.svg">
                </span>
            <span class="nav-label">Parduotuv</span></button>
            <button class="nav-item taxes" data-target="taxes-container">
                <span class="nav-icon taxes-nav-icon">
                <img src="../images/icons/icon-taxes.svg">
                </span>
            <span class="nav-label">Mokesiai</span></button>
        </div>
    </nav>

    <div id="game-content" class="">
        <div id="content-outer-container" class="hide-scrollbar">
            <div id="pet-room-container" class="game-content-panel active">

            <div id="game-panel">
            <div id="pet-buttons-outer">
            <div id="pet-buttons-outer">
                <div id="pet-buttons"></div>
                <div id="pet-on-walk-checkbox-holder"></div>
            </div>
        
            </div>

    <div class="pet-stats-bars">
        <div class="stats-bar-outer">
            <div class="stats-bar-icon">
                <svg class="stats-icon">
                    <use href="#icon-food"></use>
                </svg>
                </div>
            <div class="stat-bar" id="food-bar" role="progressbar" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
                <div class="segments"></div>
            </div>
        </div>

        <div class="stats-bar-outer">
            <div class="stats-bar-icon">
                <svg class="stats-icon">
                    <use href="#icon-water"></use>
                </svg>
            </div>
            <div class="stat-bar" id="water-bar" role="progressbar" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
                <div class="segments"></div>
            </div>
        </div>

        <div class="stats-bar-outer">
            <div class="stats-bar-icon">
                <svg class="stats-icon">
                    <use href="#icon-love"></use>
                </svg>
            </div>
            <div class="stat-bar" id="love-bar" role="progressbar" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0">
                <div class="segments"></div>
            </div>
        </div>
    </div>
            <div id="room-container">
                <div id="roomGridContainer">
                    <div id="roomGrid" class="room-grid">
                </div>
                    </div>
                <div id="petContainer">
                </div>
                    <div id="roomObjectsContainer">
                </div>
            </div>
            <div id="button-container">
                <button id="toggle-edit-save-btn" class="edit">Perstatyti</button>
                <button id="cancel-edit-btn" class="cancel hidden">Ataukti</button>
                <button id="end-preview-button" class="cancel hidden">Baigti perir</button>
            </div>
            </div>
            </div>

      <div id="shop-container" class="game-content-panel">
        <div class="shop-header">
            <h2>Parduotuv</h2>
            <div class="coin-display">
                <span class="coin-icon">
                        <img src="../images/icons/icon-sudedu-coin.png">
                </span>
                <span class="coin-amount"></span>
            </div>
        </div>
        
        <div class="shop-departments">
            <button class="department-btn">
                <span class="department-icon">
                    <span class="department-icon">
                        <img src="../images/icons/icon-pet-supplies.svg">
                    </span>
                </span>
                <span class="department-label">Reikmenys</span>
            </button>
            
            <button class="department-btn">
                <span class="department-icon">
                    <span class="nav-icon">
                        <img src="../images/icons/icon-furniture.svg">
                    </span>
                </span>
                <span class="department-label">Baldai</span>
            </button>
            <button class="department-btn">
                <span class="department-icon">
                    <span class="nav-icon">
                        <img src="../images/icons/icon-animals.svg">
                    </span>
                </span>
                <span class="department-label">Gyvnliai</span>
            </button>
            
        </div>

        <div id="shop-buttons">
        <!-- Pet list (only shown for Maistas) -->
        <div id="pet-list-shop" class="pet-list hidden"></div>

        <!-- Maistas tabs (only shown for Maistas) -->
        <div id="pet-supplies-tabs" class="pet-supplies-tabs hidden">
            <button class="pet-supply-tab active" data-type="supplies">
                <span class="department-icon">
                    <img src="../images/icons/icon-pet-food.svg">
                </span>
                <span class="tab-label">Maistas</span>
            </button>
            <button class="pet-supply-tab" data-type="skins">
                <span class="department-icon">
                    <img src="../images/icons/icon-pet-skins.svg">
                </span>
                <span class="tab-label">Ivaizda</span>
            </button>
        </div>
        </div>

        <div class="shop-categories-dropdown">
            <div class="categories-dropdown-holder">
                <select id="shop-category-select"></select>
            
            <div class="shop-not-owned-holder">
                <label class="switch"><input type="checkbox" id="shop-not-owned-toggle" class="shop-not-owned-toggle">
                    <span class="switch-slider">
                        <span class="switch-text switch-text-shop">
                            NETURIU
                        </span>
                    </span>
                </label>
            </div>

            </div>
            <div class="shop-items" id="shop-items"></div>
        </div>
    </div>

    <div id="pet-asset-container" class="game-content-panel">
                <div class="shop-header">
                    <h2>Augintiniai</h2>
                </div>
                

                <div id="pet-asset-buttons">
                <div id="pet-list-owned"></div>
                <div id="pet-asset-buttons-departments-dropdown">
                <div class="pet-asset-supply-tabs">
                <button class="department-btn pet-asset-supply-button active">
                    <span class="department-icon">
                        <img src="../images/icons/icon-pet-food.svg">
                    </span>
                    <span class="department-label">Maistas</span>
                </button>
                <button class="department-btn pet-asset-supply-button">
                    <span class="department-icon">
                        <img src="../images/icons/icon-pet-skins.svg">
                    </span>
                    <span class="department-label">Ivaizda</span>
                </button>
                </div>
                    </div>
                </div>
                <div class="categories-dropdown-holder">
                        <select id="pet-category-select" style="display: none;"></select>
                </div>
                <div id="pet-skins"></div>
                <div id="pet-supplies">
                    <div id="pet-supplies-items"></div>
                </div>
                <div class="pet-categories-dropdown"></div>
    </div>

            <div id="taxes-container" class="game-content-panel">
            
                <div class="taxes-header">
                <div class="shop-header">
                    <h2>Mokesiai</h2>
                    <div class="coin-display">
                    <span class="coin-icon">
                            <img src="../images/icons/icon-sudedu-coin.png">
                    </span>
                    <span class="coin-amount"></span>
                </div>
                </div>
                </div>
                <div class="tax-records">
                    <h3>Mokesi sraas</h3>
                    <div class="records-list">
                        <div class="tax-record">
                            <div class="record-info water-tax">
                                <div class="record-type"><span class="type-icon">
                                <span class="department-icon">
                                    <img src="../images/icons/icon-tax-water.svg">
                                </span>
                                </span><span class="type-name">Vandens mokestis</span><span id="days-remaining-water"></span></div>
                                <div class="record-details"><span class="record-date"></span><span class="record-amount" id="water-tax-cost"></span></div>
                            </div>
                            <div class="tax-status-and-pay-btn-holder">
                            <div class="record-status"><span class="status-badge"></span></div>
                            <div class="record-actions">
                                <button class="pay-tax-btn water"></button>
                            </div>
                            </div>
                        </div>
                        <div class="tax-record">
                            <div class="record-info electricity-tax">
                                <div class="record-type"><span class="type-icon">
                                <span class="department-icon">
                                    <img src="../images/icons/icon-tax-electricity.svg">
                                </span>
                                </span><span class="type-name">Elektros mokestis</span><span id="days-remaining-electricity"></span></div>
                                <div class="record-details"><span class="record-date"></span><span class="record-amount" id="electricity-tax-cost"></span></div>
                            </div>
                            <div class="tax-status-and-pay-btn-holder">
                            <div class="record-status"><span class="status-badge"></span></div>
                            <div class="record-actions">
                                <button class="pay-tax-btn electricity"></button>
                            </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="tax-info">
                    <h3>Mokesi informacija</h3>
                    <div class="info-cards">
                        <div class="info-card">
                            <h4><span class="department-icon">
                                    <img src="../images/icons/icon-tax-water.svg">
                                </span> Vandens mokestis</h4>
                            <p>Vanduo reikalingas augintinams girdyti ir prausti.</p>
                        </div>
                        <div class="info-card">
                            <h4><span class="department-icon">
                                    <img src="../images/icons/icon-tax-electricity.svg">
                                </span> Elektros mokestis</h4>
                            <p>Elektra reikalinga viesai ir elektros prietaisams.</p>
                        </div>
                    </div>
                </div>


            </div>

            <div id="furniture-container" class="game-content-panel">
                <div class="shop-header">
                    <h2>Baldai</h2>
                </div>
                <div class="shop-categories-dropdown">
                    <div class="categories-dropdown-holder">
                        <select id="object-category-select"></select>
                            <div class="object-usage-toggle-holder">
                            <label class="switch"><input type="checkbox" id="object-usage-toggle" class="object-usage-toggle">
                                <span class="switch-slider">
                                    <span class="switch-text switch-text-object">
                                        NENAUD.
                                    </span>
                                </span>
                            </label>
                        </div>
                    </div>
                    <div class="object-assets">

                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script src="../mental-arithmetic.js"></script>
    <script src="../main-nav-bar.js"></script>
    <script>
        if (!userData || userData?.accType === "teacher") {
            window.location.href = './';
        }

        let unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
        let gameAssetIndex = {};
        let userPetAssets = {};
        let userMoney = 0;
        let selectedConsumable = [];
        let pendingPetActions = {};
        let petControllers = {};
        let petStatsList = '';
        let taxesData = {}
        const taxPaymentPeriod = 14 //days
        const taxGracePeriod = 2 //days;
        const taxPrice = {
            "waterTax": 20,
            "electricityTax": 20
        }
        let petOnWalk = "";
        const speciesTranslationDict = {
            "cat": "kat"
        }
        const receivedMessages = [];

        function convertUserPetAssetsDictToCompactList(data) {
            let pets = Object.entries(data.pets).map(([p, v]) => [
                p,
                [
                    v.name, // real pet name
                    Object.entries(v.skins).map(([s, d]) => [s, d.assetIndex, d.equiped])
                ]
            ]);
            let supplies = Object.values(data.supplies).map(s => [s.assetIndex, s.quantity]);
            return [pets, supplies];
        }

        function renderPets() {
            const petContainer = document.getElementById("petContainer");

            if (!petContainer) return;
            petContainer.innerHTML = ''; // clear existing content

            const pets = userPetAssets.pets;

            let itemsInUse = [];

            for (const petNumber in pets) {
                const petDict = pets[petNumber];
                const skins = petDict.skins;
                let petCoords = getObjectCoordinates(petDict.id);
                let petStaringPosTop;
                let petStartingPosLeft;
                
                
                const petSpecies = petNumber.split('-')[0]
                const matchingBeds = Array.from(roomObjectsContainer.querySelectorAll("*")).filter(el => {
                    const classStr = el.className; // full class string
                    return classStr.includes("bed") && classStr.includes(petSpecies) && !classStr.includes("furniture-preview") && !itemsInUse.includes(el.id);
                });

                let equippedSkin = Object.values(skins).find(skin => skin.equiped);
                
                if (!equippedSkin) {
                    const firstSkinKey = Object.keys(skins)[0];
                    equippedSkin = skins[firstSkinKey];
                    equippedSkin.equiped = true;
                    sendPetAssetsUpdateToDatabase();
                }

                const petDiv = document.createElement('div');
                const petClasses = gameAssetIndex[equippedSkin.assetIndex]["css-class"];
                petDiv.id = petClasses.split(' ')[0];
                petDiv.className = petClasses;
                petContainer.appendChild(petDiv);
                
                if (matchingBeds.length > 0) {
                    const randomIndex = Math.floor(Math.random() * matchingBeds.length);
                    object = matchingBeds[randomIndex];
                    itemsInUse.push(object.id);
                    
                    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]["assetIndex"]]["interactive-spot"];
                    let objectCoords = getObjectCoordinates(object.id);
                    [petStartingPosLeft, petStaringPosTop] = [objectCoords[0] + objectInteractivePart[0], objectCoords[1] - objectInteractivePart[1]];
                } else {
                    const pet = document.getElementById(petNumber);
                    const suitableWalkingTiles = generateWalkabilityMap();
                    const validCoords = findValidPlacements(suitableWalkingTiles, pet);

                    if (validCoords.length === 0) {
                        return;
                    }

                    // Pick a random coordinate
                    const randomIndex = Math.floor(Math.random() * validCoords.length);
                    const randomCoord = validCoords[randomIndex];
                    const petPos = getObjectCoordinates(pet.id)

                    petStartingPosLeft = randomCoord[0];
                    petStaringPosTop = randomCoord[1];
                }


                petDiv.style.top = `calc((${petStaringPosTop} * var(--unit-size)) - (var(--pet-size) - var(--unit-size)))`;
                petDiv.style.left = `calc(${petStartingPosLeft} * var(--unit-size))`;

                predictAndSetZIndex(petDiv);

                setObjectAnimation(petDiv, `${petNumber}-sleeps`)
            }

            Object.entries(petStatsList).forEach(([petId, stats]) => {
            if (userPetAssets.pets?.[petId]) {
                const petSpecies = petId.split("-")[0];
                const bonusStats = bonusFromDailySupplyItems();
                const el = document.getElementById(petId);
                if (!el) {
                    console.warn(`Pet element not found in DOM: ${petId}`);
                    return;
                }

                const currentTime = Math.floor(Date.now() / 1000 / 60);
                const timeElapsed = currentTime - stats[3];
                const statDecrease = Math.floor(timeElapsed * PET_STATS_EXPIRATION);

                const food = Math.max(bonusStats[petSpecies]?.food ?? 0, stats[0] - statDecrease);
                const water = Math.max(bonusStats[petSpecies]?.water ?? 0, stats[1] - statDecrease);
                const love = Math.max(bonusStats[petSpecies]?.love ?? 0, stats[2] - statDecrease);
                const date = currentTime;

                el._stats = {
                    food: food,
                    water: water,
                    love: love,
                    date: currentTime,
                    foodNew: food,
                    waterNew: water,
                    loveNew: love,
                    };
                }
            });

        
            // Create default stats for any pets that exist but don't have stats yet
            Object.keys(userPetAssets.pets || {}).forEach(petId => {
                if (!document.getElementById(petId)._stats) {
                    document.getElementById(petId)._stats = {
                        "food": 10,
                        "water": 10,
                        "love": 10,
                        "date": Math.floor(Date.now() / 1000 / 60),
                        "foodNew": 10,
                        "waterNew": 10,
                        "loveNew": 10,
                    }

                    sendPetStatsUpdateToDatabase(petId);
                }
            });

            createPetButtons();
            
            const allPets = document.querySelectorAll("#petContainer .pet");
            if (allPets[0]) {
                displayPetStats(allPets[0].id);
            }
        }

        let userObjectAssets = {};
            
        const roomLayout = [
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // Row 0 - top wall
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // Row 1 - wall-floor boundary
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // Row 0 - top wall
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // Row 1 - wall-floor boundary
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // Row 1 - wall-floor boundary
          [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], // Row 2 - floor with walls
          [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], // Row 4 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 5 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 6 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 7 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 8 - floor-wall boundary
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 3 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 4 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 5 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 6 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 7 - floor with walls
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Row 8 - floor-wall boundary
        ];


        function renderRoomGrid() {
            const roomGrid = document.getElementById('roomGrid');

            roomGrid.innerHTML = ''
                        
            // Define how many columns/rows you want
            const cols = roomLayout[0].length;
            const rows = roomLayout.length;

            // Apply grid template using JS
            roomGrid.style.gridTemplateColumns = `repeat(${cols}, ${unitSize}px)`;
            roomGrid.style.gridTemplateRows = `repeat(${rows}, ${unitSize}px)`;

            for (let row = 0; row < roomLayout.length; row++) {
                for (let col = 0; col < roomLayout[0].length; col++) {
                    const tile = document.createElement('div');
                    const tileType = roomLayout[row][col];
                    
                    tile.className = 'tile';
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    
                    switch(tileType) {
                        case 1:
                            tile.classList.add('floor');
                            break;
                        case 2:
                            tile.classList.add('wall');
                            break;
                        case 3:
                            tile.classList.add('boundary');
                    }
                    
                    roomGrid.appendChild(tile);
                }
            }
        }

        function setPetAndObjectContainersToGridDimentions() {
            const roomGrid = document.getElementById('roomGrid');

            const width = roomGrid.offsetWidth;
            const height = roomGrid.offsetHeight;

            const roomContainer = document.getElementById('room-container');
            const petContainer = document.getElementById('petContainer');
            const roomObjectsContainer = document.getElementById('roomObjectsContainer');

            // Add 'px' to make it valid CSS
            roomContainer.style.width = width + "px";
            roomContainer.style.height = height + "px";
            
            petContainer.style.width = width + "px";
            petContainer.style.height = height + "px";

            roomObjectsContainer.style.width = width + "px";
            roomObjectsContainer.style.height = height + "px";
        }

// Function to render assets into the container
function renderRoomObjects() {
    const roomObjectsContainer = document.querySelector("#roomObjectsContainer");
    roomObjectsContainer.innerHTML = '';

    Object.entries(userObjectAssets).forEach(([key, asset]) => {
        if (asset.position.length !== 0) {
            const [x, y] = asset.position;
            const div = document.createElement("div");
            roomObjectsContainer.appendChild(div);
            div.className = `room-object ${gameAssetIndex[asset.assetIndex]["css-class"]}`;
            div.id = key;
            div.style.left = `calc(${x} * var(--unit-size))`;
            div.style.top = `calc((${y + 1} * var(--unit-size)) - ${div.offsetHeight}px)`;
        }
    });

    if (furniturePreviewDict["furniture-preview"].assetIndex) {
        if (furniturePreviewDict["furniture-preview"].position.length !== 0) {
            const [x, y] = furniturePreviewDict["furniture-preview"].position;
            const div = document.createElement("div");
            roomObjectsContainer.appendChild(div);
            div.className = `room-object furniture-preview ${gameAssetIndex[furniturePreviewDict["furniture-preview"].assetIndex]["css-class"]}`;
            div.id = 'furniture-preview';
            div.style.left = `calc(${x} * var(--unit-size))`;
            div.style.top = `calc((${y + 1} * var(--unit-size)) - ${div.offsetHeight}px)`;
        }
    }
    
    disableObjectDragging();
}

function toggleRoomDarknessBasedOnElectricityTax() {
    const room = document.getElementById("room-container");
    if (!taxesData.electricityTax.paid) {
        room.classList.add("dark");
        messageToTheUser("Nra viesos! Sumokk elektros mokest.")
    } else {
        // only remove if it exists
        if (room.classList.contains("dark")) {
            room.classList.remove("dark");
        }
    }
}

function initGame() {
    adjustUnitSizeForSmallScreens(roomLayout);
    renderRoomGrid();
    setPetAndObjectContainersToGridDimentions();
    renderRoomObjects();
    renderPets();
    enablePetDragging();
    updateCoinAmounts(userMoney);
    taxesNavChoiceIndicator();
    bonusFromDailySupplyItems();
    toggleRoomDarknessBasedOnElectricityTax();

    predictAndSetZIndex();

    const shopEl = document.querySelector(".switch-text-shop");
    if (shopEl) shopEl.textContent = "NETURIU";

    const objEl = document.querySelector(".switch-text-object");
    if (objEl) objEl.textContent = "NENAUD.";

    petControllers = {};
    pendingPetActions = {};

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        managePetActions(pet);
    });
}

fetch("gameAssetIndex.json")
    .then(response => response.json())
    .then(data => {
        gameAssetIndex = data;      // assign JSON result
        return fetchGameData();     // call your function next
    })
    .then(() => {
        initGame();                 // only runs after fetchGameData completes
        fetchMessageGiftsFromServer();
    })
    .catch(error => {
        console.error("Error loading gameAssetIndex.json or fetching game data:", error);
    });

function parseGameData(dataFromServer) {
    userObjectAssets = formatObjectAssets(dataFromServer.objectAssets);
    userPetAssets = parseUserPetAssets(dataFromServer.petAssets);
    userMoney = Number(dataFromServer.money);
    petOnWalk = dataFromServer.petOnWalk;
    formatTaxesData(dataFromServer.taxes) 
    
    // Parse pet stats from the new format
    petStatsList = JSON.parse(dataFromServer.petStats);

    function formatTaxesData(taxesDataFromTheServer) {
        if (typeof taxesDataFromTheServer === "string") {
            taxesDataFromTheServer = JSON.parse(taxesDataFromTheServer);
        }

        // Current time in days
        const currentTimeInDays = Date.now() / 1000 / 60 / 60 / 24;

        // taxPaymentPeriod and taxGracePeriod are already in days
        if (!taxesDataFromTheServer || taxesDataFromTheServer.length === 0) {
            taxesData = {
                "waterTax": {
                    date: Math.floor(Date.now() / 1000 / 60),
                    paid: true
                },
                "electricityTax": {
                    date: Math.floor(Date.now() / 1000 / 60),
                    paid: true
                }
            }
            sendTaxUpdate([taxesData.waterTax.date, taxesData.electricityTax.date])
            return
        }

        const [waterTaxDateInMinutes, electricityTaxDateInMinutes] = taxesDataFromTheServer;

        // Convert server-provided dates from minutes to days
        const waterTaxDate = waterTaxDateInMinutes / 60 / 24;
        const electricityTaxDate = electricityTaxDateInMinutes / 60 / 24;

        // Calculate due dates and grace periods in days
        const waterTaxDueDate = waterTaxDate + taxPaymentPeriod;
        const electricityTaxDueDate = electricityTaxDate + taxPaymentPeriod;
        const graceEndWater = waterTaxDueDate + taxGracePeriod;
        const graceEndElectricity = electricityTaxDueDate + taxGracePeriod;

        // Determine if paid
        const waterPaid = currentTimeInDays <= graceEndWater;
        const electricityPaid = currentTimeInDays <= graceEndElectricity;

        taxesData = {
            "waterTax": {
                date: waterTaxDateInMinutes,
                paid: waterPaid
            },
            "electricityTax": {
                date: electricityTaxDateInMinutes,
                paid: electricityPaid
            }
        };
    }


    function formatObjectAssets(objectAssetsDataFromServer) {
        let formatteddataFromServer = {};
        objectAssetsDataFromServer = JSON.parse(objectAssetsDataFromServer);

        objectAssetsDataFromServer.forEach((entry, index) => {
            formatteddataFromServer[`O${index + 1}`] = {
                assetIndex: entry[0],
                position: entry[1]
            };
        });

        return formatteddataFromServer;
    }


    function parseUserPetAssets(petAssets) {
        // If server sends a JSON string, parse it
        if (typeof petAssets === "string") {
            petAssets = JSON.parse(petAssets);
        }

        let petObj = {};
        let supObj = {};
        
        if (petAssets.length > 1) {
            const [pets, supplies] = petAssets;

            for (let [petId, [petName, skins]] of pets) {
                petObj[petId] = { 
                    skins: {},
                    name: petName
                };
                for (let [skinName, assetIndex, equipped] of skins) {
                    petObj[petId].skins[skinName] = {
                        assetIndex: assetIndex,
                        equiped: equipped
                    };
                }
            }

            supplies.forEach(([assetIndex, quantity], idx) => {
                supObj[`S${idx + 1}`] = {
                    assetIndex: assetIndex,
                    quantity: quantity
                };
            });
        }

        return { pets: petObj, supplies: supObj };
    }


}

async function fetchGameData() {
    let showMessageTimeout;
    let closer;
    
    // Schedule showing the message after 500ms
    showMessageTimeout = setTimeout(() => {
        closer = messageToTheUser("Duomenys iekomi duomen bazje. Procesas gali utrukti kelias minutes.", false);
    }, 500);

    const gameContainer = document.getElementById("gameContainer");
    Array.from(gameContainer.children).forEach(child => {
        child.style.pointerEvents = "none";
        child.style.opacity = "0.5";
    });
    
    try {
        //  Get fresh userData right before making the request
        const userData = JSON.parse(localStorage.getItem('userData'));
        
        if (!userData?.userId) {
            throw new Error('No user data found');
        }

        const response = await apiFetch(apiBase + 'petGame/gameData', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId })
        });

        if (!response) {
            throw new Error('No response from server');
        }

        if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        parseGameData(result);

    } catch (error) {
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.error("Error fetching game data:", error);
    } finally {
        //  Re-enable container (moved to finally to always execute)
        Array.from(gameContainer.children).forEach(child => {
            child.style.pointerEvents = "auto";
            child.style.opacity = "1";
        });
        
        clearTimeout(showMessageTimeout);
        
        if (closer) {
            setTimeout(() => closer(), 0);
        }
    }
}

    
const roomContainer = document.getElementById('room-container');
let isDragging = false;
let currentObject = null;
let holdTimer = null;
let holdStartTime = 0;
let offsetX = 0;
let offsetY = 0;

// Object interactions
const objectInteractions = {
    'pet': (obj) => displayPetTreatOptions(obj),
    'food-bowl': (obj) => displayFoodOptions(obj),
    'water-bowl': (obj) => displayWaterBowlFillingOptions(obj),
    'music-player': (obj) => toggleMusicPlayer(obj),
    'bath': (obj) => displayBathFillingOption (obj)

};

function toggleMusicPlayer(obj) {
  const musicPlayerAutoOff = 4000; // milliseconds

  const pets = document.querySelectorAll('.pet');

  if (!obj.objectOn) {
    // Turn ON
    obj.objectOn = true;
    setObjectAnimation(obj, "musicPlayerOn");
    initUserTriggeredAction("music", obj);

    // Automatically turn off after delay
    setTimeout(() => {
      if (!obj.objectOn) return; // already off

      obj.objectOn = false;
      setObjectAnimation(obj, "musicPlayerOff");

      pets.forEach((pet) => {
        const firstAction = pendingPetActions[pet.id]?.[0];
        const dancingIsFirstItem = firstAction && firstAction[0] === petDances;

        pendingPetActions[pet.id] = (pendingPetActions[pet.id] || []).filter(
          ([fn, args]) => fn !== petDances
        );

        if (dancingIsFirstItem) {
          managePetActions(pet);
        }
      });
    }, musicPlayerAutoOff);

  } else {
    // Turn OFF manually
    obj.objectOn = false;
    setObjectAnimation(obj, "musicPlayerOff");

    pets.forEach((pet) => {
      const firstAction = pendingPetActions[pet.id]?.[0];
      const dancingIsFirstItem = firstAction && firstAction[0] === petDances;

      pendingPetActions[pet.id] = (pendingPetActions[pet.id] || []).filter(
        ([fn, args]) => fn !== petDances
      );

      if (dancingIsFirstItem) {
        managePetActions(pet);
      }
    });
  }
}

// Disable right-click context menu and image highlighting in room container
roomContainer.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});

roomContainer.addEventListener('selectstart', function(e) {
    e.preventDefault();
});

roomContainer.addEventListener('dragstart', function(e) {
    e.preventDefault();
});

// Add CSS to prevent highlighting
roomContainer.style.userSelect = 'none';
roomContainer.style.webkitUserSelect = 'none';
roomContainer.style.mozUserSelect = 'none';

function startDragging(e) {
    // Only allow left mouse button OR finger touch
    if (e.pointerType === "mouse" && e.button !== 0) return;
    
    isDragging = true;
    currentObject.classList.add('dragging');
    
    const rect = currentObject.getBoundingClientRect();
    const parentRect = currentObject.parentElement.getBoundingClientRect();
    
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.bottom; // offset from pointer to bottom
}

function enablePetDragging() {
    const pets = document.querySelectorAll('.pet');
    pets.forEach(pet => {
        // Prevent default browser drag on image/text
        pet.setAttribute('draggable', 'false');
        pet.style.userSelect = 'none';
        pet.style.touchAction = 'none';
        
        pet.addEventListener('pointerdown', function(e) {
            // Only allow left mouse or touch
            if (e.pointerType === "mouse" && e.button !== 0) return;

            pet.classList.add('dragging');
            
            cancelMovement(this.id);
            e.preventDefault();
            
            currentObject = this;
            holdStartTime = Date.now();

            if (pet.actionTimer) {
                clearTimeout(pet.actionTimer);
                pet.actionTimer = null;
            }

            if (petControllers[pet.id]) {
                petControllers[pet.id].abort();
                setObjectAnimation(pet, `${pet.id}-stands-idle`);
            }
            
            holdTimer = setInterval(() => {
                const elapsed = Date.now() - holdStartTime;
                const progress = Math.min(elapsed / 100, 1) * 100;
                
                if (elapsed >= 100) {
                    clearInterval(holdTimer);
                    startDragging(e);
                }
            }, 10);
        });
        
        // Cancel hold if pointer is released early
        pet.addEventListener('pointerup', function(e) {
            pet.classList.remove('dragging');
            if (holdTimer) {
                clearInterval(holdTimer);
            }
            setObjectAnimation(pet, `${pet.id}-stands-idle`)
            pet.actionTimer = setTimeout(() => {
                managePetActions(pet);
                pet.actionTimer = null; // Clean up reference
            }, 1000); // 1 second delay
            });
    });
}

function removeAllDeleteIcons() {
    document.querySelectorAll('.delete-icon').forEach(icon => icon.remove());
}

function showDeleteIcon(element) {
    if (furniturePreviewDict["furniture-preview"].assetIndex) {
        return
    }

    removeAllDeleteIcons();
    
    const deleteIcon = document.createElement('div');
    deleteIcon.className = 'delete-icon';
    deleteIcon.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 6 L6 18 M6 6 L18 18" stroke="#F5F5F7" stroke-width="2"/></svg>';
    deleteIcon.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 25px;
        height: 25px;
        background: red;
        color: #F5F5F7;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 12px;
        z-index: 1000;
        user-select: none;
    `;
    element.appendChild(deleteIcon);
}

function removeObjectByClickingDeleteIcon(element) {
    const obj = element.parentNode
    const objPlacingOrder = gameAssetIndex[userObjectAssets[obj.id]["assetIndex"]]["placingIndex"]
    if (hasBlockingObjects(obj) && !(objPlacingOrder === 5 || objPlacingOrder === 9)) {
        messageToTheUser(" daikt galsi iimti i kambario tik nums nuo jo kitus!");
        return;
    } else if (element && element.parentNode) {
        element.parentNode.remove();
    }
}

function hasBlockingObjects(target) {
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const targetCoords = getObjectCoordinates(target.id);
    if (!targetCoords) return false;

    const [baseX, baseY] = targetCoords;

    const targetWidth = Math.ceil(target.offsetWidth / unitSize);
    const targetHeight = Math.ceil(target.offsetHeight / unitSize);
    const targetZ = parseInt(window.getComputedStyle(target).zIndex) || 0;

    // Collect all tiles covered by this object
    const targetTiles = [];
    for (let dx = 0; dx < targetWidth; dx++) {
        for (let dy = 0; dy < targetHeight; dy++) {
            targetTiles.push([baseX + dx, baseY - dy]);
        }
    }

    // Compare against all other objects
    const allObjects = document.querySelectorAll('.room-object');
    for (let other of allObjects) {
        if (other === target) continue;

        const otherCoords = getObjectCoordinates(other.id);
        if (!otherCoords) continue;

        const [ox, oy] = otherCoords;
        const otherWidth = Math.ceil(other.offsetWidth / unitSize);
        const otherHeight = Math.ceil(other.offsetHeight / unitSize);
        const otherZ = parseInt(window.getComputedStyle(other).zIndex) || 0;

        const otherTiles = [];
        for (let dx = 0; dx < otherWidth; dx++) {
            for (let dy = 0; dy < otherHeight; dy++) {
                otherTiles.push([ox + dx, oy - dy]);
            }
        }

        //  Check if any tile overlaps
        for (let t of targetTiles) {
            for (let o of otherTiles) {
                if (t[0] === o[0] && t[1] === o[1] && otherZ > targetZ) {
                    return true;
                }
            }
        }
    }
    return false;
}

// Enable object dragging for edit mode
function enableObjectDragging() {
    const objects = document.querySelectorAll('.room-object');
    objects.forEach(obj => {
        obj.classList.add('room-object-edit');
        
        // Remove any existing event listeners first
        obj.removeEventListener('pointerdown', obj._normalModeHandler);
        obj.removeEventListener('pointerdown', obj._editModeHandler);
        
        // Create edit mode handler
        obj._editModeHandler = function(e) {
            if (e.pointerType === "mouse" && e.button !== 0) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const startTime = Date.now();
            const startX = e.clientX;
            const startY = e.clientY;
            
            let hasMoved = false;
            let dragStarted = false;
            
            const moveHandler = (moveEvent) => {
                const deltaX = Math.abs(moveEvent.clientX - startX);
                const deltaY = Math.abs(moveEvent.clientY - startY);
                
                // Increase threshold to prevent accidental dragging on clicks
                if ((deltaX > 10 || deltaY > 10) && !dragStarted) {
                    hasMoved = true;
                    const objPlacingOrder = gameAssetIndex[userObjectAssets[obj.id]?.assetIndex]?.placingIndex || gameAssetIndex[furniturePreviewDict[obj.id]?.assetIndex]?.placingIndex;
                    if (hasBlockingObjects(obj) && !(objPlacingOrder === 5 || objPlacingOrder === 9)) {
                        messageToTheUser(" daikt galsi pajudinti tik nums nuo jo kitus!");
                        cancelDrag(); // stop listening so it wont repeat
                        return;
                    }

                    dragStarted = true;
                    currentObject = obj;

                    obj._placementMap = determineAndHighlightValidTiles(obj.id);

                    const rect = obj.getBoundingClientRect();
                    const parentRect = obj.parentElement.getBoundingClientRect();

                    obj._originalCoords = getObjectCoordinates(obj.id)
                    
                    // Remove the temporary listeners
                    document.removeEventListener('pointermove', moveHandler);
                    
                    // Start dragging with the original event position
                    const syntheticEvent = {
                        clientX: startX,
                        clientY: startY,
                        pointerType: e.pointerType,
                        button: e.button
                    };
                    startDragging(syntheticEvent);
                }
            };
            
            const upHandler = (upEvent) => {
                document.removeEventListener('pointermove', moveHandler);
                document.removeEventListener('pointerup', upHandler);
                
                // If no dragging started and it was a quick click, show delete icon
                if (!dragStarted) {
                    showDeleteIcon(obj);
                }
                
                // Reset currentObject if no drag was initiated
                if (!isDragging) {
                    currentObject = null;
                }

                predictAndSetZIndex();
            };

            const cancelDrag = () => {
                document.removeEventListener('pointermove', moveHandler);
                document.removeEventListener('pointerup', upHandler);
                currentObject = null;
            };
            
            document.addEventListener('pointermove', moveHandler);
            document.addEventListener('pointerup', upHandler);
        };
        
        obj.addEventListener('pointerdown', obj._editModeHandler);
    });
}

// Disable object dragging for normal mode
function disableObjectDragging() {
    // Remove all delete icons when exiting edit mode
    removeAllDeleteIcons();
    
    // Target both room objects AND pets
    const objects = document.querySelectorAll('.room-object, .pet');
    objects.forEach(obj => {
        obj.classList.remove('room-object-edit');
        
        // Remove edit mode handler
        if (obj._editModeHandler) {
            obj.removeEventListener('pointerdown', obj._editModeHandler);
        }
        
        // Remove any existing normal mode handler first
        if (obj._normalModeHandler) {
            obj.removeEventListener('pointerdown', obj._normalModeHandler);
        }
        if (obj._normalModeUpHandler) {
            obj.removeEventListener('pointerup', obj._normalModeUpHandler);
        }
        
        let clickStartTime = 0;
        let wasLongHold = false;
        
        // Add normal mode handler (click for interaction only)
        obj._normalModeHandler = function(e) {
            if (e.pointerType === "mouse" && e.button !== 0) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            clickStartTime = Date.now();
            wasLongHold = false;
            
            // Check if this becomes a long hold (like your existing hold timer logic)
            const holdTimer = setTimeout(() => {
                wasLongHold = true;
            }, 1000); // Same 1 second threshold as your drag logic
            
            // Store timer reference to clear it later
            obj._holdTimer = holdTimer;
        };
        
        obj._normalModeUpHandler = function(e) {
            if (e.pointerType === "mouse" && e.button !== 0) return;
            
            // Clear the hold timer
            if (obj._holdTimer) {
                clearTimeout(obj._holdTimer);
                obj._holdTimer = null;
            }
            
            // Only trigger interaction if it was a quick click, not a long hold
            if (!wasLongHold && !isDragging && !editing) {
                for (const cls of this.classList) {
                    if (objectInteractions[cls]) {
                        objectInteractions[cls](obj);
                        break; // stop after the first match
                    }
                }
            }
            
            // Reset flags
            wasLongHold = false;
        };
        
        obj.addEventListener('pointerdown', obj._normalModeHandler);
        obj.addEventListener('pointerup', obj._normalModeUpHandler);
    });
}

// Global pointer move handler
document.addEventListener('pointermove', function(e) {
    if (isDragging && currentObject) {
        const parentRect = currentObject.parentElement.getBoundingClientRect();
        let newX = e.clientX - parentRect.left - offsetX;
        let newY = e.clientY - parentRect.top - offsetY - currentObject.offsetHeight;
        
        newX = Math.max(0, Math.min(newX, parentRect.width - currentObject.offsetWidth));
        newY = Math.max(0, Math.min(newY, parentRect.height - currentObject.offsetHeight));
        
        currentObject.style.left = newX + 'px';
        currentObject.style.top = newY + 'px';
    }
});

function checkPlacement(obj, placementMap, unitSize) {
    const objRect = obj.getBoundingClientRect();
    const parentRect = obj.parentElement.getBoundingClientRect();

    const startRow = Math.floor((obj.offsetTop) / unitSize);
    const startCol = Math.floor((obj.offsetLeft) / unitSize);

    const rows = Math.ceil(obj.offsetHeight / unitSize);
    const cols = Math.ceil(obj.offsetWidth / unitSize);

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const mapRow = startRow + r;
            const mapCol = startCol + c;

            if (!placementMap[mapRow] || !placementMap[mapRow][mapCol] || !placementMap[mapRow][mapCol].canPlace) {
                return false;
            }
        }
    }
    return true;
}

function isBottomRowWalkable(walkMap, startRow, startCol, width) {
    // startRow = bottom row where pet would sit
    // startCol = leftmost column of the pet
    for (let col = startCol; col < startCol + width; col++) {
        if (!walkMap[startRow][col]?.walkable) {
            return false;
        }
    }
    return true;
}


function findClosestWalkablePosition(walkMap, startRow, startCol, petWidth) {
    let minDist = Infinity;
    let closest = null;

    for (let row = 0; row < walkMap.length; row++) {
        for (let col = 0; col <= walkMap[0].length - petWidth; col++) {
            if (isBottomRowWalkable(walkMap, row, col, petWidth)) {
                const dist = Math.abs(startRow - row) + Math.abs(startCol - col);
                if (dist < minDist) {
                    minDist = dist;
                    closest = { row, col };
                }
            }
        }
    }
    return closest;
}

// Global pointer up handler
document.addEventListener('pointerup', function(e) {
    if (e.pointerType === "mouse" && e.button !== 0) return;
    
    // Clear any hold timer
    if (holdTimer) {
        clearInterval(holdTimer);
    }
    
    if (isDragging && currentObject) {
    const left = parseInt(currentObject.style.left);
    const top = parseInt(currentObject.style.top);

    const snappedLeft = Math.round(left / unitSize) * unitSize;
    const snappedTop = Math.round((top + currentObject.offsetHeight) / unitSize) * unitSize - currentObject.offsetHeight;

    currentObject.style.left = snappedLeft + 'px';
    currentObject.style.top = snappedTop + 'px';
    currentObject.classList.remove('dragging');

    if ([...currentObject.classList].some(cls => cls.includes("pet"))) {
        const walkMap = generateWalkabilityMap();

        const petWidthInTiles = Math.ceil(currentObject.offsetWidth / unitSize);
        const petHeightInTiles = Math.ceil(currentObject.offsetHeight / unitSize);

        // Current tile coordinates (top-left of pet)
        let tileX = Math.round(parseInt(currentObject.style.left) / unitSize);
        let tileY = Math.round(parseInt(currentObject.style.top) / unitSize);

        // The bottom row of the pet in tile coordinates
        let bottomRow = tileY + petHeightInTiles - 1;

        // If bottom row not walkable, find closest position where **entire bottom row** is walkable
        if (!isBottomRowWalkable(walkMap, bottomRow, tileX, petWidthInTiles)) {
            const closest = findClosestWalkablePosition(walkMap, bottomRow, tileX, petWidthInTiles);
            if (closest) {
                // Align pet so **bottom row** sits on walkable tiles
                currentObject.style.left = closest.col * unitSize + 'px';
                currentObject.style.top = (closest.row - petHeightInTiles + 1) * unitSize + 'px';
            } else {
                messageToTheUser("Augintiniui nra vietos vaikioti!");
            }
        }
        predictAndSetZIndex(currentObject);

    }

    clearPlacementHighlights();

    if (editing && currentObject._placementMap) {
        const canPlace = checkPlacement(currentObject, currentObject._placementMap, unitSize);
        if (!canPlace) {
            currentObject.style.left = `calc(${currentObject._originalCoords[0]} * var(--unit-size))`;
            currentObject.style.top = `calc((${currentObject._originalCoords[1] + 1} * var(--unit-size)) - ${currentObject.offsetHeight}px)`;
        }
    }

    isDragging = false;
    currentObject = null;
    } else if (currentObject && !editing) {
        // Only trigger interactions in normal mode and if we have a current object
        for (const cls of currentObject.classList) {
            if (objectInteractions[cls]) {
                objectInteractions[cls](currentObject);
                break; // stop after first match
            }
        }
        currentObject = null;
    }
    
    // Hide delete icons when clicking elsewhere (only in edit mode)
    if (editing) {
        if (!e.target.closest('.delete-icon')) {
            const clickedObject = e.target.closest('.room-object');
            if (!clickedObject) {
                removeAllDeleteIcons();
            }
        } else {
            removeObjectByClickingDeleteIcon(e.target.closest('.delete-icon'))
        }
    }
});


function movePetToTile(pet, startCoord, endCoord, speed = 300) {
    if (!pet) return Promise.resolve();
    
    const [startCol, startRow] = startCoord;
    const [endCol, endRow] = endCoord;
    
    const path = findPath(startCol, startRow, endCol, endRow, pet.id);
    
    if (!path || path.length === 0) {
        return Promise.resolve();
    }

    if (startCoord.length === endCoord.length && startCoord.every((val, i) => val === endCoord[i])) {
        return Promise.resolve();
    }
    
    return new Promise((resolve) => {
        moveObjectAlongPath(pet.id, path, speed, resolve);
    });
}

// Helper: only bottom row must be walkable
function canPlaceObjectAt(x, y, width, height, walkabilityMap) {
    width = Math.ceil(width / unitSize);
    height = Math.ceil(height / unitSize);
    
    const topRow = y - (height - 1);

    // Check bounds first (entire object must fit in map vertically & horizontally)
    if (topRow < 0 || y >= walkabilityMap.length ||
        x < 0 || x + width - 1 >= walkabilityMap[0].length) {
        return false;
    }

    //  Only check bottom row for walkability
    for (let c = x; c < x + width; c++) {
        if (!walkabilityMap[y][c] || !walkabilityMap[y][c].walkable) {
            return false;
        }
    }

    // Upper rows don't need to be walkable
    return true;
}

// Pathfinding function with bottom-left reference - FIXED
function findPath(startCol, startRow, endCol, endRow, objectId) {
    // Get object size in tiles
    const object = document.getElementById(objectId);
    if (!object) {
        console.error("Object not found:", objectId);
        return null;
    }

    const objWidth = object.offsetWidth;
    const objHeight = object.offsetHeight;
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const widthInTiles = Math.ceil(objWidth / unitSize);

    // Generate walkability map
    const walkabilityMap = generateWalkabilityMap();
    
    // Add safety check
    if (!walkabilityMap || walkabilityMap.length === 0) {
        console.error("Failed to generate walkability map");
        return null;
    }

    // Validate start & end
    if (!canPlaceObjectAt(startCol, startRow, objWidth, objHeight, walkabilityMap)) {
        console.log("Start position is not valid for object bottom");
        return null;
    }
    if (!canPlaceObjectAt(endCol, endRow, objWidth, objHeight, walkabilityMap)) {
        console.log(endCol, endRow)
        console.log("End position is not valid for object bottom");
        return null;
    }

    // Helper function to check if movement is allowed for the entire object
    function canMoveInDirection(fromCol, fromRow, dirIndex) {
        // For each tile the object occupies at the current position
        for (let c = fromCol; c < fromCol + widthInTiles; c++) {
            if (c >= walkabilityMap[0].length || 
                !walkabilityMap[fromRow] || 
                !walkabilityMap[fromRow][c] || 
                !walkabilityMap[fromRow][c].allowedDirections || 
                !walkabilityMap[fromRow][c].allowedDirections[dirIndex]) {
                return false;
            }
        }
        return true;
    }

    // Directions: up, right, down, left
    const directions = [
        [0, -1], // up (col, row - 1)
        [1, 0],  // right (col + 1, row)
        [0, 1],  // down (col, row + 1)
        [-1, 0]  // left (col - 1, row)
    ];

    // Track visited states for bottom-left corner
    const visited = Array(walkabilityMap.length).fill().map(
        () => Array(walkabilityMap[0].length).fill(false)
    );

    const queue = [[startCol, startRow, []]];
    visited[startRow][startCol] = true;

    while (queue.length > 0) {
        const [col, row, path] = queue.shift();

        for (let dirIndex = 0; dirIndex < directions.length; dirIndex++) {
            const [dc, dr] = directions[dirIndex];
            
            // CHECK DIRECTIONAL MOVEMENT FIRST, before calculating new position
            if (!canMoveInDirection(col, row, dirIndex)) {
                continue;
            }
            
            const newCol = col + dc;
            const newRow = row + dr;

            // Destination reached?
            if (newCol === endCol && newRow === endRow) {
                return [...path, [newCol, newRow]];
            }

            // Rest of your checks...
            if (newRow < 0 || newRow >= walkabilityMap.length ||
                newCol < 0 || newCol >= walkabilityMap[0].length ||
                visited[newRow][newCol]) {
                continue;
            }

            if (!canPlaceObjectAt(newCol, newRow, objWidth, objHeight, walkabilityMap)) {
                continue;
            }

            // Valid move
            visited[newRow][newCol] = true;
            queue.push([newCol, newRow, [...path, [newCol, newRow]]]);
        }
    }

    console.log("No path found after BFS search");
    return null;
}

function generateWalkabilityMap() {
    // Add safety check for roomLayout
    if (!roomLayout || roomLayout.length === 0) {
        console.error("roomLayout is not defined or empty");
        return null;
    }
    
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const map = [];

    // Initialize map with basic walkability
    for (let row = 0; row < roomLayout.length; row++) {
        map[row] = [];
        for (let col = 0; col < roomLayout[0].length; col++) {
            const tileType = roomLayout[row][col];

            // Only floor (1) and boundary (3) tiles are walkable
            const isWalkable = (tileType === 1 || tileType === 3);

            map[row][col] = {
                walkable: isWalkable,
                allowedDirections: [true, true, true, true] // up, right, down, left
            };
        }
    }

    // Apply boundary tile restrictions (with safety checks)
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (roomLayout[row][col] === 3) { // boundary tile
                if (row + 1 < roomLayout.length) {
                    let hasNonPassableBottomBelow = false;

                    // Add safety check for userObjectAssets
                    if (userObjectAssets && gameAssetIndex) {
                        Object.entries(userObjectAssets).forEach(([assetId, asset]) => {
                            const assetData = gameAssetIndex[asset.assetIndex];
                            if (!assetData) return;

                            const [assetX, assetY] = asset.position; // bottom-left corner
                            const element = document.getElementById(assetId);
                            if (!element) return;

                            const assetWidth = Math.ceil(element.offsetWidth / unitSize);
                            const assetHeight = Math.ceil(element.offsetHeight / unitSize);

                            const topRowOfAsset = assetY - assetHeight + 1;
                            const bottomRowOfAsset = assetY;

                            //  New steppable check: mark middle rows unwalkable
                            if (assetData.steppable === false) {
                                for (let r = topRowOfAsset + 1; r < bottomRowOfAsset; r++) {
                                    if (r >= 0 && r < roomLayout.length) {
                                        for (let c = assetX; c < assetX + assetWidth; c++) {
                                            if (c >= 0 && c < roomLayout[0].length) {
                                                map[r][c].walkable = false;
                                            }
                                        }
                                    }
                                }
                            }

                            // Existing passable check for boundary tiles
                            if (assetData.passable === false) {
                                //  Only if (row+1, col) is bottom row of asset
                                if (row + 1 === bottomRowOfAsset &&
                                    col >= assetX && col < assetX + assetWidth) {
                                    hasNonPassableBottomBelow = true;
                                }
                            }
                        });
                    }

                    if (hasNonPassableBottomBelow) {
                        map[row][col].walkable = false;
                    }
                }
            }
        }
    }

    // Set directional movement restrictions (with safety checks)
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (!map[row][col].walkable) continue;

            if (userObjectAssets && gameAssetIndex) {
                Object.entries(userObjectAssets).forEach(([assetId, asset]) => {
                    const assetData = gameAssetIndex[asset.assetIndex];
                    if (!assetData) return;

                    const [assetX, assetY] = asset.position;
                    const element = document.getElementById(assetId);
                    if (!element) return;

                    const assetWidth = Math.ceil(element.offsetWidth / unitSize);
                    const assetHeight = Math.ceil(element.offsetHeight / unitSize);

                    const topRowOfAsset = assetY - assetHeight + 1;
                    const bottomRowOfAsset = assetY;
                    const rowAboveBottom = bottomRowOfAsset - 1;

                    //  NEW: Special handling for food-bowl items
                    if (element.className.includes('food-bowl')) {
                        // Block upward and downward movement on the food-bowl's cells
                        if (row === bottomRowOfAsset &&
                            col >= assetX && col < assetX + assetWidth) {
                            map[row][col].allowedDirections[0] = false; // up
                            map[row][col].allowedDirections[2] = false; // down
                        }
                        
                        // Block upward movement on cells one row below the food-bowl
                        if (row === bottomRowOfAsset + 1 &&
                            col >= assetX && col < assetX + assetWidth) {
                            map[row][col].allowedDirections[0] = false; // up
                        }
                    }

                    // Only consider passable === false for movement restrictions
                    if (assetData.passable === false) {
                        if (assetHeight === 1) {
                            // Case 3: single-height asset - block movement on the asset tile itself
                            if (row === bottomRowOfAsset &&
                                col >= assetX && col < assetX + assetWidth) {
                                map[row][col].allowedDirections[0] = false; // up
                                map[row][col].allowedDirections[2] = false; // down
                            }
                        } else {
                            // Cases 1 & 2: multi-height assets
                            // Case 1: current tile is bottom row of the asset
                            if (row === bottomRowOfAsset &&
                                col >= assetX && col < assetX + assetWidth) {
                                map[row][col].allowedDirections[0] = false; // up
                            }

                            // Case 2: current tile is directly above bottom row of asset
                            if (row === rowAboveBottom &&
                                col >= assetX && col < assetX + assetWidth) {
                                map[row][col].allowedDirections[2] = false; // down
                            }
                        }
                    }
                });
            }
        }
    }
    return map;
}


// Global variable to track active movements
const activeMovements = new Map();

// Function to move an object along a path
// Function to move an object along a path
function moveObjectAlongPath(objectId, path, speed = 300, onComplete) {
    const object = document.getElementById(objectId);
    if (!object || !path?.length) {
        onComplete?.();
        return;
    }

    cancelMovement(objectId); // Cancel any existing movement

    let currentStep = 0;
    const movementId = Date.now() + Math.random(); // Unique ID for this movement
    activeMovements.set(objectId, { 
        id: movementId, 
        interval: null,
        cleanupTimeout: null  // Track cleanup timeout too
    });

    function moveToNextStep() {
        const movement = activeMovements.get(objectId);
        if (!movement || movement.id !== movementId) return;

        if (currentStep >= path.length) {
            object.style.transition = '';
            activeMovements.delete(objectId);
            onComplete?.();
            return;
        }

        const [col, row] = path[currentStep];
        const [prevCol, prevRow] = currentStep > 0 ? path[currentStep - 1] : getObjectCoordinates(objectId);
        const deltaCol = col - prevCol;
        const deltaRow = row - prevRow;

        // SOLUTION 1: Pre-adjust z-index BEFORE starting the transition
        typeof predictAndSetZIndex === 'function' && predictAndSetZIndex(object, col, row);

        // Preserve your original animation logic exactly
        if (deltaRow > 0) {
            // Moving down
            setObjectAnimation(object, `${objectId}-walks-downwards`);
        } else if (deltaRow < 0) {
            // Moving up
            setObjectAnimation(object, `${objectId}-walks-upwards`);
        } else if (deltaCol !== 0) {
            // Moving horizontally
            setObjectAnimation(object, `${objectId}-walks-sideways`);
            
            // Set direction (sprite originally faces left)
            if (deltaCol < 0) {
                object.classList.remove("pet-right");
                object.classList.add("pet-left");
            } else {
                object.classList.remove("pet-left");
                object.classList.add("pet-right");
            }
        }

        // SOLUTION 2: Add a small delay before starting the visual transition
        // This ensures z-index changes are processed first
        requestAnimationFrame(() => {
            object.style.transition = `top ${speed}ms linear, left ${speed}ms linear`;
            object.style.top = `calc((${row} * var(--unit-size)) - (var(--pet-size) - var(--unit-size)))`;
            object.style.left = `calc(${col} * var(--unit-size))`;
        });

        currentStep++;
        movement.interval = setTimeout(moveToNextStep, speed);

        // Handle final step adjustments
        if (currentStep === path.length) {
            setTimeout(() => {
                if (activeMovements.has(objectId) && activeMovements.get(objectId).id === movementId) {
                    object.style.transition = '';
                    activeMovements.delete(objectId);
                    typeof predictAndSetZIndex === 'function' && predictAndSetZIndex(object, col, row);
                    setObjectAnimation(object, `${objectId}-stands-idle`);
                    onComplete?.();
                }
            }, speed);
        }
    }

    moveToNextStep();
}

function predictAndSetZIndex(movingObject = null, nextCol = null, nextRow = null) {
    
    // Get all room objects (including pets)
    const allObjects = Array.from(document.querySelectorAll('.room-object, .pet'));

    let objectOccupiedTiles = {};

    if (!movingObject) {
        const objects = document.querySelectorAll('.room-object');
        objects.forEach(obj => {
            obj.style.zIndex = ''; // removes inline z-index
        });
    }

    // Build occupied tiles map
    allObjects.forEach(obj => {
    // Check both userObjectAssets and furniturePreviewDict
    const assetSource = userObjectAssets[obj.id] || furniturePreviewDict[obj.id];
    
    if (assetSource) {
        const objPlacingOrder = gameAssetIndex[assetSource.assetIndex]?.placingIndex;
        if (objPlacingOrder === 5 || objPlacingOrder === 9) {
            return;
        }
    }
    let coords = getObjectCoordinates(obj.id);
        // Only apply prediction if we have a moving object
        if (movingObject && nextCol && nextRow) {
            if (obj.id === movingObject.id) {
                coords = [nextCol, nextRow];
            }
        }
        const objectWidth = Math.ceil(obj.offsetWidth / unitSize);
        const objectHeight = Math.ceil(obj.offsetHeight / unitSize);
        const occupiedTiles = getTilesOccupiedByObject(coords, objectWidth, objectHeight);
        objectOccupiedTiles[obj.id] = occupiedTiles;
    });

    const requirePets = movingObject !== null;
    applyZIndexLogic(buildClusters(objectOccupiedTiles, requirePets), movingObject, nextRow);
}

function buildClusters(objectOccupiedTiles, requirePets = true) {
    const objectIds = Object.keys(objectOccupiedTiles);

    // Helper: check if two objects overlap
    function doObjectsOverlap(id1, id2) {
        const tiles1 = objectOccupiedTiles[id1];
        const tiles2 = objectOccupiedTiles[id2];
        return tiles1.some(t1 => tiles2.some(t2 => t1[0] === t2[0] && t1[1] === t2[1]));
    }

    // Step 1: find bigger clusters of overlapping objects
    let visited = new Set();
    let biggerClusters = [];

    objectIds.forEach(objId => {
        if (visited.has(objId)) return;

        let queue = [objId];
        let currentCluster = [];

        while (queue.length > 0) {
            const curr = queue.pop();
            if (visited.has(curr)) continue;
            visited.add(curr);
            currentCluster.push(curr);

            objectIds.forEach(other => {
                if (!visited.has(other) && doObjectsOverlap(curr, other)) {
                    queue.push(other);
                }
            });
        }

        if (currentCluster.length > 0) {
            biggerClusters.push(currentCluster);
        }
    });

    // Step 2: split each bigger cluster into pets + non-pet subclusters
    let finalClusters = [];

    biggerClusters.forEach(cluster => {
        const pets = cluster.filter(id => {
            const el = document.getElementById(id);
            return el && el.classList.contains('pet');
        });
        const nonPets = cluster.filter(id => {
            const el = document.getElementById(id);
            return el && !el.classList.contains('pet');
        });

        // Skip clusters based on requirePets flag
        if (requirePets) {
            // Original behavior: only include clusters with both pets and non-pets
            if (pets.length === 0 || nonPets.length === 0) {
                return;
            }
        } else {
            // Initialization behavior: skip only if cluster is empty
            if (cluster.length === 0) {
                return;
            }
        }

        // Build non-pet subclusters by finding overlapping groups among non-pets
        let nonPetVisited = new Set();
        let nonPetClusters = [];

        nonPets.forEach(objId => {
            if (nonPetVisited.has(objId)) return;

            let queue = [objId];
            let currentSubCluster = [];

            while (queue.length > 0) {
                const curr = queue.pop();
                if (nonPetVisited.has(curr)) continue;
                nonPetVisited.add(curr);
                currentSubCluster.push(curr);

                nonPets.forEach(other => {
                    if (!nonPetVisited.has(other) && doObjectsOverlap(curr, other)) {
                        queue.push(other);
                    }
                });
            }

            if (currentSubCluster.length > 0) {
                nonPetClusters.push(currentSubCluster);
            }
        });

        finalClusters.push([pets, nonPetClusters]);
    });

    return finalClusters;
}

function buildAllClusters(objectOccupiedTiles) {
    const objectIds = Object.keys(objectOccupiedTiles);

    // Helper: check if two objects overlap
    function doObjectsOverlap(id1, id2) {
        const tiles1 = objectOccupiedTiles[id1];
        const tiles2 = objectOccupiedTiles[id2];
        return tiles1.some(t1 => tiles2.some(t2 => t1[0] === t2[0] && t1[1] === t2[1]));
    }

    // Step 1: find bigger clusters of overlapping objects
    let visited = new Set();
    let biggerClusters = [];

    objectIds.forEach(objId => {
        if (visited.has(objId)) return;

        let queue = [objId];
        let currentCluster = [];

        while (queue.length > 0) {
            const curr = queue.pop();
            if (visited.has(curr)) continue;
            visited.add(curr);
            currentCluster.push(curr);

            objectIds.forEach(other => {
                if (!visited.has(other) && doObjectsOverlap(curr, other)) {
                    queue.push(other);
                }
            });
        }

        if (currentCluster.length > 0) {
            biggerClusters.push(currentCluster);
        }
    });

    // Step 2: split each bigger cluster into pets + non-pet subclusters
    let finalClusters = [];

    biggerClusters.forEach(cluster => {
        const pets = cluster.filter(id => {
            const el = document.getElementById(id);
            return el && el.classList.contains('pet');
        });
        const nonPets = cluster.filter(id => {
            const el = document.getElementById(id);
            return el && !el.classList.contains('pet');
        });

        // For initialization, include all clusters (even without pets)
        if (cluster.length === 0) {
            return;
        }

        // Build non-pet subclusters by finding overlapping groups among non-pets
        let nonPetVisited = new Set();
        let nonPetClusters = [];

        nonPets.forEach(objId => {
            if (nonPetVisited.has(objId)) return;

            let queue = [objId];
            let currentSubCluster = [];

            while (queue.length > 0) {
                const curr = queue.pop();
                if (nonPetVisited.has(curr)) continue;
                nonPetVisited.add(curr);
                currentSubCluster.push(curr);

                nonPets.forEach(other => {
                    if (!nonPetVisited.has(other) && doObjectsOverlap(curr, other)) {
                        queue.push(other);
                    }
                });
            }

            if (currentSubCluster.length > 0) {
                nonPetClusters.push(currentSubCluster);
            }
        });

        finalClusters.push([pets, nonPetClusters]);
    });

    return finalClusters;
}

function applyZIndexLogic(overlapClusters, movingObject = null, nextRow = null) {
    // List of classes that should appear in front of pets
    const itemsInFrontOfPetClasses = ['food-bowl', 'water-bowl'];
    const clusteredItemsZIndexDelta = {};

    overlapClusters.forEach(cluster => {
        let clusterInfo = {
            passable: {
                items: [],
                pos: 0,
                "items-in-front-of-pet": false,
                pet: false
            }
        };

        const pets = cluster[0]; // pet IDs
        const objectSubclusters = cluster[1];
        let itemsInFrontOfPetCounter = 1;
        let subclusterCounter = 1;

        // --- Step 0: Identify wall-only vs floor/boundary items ---
        const petIds = new Set(pets);
        const allObjects = objectSubclusters.flat(Infinity).filter(item => !petIds.has(item));
        const wallOnlyItems = [];
        const floorBoundaryItems = [];

        allObjects.forEach(item => {
            if (!item && item !== 0) return;
            const el = document.getElementById(item);
            if (!el) return;

            const coords = getTilesOccupiedByObject(
                getObjectCoordinates(item),
                Math.ceil(el.offsetWidth / unitSize),
                Math.ceil(el.offsetHeight / unitSize)
            );

            let hasFloorOrBoundary = false;
            let allWall = true;

            coords.forEach(([x, y]) => {
                const tile = roomLayout[y]?.[x];
                const tileType = tile?.type ?? tile;
                if (tileType === 1 || tileType === 3) { // floor or boundary
                    hasFloorOrBoundary = true;
                    allWall = false;
                }
                if (tileType !== 2) { // not wall
                    allWall = allWall && tileType === 2;
                }
            });

            if (hasFloorOrBoundary) floorBoundaryItems.push(item);
            else if (allWall) wallOnlyItems.push(item);
        });

        // --- Step 0b: Identify special overlap cases with placingIndex 8 ---
        const specialOverlapItems = new Set(); // Wall items that should appear in front

        if (floorBoundaryItems.length && wallOnlyItems.length) {
            floorBoundaryItems.forEach(floorItemId => {
                const floorEl = document.getElementById(floorItemId);
                if (!floorEl) return;

                const floorAsset = userObjectAssets[floorItemId] || furniturePreviewDict[floorItemId];
                if (!floorAsset) return;

                const floorAssetData = gameAssetIndex[floorAsset.assetIndex];
                if (!floorAssetData || !floorAssetData.placingMap) return;

                const [floorX, floorY] = getObjectCoordinates(floorItemId);
                const floorWidth = Math.ceil(floorEl.offsetWidth / unitSize);
                const floorHeight = Math.ceil(floorEl.offsetHeight / unitSize);

                const floorTopRow = floorY - floorHeight + 1;
                const floorBottomRow = floorY;

                wallOnlyItems.forEach(wallItemId => {
                    const wallEl = document.getElementById(wallItemId);
                    if (!wallEl) return;

                    const wallAsset = userObjectAssets[wallItemId] || furniturePreviewDict[wallItemId];
                    if (!wallAsset) return;

                    const wallAssetData = gameAssetIndex[wallAsset.assetIndex];
                    if (!wallAssetData || wallAssetData.placingIndex !== 8) return;

                    const [wallX, wallY] = getObjectCoordinates(wallItemId);
                    const wallWidth = Math.ceil(wallEl.offsetWidth / unitSize);
                    const wallHeight = Math.ceil(wallEl.offsetHeight / unitSize);
                    const wallTopRow = wallY - wallHeight + 1;
                    const wallBottomRow = wallY;

                    const xOverlap = wallX < floorX + floorWidth && wallX + wallWidth > floorX;
                    const yOverlap = wallTopRow <= floorBottomRow && wallBottomRow >= floorTopRow;

                    if (xOverlap && yOverlap) {
                        let hasValidOverlap = false;

                        for (let wy = wallTopRow; wy <= wallBottomRow; wy++) {
                            for (let wx = wallX; wx < wallX + wallWidth; wx++) {
                                if (wy >= floorTopRow && wy <= floorBottomRow &&
                                    wx >= floorX && wx < floorX + floorWidth) {

                                    const relativeY = wy - floorTopRow;
                                    const relativeX = wx - floorX;
                                    const placingMapIndex = relativeY * floorWidth + relativeX;
                                    const placingMapValue = floorAssetData.placingMap[placingMapIndex];

                                    if (placingMapValue === 8 ||
                                        (Array.isArray(placingMapValue) && placingMapValue.includes(8))) {
                                        hasValidOverlap = true;
                                        break;
                                    }
                                }
                            }
                            if (hasValidOverlap) break;
                        }

                        if (hasValidOverlap) specialOverlapItems.add(wallItemId);
                    }
                });
            });
        }

        // --- Step 1: Process object subclusters (non-pets) ---
        objectSubclusters.forEach(subcluster => {
            const itemsZIndexes = {};
            const items = Array.isArray(subcluster) ? subcluster.flat(Infinity) : [subcluster];
            const nonPassKey = `non-passable-${subclusterCounter}`;

            clusterInfo[nonPassKey] = {
                items: [],
                "items-in-front-of-pet": false,
                pet: false,
                pos: 0
            };

            items.forEach(item => {
                if (!item && item !== 0) return;

                const userAsset = userObjectAssets[item] || furniturePreviewDict[item];
                if (!userAsset || userAsset.assetIndex == null) return;

                const asset = gameAssetIndex[userAsset.assetIndex];
                if (!asset) return;

                const el = document.getElementById(item);

                if (asset.passable) {
                    clusterInfo.passable.items.push(item);
                    if (el) itemsZIndexes[item] = parseInt(window.getComputedStyle(el).zIndex) || 0;
                    return;
                }

                if (!el) {
                    clusterInfo[nonPassKey].items.push(item);
                    return;
                }

                itemsZIndexes[item] = parseInt(window.getComputedStyle(el).zIndex) || 0;

                const hasItemInFrontOfPetClass = itemsInFrontOfPetClasses.some(className =>
                    el.classList.contains(className)
                );

                if (hasItemInFrontOfPetClass) {
                    clusterInfo[`items-in-front-of-pet-${itemsInFrontOfPetCounter}`] = {
                        items: [item],
                        "items-in-front-of-pet": true,
                        pet: false,
                        pos: el.dataset.pos || 0
                    };
                    itemsInFrontOfPetCounter++;
                } else {
                    clusterInfo[nonPassKey].items.push(item);
                }
            });

            if (Object.keys(itemsZIndexes).length > 0) {
                const allItems = Object.entries(itemsZIndexes).map(([item, zIndex]) => ({
                    item,
                    zIndex,
                    pos: getObjectCoordinates(item)[1]
                }));

                allItems.sort((a, b) => {
                    if (a.zIndex !== b.zIndex) return a.zIndex - b.zIndex;
                    return a.pos - b.pos;
                });

                const minZ = allItems[0].zIndex;
                let currentZ = minZ;

                for (let i = 0; i < allItems.length; i++) {
                    const current = allItems[i];
                    if (i > 0) {
                        const prev = allItems[i - 1];
                        if (current.zIndex > prev.zIndex) currentZ = itemsZIndexes[prev.item] + (current.zIndex - prev.zIndex);
                        else if (current.pos > prev.pos) currentZ = itemsZIndexes[prev.item] + 1;
                        else currentZ = itemsZIndexes[prev.item];
                    }
                    itemsZIndexes[current.item] = currentZ;
                }

                for (const [key, value] of Object.entries(itemsZIndexes)) {
                    if (value > minZ) clusteredItemsZIndexDelta[key] = value - minZ;
                }
            }

            subclusterCounter++;
        });

        // --- Step 2: Process pets (unchanged) ---
        pets.forEach(petId => {
            clusterInfo[petId] = {
                items: [petId],
                "items-in-front-of-pet": false,
                pet: true,
                pos: 0
            };
        });

        // --- Step 3: Calculate positions ---
        Object.entries(clusterInfo).forEach(([key, value]) => {
            let lowestClusterRow = 0;
            value.items.forEach(item => {
                const itemsRow = getObjectCoordinates(item)[1];
                if (itemsRow > lowestClusterRow) lowestClusterRow = itemsRow;
            });
            value.pos = lowestClusterRow;
            if (movingObject && nextRow && key === movingObject.id) value.pos = nextRow;
        });

        // --- Step 4: Sort and assign z-index ---
        let entries = Object.entries(clusterInfo);
        const passableEntries = entries.filter(([key]) => key === 'passable');
        const nonPassableEntries = entries.filter(([key]) => key !== 'passable');

        nonPassableEntries.sort((a, b) => {
            const aPos = a[1].pos || 0, bPos = b[1].pos || 0;
            if (aPos !== bPos) return aPos - bPos;
            const aIFP = a[1]["items-in-front-of-pet"], bIFP = b[1]["items-in-front-of-pet"];
            const aPet = a[1].pet, bPet = b[1].pet;
            if (aPet && bPet) return 0;
            if (aIFP && bIFP) return 0;
            if (aIFP && !bIFP) return 1;
            if (bIFP && !aIFP) return -1;
            if (aPet && !bIFP && !bPet) return 1;
            if (bPet && !aIFP && !aPet) return -1;
            return 0;
        });

        entries = [...passableEntries, ...nonPassableEntries];

        let zIndexStart = 3;
        let maxWallZ = 0; // Track the highest wall z-index

        entries.forEach((entry, idx) => {
            const [key, value] = entry;
            value.order = idx + 1;
            let zIndex = zIndexStart + idx;
            let maxDelta = 0;

            value.items.forEach(item => {
                const el = document.getElementById(item);
                const itemDelta = clusteredItemsZIndexDelta[item] || 0;
                maxDelta = Math.max(maxDelta, itemDelta);

                let finalZIndex = zIndex + itemDelta;

                // Apply special overlap boost for placingIndex 8 items
                if (specialOverlapItems.has(item)) {
                    let maxFloorZ = finalZIndex;
                    floorBoundaryItems.forEach(floorId => {
                        const floorEl = document.getElementById(floorId);
                        if (floorEl) {
                            const floorZ = parseInt(window.getComputedStyle(floorEl).zIndex) || 0;
                            maxFloorZ = Math.max(maxFloorZ, floorZ);
                        }
                    });
                    finalZIndex = maxFloorZ + 1;
                }

                if (el) {
                    el.style.zIndex = finalZIndex;

                    // Track max wall z-index
                    if (wallOnlyItems.includes(item)) {
                        maxWallZ = Math.max(maxWallZ, finalZIndex);
                    }
                }
            });

            zIndexStart += maxDelta;
        });

        // --- Step 5: Ensure pet is above walls ---
        pets.forEach(petId => {
            const petEl = document.getElementById(petId);
            if (petEl) {
                const petZ = parseInt(window.getComputedStyle(petEl).zIndex) || 0;
                if (petZ <= maxWallZ) petEl.style.zIndex = maxWallZ + 1;
            }
        });

        clusterInfo = Object.fromEntries(entries);
    });
}


function generateWalkabilityMap() {
    // Add safety check for roomLayout
    if (!roomLayout || roomLayout.length === 0) {
        console.error("roomLayout is not defined or empty");
        return null;
    }

    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const map = [];

    // Initialize map with basic walkability
    for (let row = 0; row < roomLayout.length; row++) {
        map[row] = [];
        for (let col = 0; col < roomLayout[0].length; col++) {
            const tileType = roomLayout[row][col];
            // Only floor (1) and boundary (3) tiles are walkable
            const isWalkable = (tileType === 1 || tileType === 3);
            map[row][col] = {
                walkable: isWalkable,
                allowedDirections: [true, true, true, true] // up, right, down, left
            };
        }
    }

    // Apply boundary tile restrictions (with safety checks)
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (roomLayout[row][col] === 3) { // boundary tile
                if (row + 1 < roomLayout.length) {
                    let hasNonPassableBottomBelow = false;

                    // Add safety check for userObjectAssets
                    if (userObjectAssets && gameAssetIndex) {
                        Object.entries(userObjectAssets).forEach(([assetId, asset]) => {
                            const assetData = gameAssetIndex[asset.assetIndex];
                            if (!assetData) return;

                            const [assetX, assetY] = asset.position;
                            const element = document.getElementById(assetId);
                            if (!element) return;

                            const assetWidth = Math.ceil(element.offsetWidth / unitSize);
                            const assetHeight = Math.ceil(element.offsetHeight / unitSize);
                            const topRowOfAsset = assetY - assetHeight + 1;
                            const bottomRowOfAsset = assetY;

                            //  New steppable check: mark middle rows unwalkable
                            if (assetData.steppable === false) {
                                for (let r = topRowOfAsset + 1; r < bottomRowOfAsset; r++) {
                                    if (r >= 0 && r < roomLayout.length) {
                                        for (let c = assetX; c < assetX + assetWidth; c++) {
                                            if (c >= 0 && c < roomLayout[0].length) {
                                                map[r][c].walkable = false;
                                            }
                                        }
                                    }
                                }
                            }

                            // Existing passable check for boundary tiles
                            if (assetData.passable === false) {
                                //  Only if (row+1, col) is bottom row of asset
                                if (row + 1 === bottomRowOfAsset && col >= assetX && col < assetX + assetWidth) {
                                    hasNonPassableBottomBelow = true;
                                }
                            }
                        });
                    }

                    if (hasNonPassableBottomBelow) {
                        map[row][col].walkable = false;
                    }
                }
            }
        }
    }

    // Set directional movement restrictions (with safety checks)
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (!map[row][col].walkable) continue;

            if (userObjectAssets && gameAssetIndex) {
                Object.entries(userObjectAssets).forEach(([assetId, asset]) => {
                    const assetData = gameAssetIndex[asset.assetIndex];
                    if (!assetData) return;

                    const [assetX, assetY] = asset.position;
                    const element = document.getElementById(assetId);
                    if (!element) return;

                    const assetWidth = Math.ceil(element.offsetWidth / unitSize);
                    const assetHeight = Math.ceil(element.offsetHeight / unitSize);
                    const topRowOfAsset = assetY - assetHeight + 1;
                    const bottomRowOfAsset = assetY;
                    const rowAboveBottom = bottomRowOfAsset - 1;

                    //  NEW: Special handling for food-bowl items
                    if (element.className.includes('food-bowl')) {
                        // Block upward and downward movement on the food-bowl's cells
                        if (row === bottomRowOfAsset && col >= assetX && col < assetX + assetWidth) {
                            map[row][col].allowedDirections[0] = false; // up
                            map[row][col].allowedDirections[2] = false; // down
                        }
                        // Block upward movement on cells one row below the food-bowl
                        if (row === bottomRowOfAsset + 1 && col >= assetX && col < assetX + assetWidth) {
                            map[row][col].allowedDirections[0] = false; // up
                        }
                    }

                    // Only consider passable === false for movement restrictions
                    if (assetData.passable === false) {
                        if (assetHeight === 1) {
                            // Case 3: single-height asset - block movement on the asset tile itself
                            if (row === bottomRowOfAsset && col >= assetX && col < assetX + assetWidth) {
                                map[row][col].allowedDirections[0] = false; // up
                                map[row][col].allowedDirections[2] = false; // down
                            }
                        } else {
                            // Cases 1 & 2: multi-height assets
                            // Case 1: current tile is bottom row of the asset
                            if (row === bottomRowOfAsset && col >= assetX && col < assetX + assetWidth) {
                                map[row][col].allowedDirections[0] = false; // up
                            }
                            // Case 2: current tile is directly above bottom row of asset
                            if (row === rowAboveBottom && col >= assetX && col < assetX + assetWidth) {
                                map[row][col].allowedDirections[2] = false; // down
                            }
                        }
                    }
                });
            }
        }
    }

    return map;
}


function isOverlapping(petObject, targetObject) {
    const overlappingObjects = detectTileCollision(petObject.id);
    return overlappingObjects.includes(targetObject);
}

function findPetOverlapClusters(data) {
    const idToKey = {}; // map key -> element id
    for (const key of Object.keys(data)) {
        idToKey[key] = key;
    }

    // Step 1: Build overlap graph
    const overlapGraph = {}; // node id -> Set of overlapping node ids

    for (const keyA of Object.keys(data)) {
        const objA = document.getElementById(idToKey[keyA]);
        if (!objA) continue;

        for (const keyB of Object.keys(data)) {
            if (keyA === keyB) continue;

            const objB = document.getElementById(idToKey[keyB]);
            if (!objB) continue;

            if (isOverlapping(objA, objB)) {
                if (!overlapGraph[keyA]) overlapGraph[keyA] = new Set();
                if (!overlapGraph[keyB]) overlapGraph[keyB] = new Set();

                overlapGraph[keyA].add(keyB);
                overlapGraph[keyB].add(keyA);
            }
        }
    }

    // Step 2: Find connected components via DFS/BFS
    const visited = new Set();
    const clusters = [];

    function dfs(node, cluster) {
        visited.add(node);
        cluster.push(node);
        (overlapGraph[node] || []).forEach(neighbor => {
            if (!visited.has(neighbor)) dfs(neighbor, cluster);
        });
    }

    for (const key of Object.keys(data)) {
        if (!visited.has(key)) {
            const cluster = [];
            dfs(key, cluster);

            const hasPet = cluster.some(k => document.getElementById(idToKey[k]).classList.contains('pet'));
            const hasNonPet = cluster.some(k => !document.getElementById(idToKey[k]).classList.contains('pet'));

            // Include cluster only if it has at least one pet AND (more than one node or includes a non-pet)
            if (hasPet && (cluster.length > 1 || hasNonPet)) {
                clusters.push(cluster);
            }
        }
    }

    return clusters;
}

function cancelMovement(objectId) {
    const object = document.getElementById(objectId);
    if (activeMovements.has(objectId)) {
        const movement = activeMovements.get(objectId);
        clearTimeout(movement.interval);
        if (object) {
            object.style.transition = '';
        }
        activeMovements.delete(objectId);
        if (object && object.classList.contains("pet")) {
            setObjectAnimation(object, `${object.id}-stands-idle`);
        }
    } else {
        setObjectAnimation(object, `${object.id}-stands-idle`);
    }
}

// Alternative approach: get computed style instead of parsing calc()
function getObjectCoordinates(objectId) {
    const object = document.getElementById(objectId);
    if (!object) return null;

    // Get the unit size
    const unit = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

    // Get computed style (actual pixel values after calc() is processed)
    const computedStyle = window.getComputedStyle(object);
    const leftPx = parseInt(computedStyle.left) || 0;
    const topPx = parseInt(computedStyle.top) || 0;

    const elementHeight = object.offsetHeight; // actual pixel height of element
    const botPx = topPx + elementHeight;

    // Calculate tile coordinates
    const tileX = Math.round(leftPx / unit);
    let tileY;
    tileY = Math.round(botPx / unit) - 1;

    return [tileX, tileY];
}

function detectTileCollision(objectId) {
    const movingObject = document.getElementById(objectId);
    if (!movingObject) return [];

    // Get the moving object's tile position
    const movingObjPos = getObjectCoordinates(objectId);
    if (!movingObjPos) return [];

    const [movingX, movingY] = movingObjPos;

    // Calculate the size of the moving object in tiles
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const movingWidth = Math.ceil(movingObject.offsetWidth / unitSize);
    const movingHeight = Math.ceil(movingObject.offsetHeight / unitSize);

    const overlappingObjects = [];

    // Get all room objects (excluding the moving object)
    const allObjects = document.querySelectorAll('.room-object');

    // Check against all other objects
    allObjects.forEach(targetObj => {
        // Skip the moving object itself
        if (targetObj.id === objectId) return;

        // Get the target object's tile position
        const targetPos = getObjectCoordinates(targetObj.id);
        if (!targetPos) return;

        const [targetX, targetY] = targetPos;

        // Calculate the size of the target object in tiles
        const targetWidth = Math.ceil(targetObj.offsetWidth / unitSize);
        const targetHeight = Math.ceil(targetObj.offsetHeight / unitSize);

        // Check for tile-based collision
        if (movingX < targetX + targetWidth &&
            movingX + movingWidth > targetX &&
            movingY < targetY + targetHeight &&
            movingY + movingHeight > targetY) {
            
            // Collision detected - highlight the colliding object
            targetObj.classList.add('collision-highlight');
            setTimeout(() => {
                targetObj.classList.remove('collision-highlight');
            }, 1000);

            overlappingObjects.push(targetObj); // Add the overlapping DOM element
        }
    });

    return overlappingObjects; // Return array of overlapping DOM elements
}

function getRandomItemFromACategory(category) {
  const container = document.getElementById("room-container");
  if (!container) {
    console.warn("No container with id 'room-container' found.");
    return null;
  }

  const objects = Array.from(container.querySelectorAll(`.${category}`));
  if (objects.length === 0) {
    console.warn("No .food-bowl elements found inside #room-container.");
    return null;
  }

  // Filter bowls that also have the "full" class
  const fullBowls = objects.filter(bowl => bowl.classList.contains("full"));

  // Choose from full ones if available, otherwise from all bowls
  const candidates = fullBowls.length > 0 ? fullBowls : objects;

  const randomIndex = Math.floor(Math.random() * candidates.length);
  return candidates[randomIndex];
}


// Function to change cat background image
function changeCatFacingDirection(pet, direction) {
    if (pet) {
        if (direction === 'left') {
            pet.classList.remove("pet-right");
            pet.classList.add("pet-left");
        } else {
            pet.classList.remove("pet-left");
            pet.classList.add("pet-right");
        }
    } else {
        console.warn("Pet element not found!");
    }
}

async function sendObjectAssetsUpdateToDatabase() {
    // Store original state for rollback
    const originalObjectAssets = JSON.parse(JSON.stringify(userObjectAssets));
    
    // Convert dictionary to array of arrays and stringify
    let objectAssetsString = JSON.stringify(
        Object.values(userObjectAssets).map(entry => [entry.assetIndex, entry.position])
    );

    try {
        const response = await apiFetch(apiBase + 'petGame/objectAssets', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId, objectAssets: objectAssetsString })
        });

        if (!response) {
            return;
        }

        if (response.ok && response.status === 204) {
            // Success - add tick animation
            document.querySelector('.some-purchase-element')?.classList.add('tick-svg');
            return true;
        } else {
            // Failed response - revert local state
            userObjectAssets = originalObjectAssets;
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.error(`Failed to update object assets: ${response.status}`);
            return false;
        }
    } catch (error) {
        // Network error - revert local state
        userObjectAssets = originalObjectAssets;
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.log('Error sending Objects Asset position update:', error);
        return false;
    }
}

async function sendPetAssetsUpdateToDatabase() {
    // Store original state for rollback
    const originalPetAssets = JSON.parse(JSON.stringify(userPetAssets));
    
    // Convert dictionary to array of arrays and stringify
    let petAssetsString = JSON.stringify(convertUserPetAssetsDictToCompactList(userPetAssets));

    try {
        const response = await apiFetch(apiBase + 'petGame/petAssets', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId, petAssets: petAssetsString })
        });

        if (!response) {
            return;
        }

        if (response.ok && response.status === 204) {
            // Success - add tick animation
            document.querySelector('.some-purchase-element')?.classList.add('tick-svg');
            return true;
        } else {
            // Failed response - revert local state
            userPetAssets = originalPetAssets;
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.error(`Failed to update pet assets: ${response.status}`);
            return false;
        }
    } catch (error) {
        // Network error - revert local state
        userPetAssets = originalPetAssets;
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.log('Error sending Pet Asset update:', error);
        return false;
    }
}

async function sendMoneyUpdateToDatabase() {
    // Store original state for rollback
    const originalMoney = userMoney;
    
    try {
        const response = await apiFetch(apiBase + 'petGame/money', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ studentId: userData.userId, money: userMoney })
        });

        if (!response) {
            return;
        }

        if (response.ok && response.status === 204) {
            // Success - update UI and add tick animation
            updateCoinAmounts(userMoney);
            document.querySelector('.some-purchase-element')?.classList.add('tick-svg');
            return true;
        } else {
            // Failed response - revert local state
            userMoney = originalMoney;
            console.error(`Failed to update money: ${response.status}`);
            return false;
        }
    } catch (error) {
        // Network error - revert local state
        userMoney = originalMoney;
        console.log('Error sending Money update:', error);
        return false;
    }
}

function updateCoinAmounts(money) {
    document.querySelectorAll('.coin-amount').forEach(span => {
        span.textContent = money;
    });
}

async function sendPetStatsUpdateToDatabase(petId) {
    const pet = document.getElementById(petId);
    if (!pet?._stats) return false;

    const statList = [
            pet._stats.foodNew,
            pet._stats.waterNew,
            pet._stats.loveNew,
            Math.floor(Date.now() / 1000 / 60)
        ]

    const petsArray = [
        [petId, statList]
    ];

    try {
        const response = await apiFetch(apiBase + 'petGame/petStats', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ studentId: userData.userId, petStats: petsArray })
        });

        if (!response) {
            return;
        }

        if (response.ok) {
            document.querySelector('.some-pet-element')?.classList.add('tick-svg');

            updatePetOnWalkStatsInLocalStorage(petId, statList)

            return true;
        } else {
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.error(`Failed to update pet stats: ${response.status}`);
            return false;
        }
    } catch (error) {
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.error('Error sending pet stats update:', error);
        return false;
    }
}


function updateObjectPositionChanges() {
    const container = document.getElementById("roomObjectsContainer");

    // Loop through all items in userObjectAssets
    for (const [key, asset] of Object.entries(userObjectAssets)) {
        const div = container.querySelector(`#${key}`); // find div by id

        if (div) {
            // Div exists  get tile coordinates and update
            const newCoords = getObjectCoordinates(key); // assume returns [x, y]
            asset.position = newCoords;
        } else {
            // Div not present  set position to empty list
            asset.position = [];
        }
    }

    // Send updated objectAssets to database
    sendObjectAssetsUpdateToDatabase();
}

const toggleEditSaveBtn = document.getElementById("toggle-edit-save-btn");
const cancelEditBtn = document.getElementById("cancel-edit-btn");

let editing = false;

toggleEditSaveBtn.addEventListener("click", () => {
    if (!editing) {
    // switch to Save mode
        toggleEditSaveBtn.textContent = "Isaugoti";
        toggleEditSaveBtn.classList.remove("edit");
        toggleEditSaveBtn.classList.add("save");
        cancelEditBtn.classList.remove("hidden");
        const petElements = document.querySelectorAll('.pet');
        petElements.forEach(pet => {
            pet.style.display = 'none';
        });
        updateStatsBeforeRerunningInitGameAndRenderPets();
        enableObjectDragging();
        predictAndSetZIndex();
    editing = true;
    } else {
        updateObjectPositionChanges();
        const petElements = document.querySelectorAll('.pet');
        petElements.forEach(pet => {
            predictAndSetZIndex(pet);
        });
        updateStatsBeforeRerunningInitGameAndRenderPets();
        renderPets();
        enablePetDragging();
        predictAndSetZIndex();
        resetEditButtonToggle();
        const allPets = document.querySelectorAll("#petContainer .pet");
        if (allPets[0]) {
            displayPetStats(allPets[0].id);
        }
    }
});

cancelEditBtn.addEventListener("click", () => {
    renderRoomObjects();
    resetEditButtonToggle();
    updateStatsBeforeRerunningInitGameAndRenderPets();
    renderPets();
    enablePetDragging();

    predictAndSetZIndex();
    
    const allPets = document.querySelectorAll("#petContainer .pet");
    if (allPets[0]) {
        displayPetStats(allPets[0].id);
    }
});


function updateStatsBeforeRerunningInitGameAndRenderPets() {
    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        increasePetStatsInDisplay(pet.id, "food");
        increasePetStatsInDisplay(pet.id, "water");
        increasePetStatsInDisplay(pet.id, "love");
        petStatsList[pet.id] = [pet._stats.foodNew, pet._stats.waterNew, pet._stats.loveNew, Math.floor(Date.now() / 1000 / 60)]
    });
}

function resetEditButtonToggle() {
    disableObjectDragging();
    const petElements = document.querySelectorAll('.pet');
        petElements.forEach(pet => {
        pet.style.display = 'block';
    });
    toggleEditSaveBtn.textContent = "Perstatyti";
    toggleEditSaveBtn.classList.remove("save");
    toggleEditSaveBtn.classList.add("edit");
    cancelEditBtn.classList.add("hidden");
    editing = false;
}

function getFirstRowOfTileType(number) {
  return roomLayout.findIndex(row => row.includes(number));
}
    
// Function to generate placement validity map and highlight valid tiles
function generatePlacementMap(draggedObjectId) {
    if (!gameAssetIndex || !userObjectAssets) {
        console.error("Game data not loaded");
        return null;
    }

    const combinedAssets = { ...userObjectAssets };

    // Only add furniture-preview if assetIndex is not null
    if (furniturePreviewDict["furniture-preview"].assetIndex !== null) {
        combinedAssets["furniture-preview"] = furniturePreviewDict["furniture-preview"];
    }

    // Get the dragged object's asset data
    const draggedAsset = combinedAssets[draggedObjectId];
    
    if (!draggedAsset) {
        console.error("Dragged object not found in combinedAssets");
        return null;
    }

    const draggedAssetData = gameAssetIndex[draggedAsset.assetIndex];

    if (!draggedAssetData) {
        console.error("Asset data not found for dragged object");
        return null;
    }

    // Get object dimensions in tiles
    const draggedElement = document.getElementById(draggedObjectId);
    if (!draggedElement) {
        console.error("Dragged element not found in DOM");
        return null;
    }

    const objectWidth = Math.ceil(draggedElement.offsetWidth / unitSize);
    const objectHeight = Math.ceil(draggedElement.offsetHeight / unitSize);

    const draggedAssetPlacingRules = gameAssetIndex[combinedAssets[draggedElement.id]?.assetIndex]?.canBePlacedOn;
    const draggedAssetPlacingIndex = gameAssetIndex[combinedAssets[draggedElement.id]?.assetIndex]?.placingIndex;

    // Create placement validity map
    const placementMap = [];
    
    // Initialize map
    for (let row = 0; row < roomLayout.length; row++) {
        placementMap[row] = [];
        for (let col = 0; col < roomLayout[0].length; col++) {
            placementMap[row][col] = {
                canPlace: false,
            };
        }
    }

    for (let row = 0; row < roomLayout.length; row++) {
    for (let col = 0; col < roomLayout[0].length; col++) {
        let rightEndofSection = col + objectWidth - 1;
        let bottomOfSection = row + objectHeight - 1;

        if (rightEndofSection >= roomLayout[0].length || bottomOfSection >= roomLayout.length) {
            continue; // skip, object doesn't fit
        }

        let sectionAllowed = true;

        for (let y = row; y <= bottomOfSection; y++) {
            for (let x = col; x <= rightEndofSection; x++) {
                let tileAllowed = true;
                const tile = roomLayout[y][x];
                const tileType = tile.type ?? tile;

                // tileType: 1=floor, 2=wall, 3=boundary
                if (tileType === 1) {
                    if (!draggedAssetPlacingRules.includes(1)) {
                        tileAllowed = false;
                    }
                } 
                else if (tileType === 3) {
                    if (!draggedAssetPlacingRules.includes(3)) {
                        tileAllowed = false;
                    }
                } 
                else if (tileType === 2) {
                    if (!draggedAssetPlacingRules.includes(2)) {
                        if (draggedAssetPlacingRules.includes(4)) {
                            const bottomSupportTile = roomLayout[bottomOfSection][x];
                            if (
                                (bottomSupportTile === 1 && draggedAssetPlacingRules.includes(1)) || // bottom on floor
                                (bottomSupportTile === 3 && draggedAssetPlacingRules.includes(3)) // bottom on boundary
                            ) {
                                tileAllowed = true;
                            } else {
                                tileAllowed = false;
                            }
                        } else {
                            tileAllowed = false;
                        }
                    } else {
                        tileAllowed = true;
                    }
                }

                if (!(draggedAssetData["placingIndex"] === 5 || draggedAssetData["placingIndex"] === 9)) {
                    const objectsAtTile = getObjectsAtTile(x, y, draggedObjectId);
                    for (const existingObj of objectsAtTile) {
                        const existingAsset = combinedAssets[existingObj.id];

                        const existingAssetData = gameAssetIndex[existingAsset.assetIndex];
                        const existingPlacingIndex = existingAssetData["placingIndex"] || 0;

                        if (existingPlacingIndex === 5 || existingPlacingIndex === 9) {
                            continue
                        }

                        if (existingPlacingIndex === 8) {
                            tileAllowed = false;
                            break;
                        }

                        //Added to allow floor/boundary placed objects to overlap wall placed objects
                        if ((draggedAssetPlacingRules.includes(4)) && !draggedAssetPlacingRules.includes(2) && !(draggedAssetPlacingIndex === 8 && existingPlacingIndex === 8)) {
                            if (tileType === 2) {
                                if (draggedAssetPlacingRules.includes(3)) {
                                    if (getFirstRowOfTileType(3) - (objectHeight - 1) <= row) {
                                        tileAllowed = true;
                                        break;
                                    }
                                } else if (draggedAssetPlacingRules.includes(1)) {
                                    if (getFirstRowOfTileType(1) - (objectHeight - 1) <= row) {
                                        tileAllowed = true;
                                        break;
                                    }
                                }
                            }
                        }

                        if (!draggedAssetPlacingRules.includes(existingPlacingIndex)) {
                            tileAllowed = false;
                            break;
                        } else {
                            if (existingPlacingIndex === 11 && draggedAssetPlacingIndex === 12) {
                                const windowCoords = getObjectCoordinates(existingObj.id)
                                const windowWidth = Math.ceil(existingObj.offsetWidth / unitSize);
                                const windowHeight = Math.ceil(existingObj.offsetHeight / unitSize);
                                const tilesOccupiedByWindow = getTilesOccupiedByObject(windowCoords, windowWidth, windowHeight);

                                const maxY = Math.max(...tilesOccupiedByWindow.map(c => c[1]));
                                const windowBottomTiles = tilesOccupiedByWindow.filter(c => c[1] === maxY);

                                if (windowBottomTiles.some(c => c[0] === x && c[1] === y)) {
                                    tileAllowed = true;
                                }
                            } else if (existingPlacingIndex === 11 && draggedAssetPlacingIndex === 13) {
                                const windowCoords = getObjectCoordinates(existingObj.id)
                                const windowWidth = Math.ceil(existingObj.offsetWidth / unitSize);
                                const windowHeight = Math.ceil(existingObj.offsetHeight / unitSize);
                                const tilesOccupiedByWindow = getTilesOccupiedByObject(windowCoords, windowWidth, windowHeight);
                                const maxY = Math.max(...tilesOccupiedByWindow.map(c => c[1]));
                                const windowTilesOtherThanBottom = tilesOccupiedByWindow.filter(c => c[1] !== maxY);
                                
                                // Check if current tile is actually occupied by this window AND is not bottom row
                                if (windowTilesOtherThanBottom.some(c => c[0] === x && c[1] === y)) {
                                    tileAllowed = true;
                                } else {
                                    tileAllowed = false;
                                    break;
                                }
                            } else if (existingPlacingIndex === 14) {
                               const objCoords = getObjectCoordinates(existingObj.id);
                                const objWidth = Math.ceil(existingObj.offsetWidth / unitSize);
                                const objHeight = Math.ceil(existingObj.offsetHeight / unitSize);
                                const tilesOccupiedByObj = getTilesOccupiedByObject(objCoords, objWidth, objHeight);

                                const minY = Math.min(...tilesOccupiedByObj.map(c => c[1]));
                                const objTopTiles = tilesOccupiedByObj.filter(c => c[1] === minY);

                                if (objTopTiles.some(c => c[0] === x && c[1] === y)) {
                                    tileAllowed = true;
                                } else {
                                    tileAllowed = false;
                                    break;
                                }
                            } else {
                                tileAllowed = true;
                            }
                        }
                    }

                    if (!tileAllowed) {
                        if (tileType === 2 && !draggedAssetPlacingRules.includes(2) && draggedAssetPlacingRules.includes(7)) {
                            // Check the tile below the object (bottomOfSection)
                            const bottomTileType = roomLayout[bottomOfSection][x];
                            const bottomObjects = getObjectsAtTile(x, bottomOfSection, draggedObjectId);

                            let bottomTileValid = false;

                            // First, check if the tile type itself supports placement
                            if (
                                (bottomTileType === 1 && draggedAssetPlacingRules.includes(1)) ||
                                (bottomTileType === 3 && draggedAssetPlacingRules.includes(3))
                            ) {
                                bottomTileValid = true;
                            } else {
                                // Then check if any objects on that tile allow placement
                                for (const obj of bottomObjects) {
                                    const objData = gameAssetIndex[combinedAssets[obj.id].assetIndex];
                                    const objPlacingIndex = objData.placingIndex || 0;
                                    
                                    if (draggedAssetPlacingRules.includes(objPlacingIndex)) {
                                        bottomTileValid = true;
                                    }

                                    if (objPlacingIndex === 14) {
                                        const objCoords = getObjectCoordinates(obj.id);
                                        const objWidth = Math.ceil(obj.offsetWidth / unitSize);
                                        const objHeight = Math.ceil(obj.offsetHeight / unitSize);
                                        const tilesOccupiedByObj = getTilesOccupiedByObject(objCoords, objWidth, objHeight);

                                        const minY = Math.min(...tilesOccupiedByObj.map(c => c[1]));
                                        const objTopTiles = tilesOccupiedByObj.filter(c => c[1] === minY);

                                        // Check if the BOTTOM tile (x, bottomOfSection) is on top of this object
                                        if (objTopTiles.some(c => c[0] === x && c[1] === bottomOfSection)) {
                                            bottomTileValid = true;
                                            break;
                                        } else {
                                            bottomTileValid = false;
                                            break;
                                        }
                                    }
                                }
                            }

                            if (bottomTileValid) tileAllowed = true;

                            const objectsAtTile = getObjectsAtTile(x, y, draggedObjectId);

                            for (const existingObj of objectsAtTile) {
                                const existingAsset = combinedAssets[existingObj.id];
                                const existingAssetData = gameAssetIndex[existingAsset.assetIndex];
                                const existingPlacingIndex = existingAssetData["placingIndex"] || 0;

                                //if (existingPlacingIndex === 5 || existingPlacingIndex === 9) {
                                    //tileAllowed = false;
                                    //break;
                                if (
                                    (draggedAssetPlacingRules.includes(1) || draggedAssetPlacingRules.includes(3))
                                    && !draggedAssetPlacingRules.includes(2)
                                    && (draggedAssetPlacingIndex === 8 && existingPlacingIndex === 8)
                                ) {
                                    tileAllowed = false;
                                    break;
                                }
                            }
                        }
                        }
                    } else {
                        const objectsAtTile = getObjectsAtTile(x, y, draggedObjectId);

                        for (const existingObj of objectsAtTile) {
                            const existingAsset = combinedAssets[existingObj.id];
                            const existingAssetData = gameAssetIndex[existingAsset.assetIndex];
                            const existingPlacingIndex = existingAssetData["placingIndex"] || 0;

                            if (existingPlacingIndex === 5 || existingPlacingIndex === 9) {
                                tileAllowed = false;
                                break;
                            }
                        }
                    }
                if (!tileAllowed) {
                    sectionAllowed = false;
                    break; // stop this row
                }
            }
            if (!sectionAllowed) break; // stop this section
        }

        if (sectionAllowed) {
            
            for (let y = row; y <= bottomOfSection; y++) {
                for (let x = col; x <= rightEndofSection; x++) {
                    placementMap[y][x] = { canPlace: true };
                }
            }
        }
    }

}

return placementMap;
}

// Helper function to get all objects at a specific tile
function getObjectsAtTile(tileCol, tileRow, excludeObjectId = null) {
    const objectsAtTile = [];
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));

    const combinedAssets = { ...userObjectAssets };

    // Only add furniture-preview if assetIndex is not null
    if (furniturePreviewDict["furniture-preview"].assetIndex !== null) {
        combinedAssets["furniture-preview"] = furniturePreviewDict["furniture-preview"];
    }

    Object.entries(combinedAssets).forEach(([objectId, asset]) => {
        if (objectId === excludeObjectId) return;

        const element = document.getElementById(objectId);
        if (!element) return;

        const objectPos = getObjectCoordinates(objectId);
        if (!objectPos) return;

        const [objX, objY] = objectPos;
        const objWidth = Math.ceil(element.offsetWidth / unitSize);
        const objHeight = Math.ceil(element.offsetHeight / unitSize);

        // Check if the tile is within this object's bounds
        const objTopRow = objY - objHeight + 1;
        const objBottomRow = objY;
        const objLeftCol = objX;
        const objRightCol = objX + objWidth - 1;

        if (tileCol >= objLeftCol && tileCol <= objRightCol &&
            tileRow >= objTopRow && tileRow <= objBottomRow) {

            objectsAtTile.push(element);
        }
    });

    return objectsAtTile;
}

function clearPlacementHighlights() {
    document.querySelectorAll('.placement-highlight').forEach(highlight => {
        highlight.remove();
    });
}

function determineAndHighlightValidTiles(draggedObjectId) {
    const placementMap = generatePlacementMap(draggedObjectId);
    highlightValidPlacements(placementMap)
    return placementMap
}

// Function to highlight valid placement tiles
function highlightValidPlacements(placementMap) {
    // Remove existing highlights
    clearPlacementHighlights();

    if (!placementMap) return;

    // Create highlight overlays for valid positions
    for (let row = 0; row < roomLayout.length; row++) {
        for (let col = 0; col < roomLayout[0].length; col++) {
            if (placementMap[row] && placementMap[row][col] && placementMap[row][col].canPlace) {
                createPlacementHighlight(col, row, true);
            } else if (placementMap[row] && placementMap[row][col]) {
                createPlacementHighlight(col, row, false);
            }
        }
    }
}

// Function to create individual highlight overlay
function createPlacementHighlight(col, row, isValid) {
    const highlight = document.createElement('div');
    highlight.className = `placement-highlight ${isValid ? 'valid' : 'invalid'}`;
    highlight.style.cssText = `
        position: absolute;
        left: calc(${col} * var(--unit-size));
        top: calc(${row} * var(--unit-size));
        width: var(--unit-size);
        height: var(--unit-size);
        background-color: ${isValid ? 'rgba(0, 255, 0, 0.15)' : 'rgba(255, 0, 0, 0.15)'};
        pointer-events: none;
        z-index: 1000;
    `;
    
    document.getElementById('room-container').appendChild(highlight);
}

// NAVIGATION START

const navButtons = document.querySelectorAll('.nav-item');
const contentPanels = document.querySelectorAll('.game-content-panel');

navButtons.forEach((button) => {
    button.addEventListener('click', () => {
        const targetId = button.dataset.target;
        
        // Remove active class from all buttons and panels
        navButtons.forEach(btn => btn.classList.remove('active'));
        contentPanels.forEach(panel => panel.classList.remove('active'));
        
        // Add active class to clicked button and target panel
        button.classList.add('active');
        const targetPanel = document.getElementById(targetId);
        targetPanel.classList.add('active');

        endPreview()

        if (button.id !== "pet-room-button") {
            selectedConsumable = [];
            clearPlacementHighlights();
        }

        document.getElementById('cancel-edit-btn').click();

        // Trigger rendering depending on the panel
        if (targetId === 'furniture-container') {
            renderObjectAssetsDropdown();
            const checkbox = document.getElementById("object-usage-toggle");
            const switchText = document.querySelector(".switch-text-object");
            if (checkbox && switchText) {
                switchText.textContent = checkbox.checked ? "" : "NENAUD.";
            }
        } else if (targetId === 'shop-container') {
            renderShopCategoriesDropdown();
            const checkbox = document.getElementById("shop-not-owned-toggle");
            const switchText = document.querySelector(".switch-text-shop");
            if (checkbox && switchText) {
                switchText.textContent = checkbox.checked ? "" : "NETURIU";
            }
        } else if (targetId === 'pet-room-container') {
            const allPets = document.querySelectorAll("#petContainer .pet");
            if (allPets[0]) {
                displayPetStats(allPets[0].id);
            }
            allPets.forEach(pet => {
                managePetActions(pet);
            });
            toggleRoomDarknessBasedOnElectricityTax();
        } else if (targetId === 'pet-asset-container') {
            const departmentBtns = document.querySelectorAll('#pet-asset-container .department-btn');
            const foodBtn = Array.from(departmentBtns).find(btn => {
                const label = btn.querySelector('.department-label');
                return label && label.textContent.trim() === 'Maistas';
            });

            // Trigger the click if it exists
            if (foodBtn) {
                foodBtn.click(); // This fires any click listeners attached
            }

            renderUsersPetAssets();
        } else if (targetId === 'taxes-container') {
            renderTaxesSection();
        }
    });
});

function navigationResponsiveLayout() {
    const gameContainer = document.getElementById("gameContainer");
    const gameNavigation = document.querySelector(".game-navigation");
    const gameContent = document.getElementById("game-content");
    const gameContentPanel = document.querySelectorAll('.game-content-panel')

    if (!gameContainer || !gameNavigation || !gameContent) {
        console.warn("One or more elements not found.");
        return;
    }

    if (window.matchMedia("(max-width: 767px)").matches) {
        gameContainer.classList.add("mobile");
        gameNavigation.classList.add("mobile");
        gameContent.classList.add("mobile");
        gameContentPanel.forEach(panel => panel.classList.add("mobile"));
    } else {
        gameContainer.classList.remove("mobile");
        gameNavigation.classList.remove("mobile");
        gameContent.classList.remove("mobile");
        gameContentPanel.forEach(panel => panel.classList.remove("mobile"));
    }
}

// Recalculate on resize
window.addEventListener("resize", () => {
    updateStatsBeforeRerunningInitGameAndRenderPets();
    navigationResponsiveLayout();
    endPreview()

    if (document.getElementById("pet-room-container").classList.contains("active")) {
        initGame();
        document.querySelector("#end-preview-button").classList.add("hidden")
        resetEditButtonToggle();
    }

    const checkbox = document.getElementById("shop-not-owned-toggle");
    const switchText = document.querySelector(".switch-text-shop");
    if (checkbox && switchText) {
        switchText.textContent = checkbox.checked ? "" : "NETURIU";
    }

    const checkbox2 = document.getElementById("object-usage-toggle");
    const switchText2 = document.querySelector(".switch-text-object");
    if (checkbox2 && switchText2) {
        switchText2.textContent = checkbox2.checked ? "" : "NENAUD.";
    }
});

// NAVIGATION END


function adjustUnitSizeForSmallScreens(roomLayout) {
    if (!roomLayout || !roomLayout[0]) return;

    const numTiles = roomLayout[0].length; // number of columns
    const screenWidth = window.innerWidth;

    // Define breakpoint for "small screens"
    if (screenWidth <= 768) {
        originalUnitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--original-unit-size'));
        unitSize = Math.min(Math.floor(screenWidth / numTiles), originalUnitSize);

        // Set CSS variable
        document.documentElement.style.setProperty("--unit-size", `${unitSize}px`);
        document.documentElement.style.setProperty("--pet-size", `calc(${unitSize}px * 3)`);
    } else {
        unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--original-unit-size'));

        // Reset to default if needed
        document.documentElement.style.setProperty("--unit-size", `${unitSize}px`);
        document.documentElement.style.setProperty("--pet-size", `${unitSize*3}px`);
    }
}


// CREATE SHOPPING FUNCTIONALITY START

// Store the current shop state
let shopState = {
    department: 'pet-supplies',
    category: 'all',
    pet: null,
    tab: 'supplies',
    showUnpurchasedOnly: false
};

async function handlePurchase(item, assetIndex, quantity, selectedCategory, btn) {
    console.log(item, assetIndex, quantity, selectedCategory, btn)
    updateShopState();
    
    const itemDetails = gameAssetIndex[assetIndex];
    
    if (!itemDetails) {
        console.error(`Asset with index ${assetIndex} not found in gameAssetIndex`);
        return;
    }
    
    // Calculate total cost
    const totalCost = itemDetails.cost * quantity;
    
    // Check if user has enough money
    if (userMoney < totalCost) {
        messageToTheUser("Nepakanka ping!", 'error');
        return;
    }
    
    // Store original states for potential rollback
    const originalMoney = userMoney;
    const originalObjectAssets = JSON.parse(JSON.stringify(userObjectAssets));
    const originalPetAssets = JSON.parse(JSON.stringify(userPetAssets));
    
    // Deduct money from user (optimistic update)
    userMoney -= totalCost;
    
    // Save current state before making changes (for shop restoration)
    const currentState = {...shopState};
    
    let assetUpdateNeeded = false;
    
    if (item.petAsset) {
        const cssClasses = itemDetails['css-class'].split(' ');
        const isSkin = cssClasses.includes('skin');
        
        if (isSkin) {
            // Handle skin assets
            const petType = cssClasses[0]; // First class is the pet type (e.g., 'cat-1', 'dog-1')
            
            // Initialize pets structure if it doesn't exist
            if (!userPetAssets.pets) {
                userPetAssets.pets = {};
            }
            
            // Initialize pet type if it doesn't exist
            if (!userPetAssets.pets[petType]) {
                userPetAssets.pets[petType] = { 
                    skins: {},
                    name: item.petName
                };
            }
            
            // Initialize skins object if it doesn't exist
            if (!userPetAssets.pets[petType].skins) {
                userPetAssets.pets[petType].skins = {};
            }
            
            // Generate new skin key
            const existingSkins = Object.keys(userPetAssets.pets[petType].skins);
            const skinNumber = existingSkins.length + 1;
            const newSkinKey = `${petType}-${skinNumber}`;
            
            // Add the skin (skins are always unique, so no quantity stacking)
            userPetAssets.pets[petType].skins[newSkinKey] = {
                assetIndex: assetIndex,
                equiped: false // New skins start as not equipped
            };
            
        } else {
            // Handle supply assets
            // Initialize supplies structure if it doesn't exist
            if (!userPetAssets.supplies) {
                userPetAssets.supplies = {};
            }
            
            // Check if item is stackable and already exists
            if (itemDetails.stackable) {
                let existingSupplyKey = null;
                for (const key in userPetAssets.supplies) {
                    if (userPetAssets.supplies[key].assetIndex === assetIndex) {
                        existingSupplyKey = key;
                        break;
                    }
                }
                
                if (existingSupplyKey) {
                    // Stack with existing supply
                    userPetAssets.supplies[existingSupplyKey].quantity += quantity;
                } else {
                    // Create new supply entry
                    const newSupplyKey = `S${Object.keys(userPetAssets.supplies).length + 1}`;
                    userPetAssets.supplies[newSupplyKey] = {
                        assetIndex: assetIndex,
                        quantity: quantity
                    };
                }
            } else {
                // Non-stackable items get separate entries
                for (let i = 0; i < quantity; i++) {
                    const newSupplyKey = `S${Object.keys(userPetAssets.supplies).length + 1}`;
                    userPetAssets.supplies[newSupplyKey] = {
                        assetIndex: assetIndex,
                        quantity: 1
                    };
                }
            }
        }
        assetUpdateNeeded = true;
        
    } else {
        // Object assets (unchanged from your original code)
        if (item.oneOfKind) {
            const newKey = `O${Object.keys(userObjectAssets).length + 1}`;
            userObjectAssets[newKey] = { assetIndex, position: [] };
        } else {
            for (let i = 0; i < quantity; i++) {
                const newKey = `O${Object.keys(userObjectAssets).length + 1}`;
                userObjectAssets[newKey] = { assetIndex, position: [] };
            }
        }
        assetUpdateNeeded = true;
    }
    
    try {
        // First, update money on server
        const moneyUpdateSuccess = await sendMoneyUpdateToDatabase();
        
        if (!moneyUpdateSuccess) {
            // Revert all changes
            userMoney = originalMoney;
            userObjectAssets = originalObjectAssets;
            userPetAssets = originalPetAssets;
            messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
            console.log('Purchase failed - money update failed');
            return;
        }
        
        // If assets were added, update them on server
        if (assetUpdateNeeded) {
            let assetUpdateSuccess = false;
            
            if (item.petAsset) {
                assetUpdateSuccess = await sendPetAssetsUpdateToDatabase();
                const isPet = itemDetails["pet"] === true;
                if (isPet) {
                    updateStatsBeforeRerunningInitGameAndRenderPets();
                    renderPets();
                    enablePetDragging();
                    createPetButtons();
                }
            } else {
                assetUpdateSuccess = await sendObjectAssetsUpdateToDatabase();
            }
            
            if (!assetUpdateSuccess) {
                // Asset update failed, but money was already deducted on server
                console.error('Critical error: Money deducted but asset update failed');
                
                // Attempt to revert money on server
                userMoney = originalMoney;
                await sendMoneyUpdateToDatabase();
                
                // Revert local asset state
                userObjectAssets = originalObjectAssets;
                userPetAssets = originalPetAssets;
                
                messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
                return;
            }
        }
        
        // Success! Add your original animation logic
        btn.innerHTML = '<svg class="tick-svg" viewBox="0 0 24 24" width="24" height="24"><path class="tick" d="M4 12l6 6 10-10"></path></svg>';
        const tick = btn.querySelector('.tick');
        requestAnimationFrame(() => {
            tick.classList.add('draw');
        });
        
        document.querySelectorAll('.purchase-btn').forEach(b => {
            b.disabled = true;
        });
        
        // Remove it after animation finishes (e.g. 300ms)
        setTimeout(() => {
            // Restore the shop state after purchase
            restoreShopState(currentState);
        }, 500);
        
    } catch (error) {
        // Network error or other unexpected error
        console.error('Purchase error:', error);
        
        // Revert all local changes
        userMoney = originalMoney;
        userObjectAssets = originalObjectAssets;
        userPetAssets = originalPetAssets;
        
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
    }
}

function restoreShopState(state) {
    // Update global state
    shopState = {...state};
    
    // Set the department
    const departmentButtons = document.querySelectorAll('#shop-container .department-btn');
    departmentButtons.forEach(btn => {
        const label = btn.querySelector('.department-label').textContent;
        let department;
        if (label === 'Baldai') department = 'furniture';
        if (label === 'Gyvnliai') department = 'pets';
        if (label === 'Maistas' || label === 'Reikmenys') department = 'pet-supplies';
        
        btn.classList.toggle('active', department === state.department);
    });
    
    // Set the pet selection
    selectedPet = state.pet;
    
    // Update active pet buttons in shop section only
    document.querySelectorAll('#pet-list-shop .pet-btn').forEach(btn => {
        const petPreview = btn.querySelector('.pet-preview');
        const petClass = petPreview.classList[1]; // Get the pet type class
        btn.classList.toggle('active', petClass === state.pet);
    });
    
    // Set the tab selection (for Maistas)
    activePetSupplyTab = state.tab;
    
    // Set the category dropdown
    const dropdown = document.getElementById('shop-category-select');
    if (dropdown) {
        dropdown.value = state.category;
    }
    
    // Set the unpurchased toggle
    const toggle = document.getElementById('shop-not-owned-toggle');
    if (toggle) {
        toggle.checked = state.showUnpurchasedOnly;
    }
    
    // Set the pet supply tabs
    const petSupplyTabButtons = document.querySelectorAll('.pet-supply-tab');
    petSupplyTabButtons.forEach(tab => {
        tab.classList.toggle('active', tab.dataset.type === state.tab);
    });
    
    // Re-render with the saved state
    renderShopItems(state.category, state.department, state.tab);
}

function syncPetSelection() {
    // Synchronize pet selection between shop and pet sections
    if (!selectedPet) return;
    
    // Update shop section pet buttons
    document.querySelectorAll('#pet-list-shop .pet-btn').forEach(btn => {
        const petPreview = btn.querySelector('.pet-preview');
        if (petPreview) {
            const petClass = petPreview.classList[1]; // Get the pet type class
            btn.classList.toggle('active', petClass === selectedPet);
        }
    });
    
    // Update pet section pet buttons
    document.querySelectorAll('#pet-list-owned .pet-btn').forEach((btn, index) => {
        const petType = Object.keys(userPetAssets.pets)[index];
        btn.classList.toggle('active', petType === selectedPet);
    });
}

function updateShopState() {
    // Get current department - handle case where no active button exists
    const activeBtn = document.querySelector('.department-btn.active');
    let department = 'furniture'; // default fallback
    
    if (activeBtn) {
        const label = activeBtn.querySelector('.department-label')?.textContent;
        if (label === 'Baldai') department = 'furniture';
        if (label === 'Gyvnliai') department = 'pets';
        if (label === 'Maistas' || label === 'Reikmenys') department = 'pet-supplies';
    }
    
    // Get current category
    const dropdown = document.getElementById('shop-category-select');
    const category = dropdown ? dropdown.value : 'all';
    
    // Get current unpurchased toggle state
    const toggle = document.getElementById('shop-not-owned-toggle');
    const showUnpurchasedOnly = toggle ? toggle.checked : false;
    
    // Update the shop state
    shopState = {
        department,
        category,
        pet: selectedPet,  // Make sure this uses the global selectedPet variable
        tab: activePetSupplyTab,
        showUnpurchasedOnly
    };
}

let selectedPet = null;
let activePetSupplyTab = 'supplies';

function renderShopCategoriesDropdown() {
    const dropdown = document.getElementById('shop-category-select');
    const shopContainer = document.getElementById('shop-items');
    const departmentButtons = document.querySelectorAll('#shop-container .department-btn');
    const petListContainer = document.getElementById('pet-list-shop');
    const petSuppliesTabs = document.getElementById('pet-supplies-tabs');

    const toggle = document.getElementById('shop-not-owned-toggle');
    toggle.checked = false;

    if (!dropdown || !shopContainer || !departmentButtons) return;

    let activeDepartment = getActiveDepartment();

    // Function to check if item is a skin by looking for 'skin' in css-class
    function isSkin(item) {
        const cssClass = item['css-class'] || '';
        return cssClass.includes('skin');
    }

    function getCategoryCounts(department, tabType = 'supplies') {
        const categoryCounts = {};
        for (const key in gameAssetIndex) {
            const item = gameAssetIndex[key];

            if (!item.purchasable) continue;

            // Filter by department and tab type
            if (department === 'pet-supplies') {
                if (!item.petAsset) continue;
                
                // Use CSS class to determine skin vs supply
                if (tabType === 'skins' && !isSkin(item)) continue;
                if (tabType === 'supplies' && isSkin(item)) continue;
                
                // For Maistas, filter by selected pet if any
                if (selectedPet) {
                    const petIdentifier = selectedPet.split('-')[0];
                    const cssClass = item['css-class'] || '';
                    if (!cssClass.includes(petIdentifier)) continue;
                }
            } else if (department === 'pets') {
                // For pets section, use the pet property (not CSS class)
                if (!item.petAsset || !item.pet) continue;
            } else if (department === 'furniture' && item.petAsset) {
                continue;
            }

            item.category.forEach(cat => {
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });
        }
        return categoryCounts;
    }

    function updateDropdown(department, tabType = 'supplies') {
        const categoryCounts = getCategoryCounts(department, tabType);

        dropdown.innerHTML = '';

        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = `Visi`;
        dropdown.appendChild(allOption);

        for (const cat in categoryCounts) {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
            dropdown.appendChild(option);
        }
        
        // Restore the saved category selection if it exists
        if (shopState.category && Array.from(dropdown.options).some(opt => opt.value === shopState.category)) {
            dropdown.value = shopState.category;
        }
    }

    function getActiveDepartment() {
        const activeBtn = document.querySelector('.department-btn.active');
        const label = activeBtn?.querySelector('.department-label')?.textContent;
        if (label === 'Gyvnliai') return 'pets';
        if (label === 'Maistas' || label === 'Reikmenys') return 'pet-supplies';
        return 'furniture';
    }

    function renderPetList() {
        // Always hide both containers first
        petListContainer.style.display = 'none';
        petSuppliesTabs.style.display = 'none';
        
        // Only show if we're in pet-supplies department
        if (activeDepartment === 'pet-supplies') {
            petListContainer.style.display = 'flex';
            petSuppliesTabs.style.display = 'flex';
            
            petListContainer.innerHTML = '';

            for (const petType in userPetAssets.pets) {
                const pet = userPetAssets.pets[petType];
                
                let equippedSkinAssetIndex = null;
                for (const skinKey in pet.skins) {
                    if (pet.skins[skinKey].equiped) {
                        equippedSkinAssetIndex = pet.skins[skinKey].assetIndex;
                        break;
                    }
                }

                if (!equippedSkinAssetIndex && Object.keys(pet.skins).length > 0) {
                    const firstSkinKey = Object.keys(pet.skins)[0];
                    equippedSkinAssetIndex = pet.skins[firstSkinKey].assetIndex;
                }

                const petItem = gameAssetIndex[equippedSkinAssetIndex];
                if (!petItem) continue;

                const petBtn = document.createElement('button');
                petBtn.className = `pet-btn ${selectedPet === petType ? 'active' : ''}`;
                
                const previewDiv = document.createElement('div');
                previewDiv.className = `pet-preview ${petItem["css-class"].split(" ").slice(0, 2).join(" ")}`;

                petBtn.appendChild(previewDiv);

                petBtn.addEventListener('click', () => {
                    selectedPet = petType;
                    document.querySelectorAll('.pet-btn').forEach(btn => btn.classList.remove('active'));
                    petBtn.classList.add('active');
                    updateShopState();
                    renderShopItems('all', activeDepartment, activePetSupplyTab);
                });

                petListContainer.appendChild(petBtn);
            }

            if (!selectedPet && Object.keys(userPetAssets.pets).length > 0) {
                selectedPet = Object.keys(userPetAssets.pets)[0];
                petListContainer.querySelector('.pet-btn')?.classList.add('active');
            }
        }
    }

    // Set up Maistas tabs
    const petSupplyTabButtons = document.querySelectorAll('.pet-supply-tab');
    petSupplyTabButtons.forEach(tab => {
        tab.addEventListener('click', () => {
            petSupplyTabButtons.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            activePetSupplyTab = tab.dataset.type;
            updateShopState();
            updateDropdown(activeDepartment, activePetSupplyTab);
            renderShopItems('all', activeDepartment, activePetSupplyTab);
        });
    });

    // Initialize with saved state if available
    if (shopState.department) {
        // Set active department based on saved state
        departmentButtons.forEach(btn => {
            const label = btn.querySelector('.department-label').textContent;
            let department;
            if (label === 'Baldai') department = 'furniture';
            if (label === 'Gyvnliai') department = 'pets';
            if (label === 'Maistas' || label === 'Reikmenys') department = 'pet-supplies';
            
            btn.classList.toggle('active', department === shopState.department);
        });
        
        activeDepartment = shopState.department;
        selectedPet = shopState.pet;
        activePetSupplyTab = shopState.tab;
    }

    updateDropdown(activeDepartment, activePetSupplyTab);
    renderPetList();
    renderShopItems(shopState.category || 'all', activeDepartment, activePetSupplyTab);

    dropdown.addEventListener('change', () => {
        updateShopState();
        const selectedCategory = dropdown.value;
        renderShopItems(selectedCategory, activeDepartment, activePetSupplyTab);
    });

    departmentButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            departmentButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            activeDepartment = getActiveDepartment();
            selectedPet = null; // Reset pet selection
            updateShopState();
            updateDropdown(activeDepartment, activePetSupplyTab);
            renderPetList(); // This will now properly hide/show the tabs based on department
            renderShopItems('all', activeDepartment, activePetSupplyTab);
        });
    });
}

function renderTemporaryRoomObject(assetId) {
    const roomObjectsContainer = document.querySelector("#roomObjectsContainer");
    const item = gameAssetIndex[assetId];

    const div = document.createElement("div");
    div.className = `room-object furniture-preview ${item["css-class"]}`;
    div.id = "furniture-preview";
    roomObjectsContainer.appendChild(div);

    div.style.left = `0px`;
    div.style.top = `0px`;

    return div.id;
}

let furniturePreviewDict = {
    "furniture-preview" : {
        assetIndex: null,
        position: []
    }
}

document.querySelector("#end-preview-button").addEventListener("click", () => {
    endPreview();
    updateStatsBeforeRerunningInitGameAndRenderPets();
    initGame();
});;

function endPreview() {
    if (!furniturePreviewDict["furniture-preview"].assetIndex) {
        return
    }
    
    document.querySelector("#end-preview-button").classList.add("hidden");
    document.querySelector("#toggle-edit-save-btn").classList.remove("hidden");

    // Clean up the preview object
    furniturePreviewDict["furniture-preview"].assetIndex = null;
    furniturePreviewDict["furniture-preview"].position = [];

    // Remove the preview div if it exists
    const previewDiv = document.getElementById('furniture-preview');
    
    if (previewDiv) {
        previewDiv.remove();
    }

    // If in edit mode, exit it first
    if (editing) {
        cancelEditBtn.click();
    }
}

function previewFurniture (key) {
    
    let tempDivId = renderTemporaryRoomObject(key);

    document.querySelectorAll('.game-content-panel').forEach(p => p.classList.remove('active'));
    document.getElementById('pet-room-container').classList.add('active');

    const navButtons = document.querySelectorAll('.nav-item');
    navButtons.forEach(btn => btn.classList.remove('active'));
    navButtons[0].classList.add('active')
    
    furniturePreviewDict["furniture-preview"].assetIndex = key;
    furniturePreviewDict["furniture-preview"].position = getObjectCoordinates(tempDivId);

    updateStatsBeforeRerunningInitGameAndRenderPets();
    
    initGame();
    const placementMap = generatePlacementMap(tempDivId);

    const validPosition = findValidPosition(placementMap, tempDivId);

    if (validPosition) {
        furniturePreviewDict["furniture-preview"].position = validPosition;
        updateStatsBeforeRerunningInitGameAndRenderPets();
        adjustUnitSizeForSmallScreens(roomLayout);
        renderRoomGrid();
        setPetAndObjectContainersToGridDimentions();
        renderRoomObjects();
        toggleRoomDarknessBasedOnElectricityTax();
        predictAndSetZIndex();

        toggleEditSaveBtn.click();

        document.querySelector("#end-preview-button").classList.remove("hidden")
        document.querySelector("#toggle-edit-save-btn").classList.add("hidden")
        document.querySelector("#cancel-edit-btn").classList.add("hidden")

        
    } else {
        furniturePreviewDict["furniture-preview"].position = [];
        document.getElementById(tempDivId).remove();
        if (gameAssetIndex[furniturePreviewDict["furniture-preview"].assetIndex].placingIndex === 13 || gameAssetIndex[furniturePreviewDict["furniture-preview"].assetIndex]["css-class"].includes("window-sill")) {
            messageToTheUser("Nra tinkamo dydio lango arba j ustoja kiti daiktai!")
        } else {
            messageToTheUser("Nepakanka vietos!")
        }
        furniturePreviewDict["furniture-preview"].assetIndex = null;
        predictAndSetZIndex();
    }
}

function renderShopItems(selectedCategory = 'all', department = 'pet-supplies', tabType = 'supplies') {
    const shopContainer = document.getElementById('shop-items');
    if (!shopContainer) return;
    shopContainer.innerHTML = '';

    const ownedIndexes = new Set();
    const ownedCssClasses = new Set();

    // Collect owned items
    for (const key in userObjectAssets) {
        const assetIndex = userObjectAssets[key].assetIndex;
        if (userObjectAssets[key].position.length !== 0) {
            ownedIndexes.add(assetIndex);

        const cssClassStr = gameAssetIndex[assetIndex]?.['css-class'];
        if (cssClassStr) {
            cssClassStr.split(' ').forEach(cls => ownedCssClasses.add(cls));
        }
        }
    }

    // Collect owned pets
    if (userPetAssets.pets) {
        for (const petId in userPetAssets.pets) {
            const pet = userPetAssets.pets[petId];
            if (pet.skins) {
                for (const skinId in pet.skins) {
                    const skin = pet.skins[skinId];
                    const assetIndex = skin.assetIndex;
                    ownedIndexes.add(assetIndex);

                    const cssClassStr = gameAssetIndex[assetIndex]?.['css-class'];
                    if (cssClassStr) {
                        cssClassStr.split(' ').forEach(cls => ownedCssClasses.add(cls));
                    }
                }
            }
        }
    }

    // Collect owned supplies
    if (userPetAssets.supplies) {
        for (const supplyId in userPetAssets.supplies) {
            const supply = userPetAssets.supplies[supplyId];
            const assetIndex = supply.assetIndex;
            ownedIndexes.add(assetIndex);

            const cssClassStr = gameAssetIndex[assetIndex]?.['css-class'];
            if (cssClassStr) {
                cssClassStr.split(' ').forEach(cls => ownedCssClasses.add(cls));
            }
        }
    }

    const showUnpurchasedOnly = document.getElementById('shop-not-owned-toggle').checked;

    // Function to check if item is a skin by looking for 'skin' in css-class
    function isSkin(item) {
        const cssClass = item['css-class'] || '';
        return cssClass.includes('skin');
    }

    for (const key in gameAssetIndex) {
        const item = gameAssetIndex[key];
        const assetIndex = parseInt(key);

        if (!item.purchasable) continue;

        // Department and tab filter
        if (department === 'pet-supplies') {
            if (!item.petAsset) continue;
            
            // Use CSS class to determine skin vs supply
            if (tabType === 'skins' && !isSkin(item)) continue;
            if (tabType === 'supplies' && isSkin(item)) continue;
            
            // For Maistas, filter by selected pet if any
            if (selectedPet) {
                const cssClass = item['css-class'] || '';
                
                if (tabType === 'skins') {
                    // For skins, match exact pet type (cat-1, cat-2, etc.)
                    if (!cssClass.includes(selectedPet)) continue;
                } else {
                    // For supplies/food, match species only (cat, dog, etc.)
                    const petIdentifier = selectedPet.split('-')[0];
                    if (!cssClass.includes(petIdentifier)) continue;
                }
            }
        } else if (department === 'pets') {
            // For pets section, use the pet property (not CSS class)
            if (!item.petAsset || !item.pet) continue;
        } else if (department === 'furniture' && item.petAsset) {
            continue;
        }

        // Category filter
        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;

        // Unpurchased only filter
        if (showUnpurchasedOnly && ownedIndexes.has(assetIndex) && item.oneOfKind) continue;

        const itemDiv = document.createElement('div');
        const itemClasses = item.category.join(' ');
        itemDiv.className = `shop-item ${itemClasses}`;

        let previewButton = null;
        if (item['css-class'].includes("previewable")) {
            previewButton = document.createElement('button');
            previewButton.className = 'furniture-preview-button';
            previewButton.innerHTML = `
                <svg viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg">
                <g id="#000000ff">
                    <path fill="currentColor" opacity="1.00" d=" M 36.64 15.81 C 50.35 12.75 64.60 18.19 74.99 27.10 C 80.59 32.24 86.00 37.71 90.00 44.21 L 90.00 45.73 C 88.02 49.39 85.71 52.88 82.91 55.98 C 78.00 61.42 72.60 66.65 65.92 69.86 C 60.03 72.66 53.67 74.84 47.09 74.94 C 33.60 75.71 20.23 69.69 10.94 60.06 C 6.55 55.91 2.82 51.08 0.00 45.74 L 0.00 44.21 C 3.86 37.89 9.09 32.58 14.49 27.57 C 20.71 21.84 28.52 18.03 36.64 15.81 M 42.33 24.28 C 35.57 24.96 29.44 29.28 26.35 35.30 C 23.27 41.54 23.38 49.22 26.69 55.35 C 29.39 59.98 33.82 63.75 39.08 65.06 C 46.25 67.12 54.61 65.29 59.84 59.85 C 67.89 52.16 67.88 37.84 59.85 30.15 C 55.40 25.51 48.63 23.50 42.33 24.28 Z" />
                    <path fill="currentColor" opacity="1.00" d=" M 43.34 36.28 C 47.08 35.56 51.53 37.40 52.99 41.08 C 54.64 44.43 53.88 48.67 51.37 51.37 C 48.85 53.67 45.00 54.58 41.80 53.27 C 36.93 51.78 34.78 45.49 37.00 41.08 C 38.00 38.42 40.65 36.81 43.34 36.28 Z" />
                </g>
                </svg>
                `;
            previewButton.onclick = () => previewFurniture(key);
        }

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${item['css-class']}`;
        const previewHolder = document.createElement('div');
        previewHolder.className = 'item-preview-holder';
        previewHolder.appendChild(previewDiv);

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';

        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = item.title;

        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = item.description;
        descP.innerHTML += generateConsumableItemDescription(item)

        const priceDiv = document.createElement('div');
        priceDiv.className = 'item-price';
        const coinSpan = document.createElement('span');
        coinSpan.className = 'item-price-coin-icon';
        coinSpan.innerHTML = '<span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span>';
        const priceSpan = document.createElement('span');
        priceSpan.textContent = item.cost;
        priceDiv.appendChild(coinSpan);
        priceDiv.appendChild(priceSpan);

        const priceAndQuantDiv = document.createElement('div');
        priceAndQuantDiv.className = 'item-price-and-quantity';

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        // Check requirements
        let canPurchase = true;
        let unmetRequirements = [];

        if (item.requires && item.requires.length > 0) {
            item.requires.forEach(reqPair => {
                const [reqClass, reqLabel] = reqPair;
                if (reqClass === 'electricity') {
                    if (!taxesData.electricityTax.paid) {
                        canPurchase = false;
                        unmetRequirements.push(reqLabel);
                    }
                } else if (!ownedCssClasses.has(reqClass)) {
                    canPurchase = false;
                    unmetRequirements.push(reqLabel);
                }
            });
        }

        if (canPurchase) {
            const btn = document.createElement('button');
            btn.className = 'purchase-btn';
            btn.textContent = 'Pirkti';

            let quantityInput = null;
            if (!item.oneOfKind) {
                const quantityInputHolder = document.createElement('div');
                quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';

                const quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = 1;
                quantityInput.max = 999;
                quantityInput.step = 1;
                quantityInput.value = 1;
                quantityInput.className = 'purchase-quantity';
                quantityInput.id = `purchase-qty-${key}`;
                quantityInput.readOnly = true;

                const minusBtn = document.createElement('button');
                minusBtn.className = 'control-btn';
                minusBtn.textContent = '';
                minusBtn.onmousedown = () => {
                    startHold(quantityInput.id, 1, 999, false);
                    updatePrice();
                };
                minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, 999, false); updatePrice(); };
                minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                const plusBtn = document.createElement('button');
                plusBtn.className = 'control-btn';
                plusBtn.textContent = '+';
                plusBtn.onmousedown = () => {
                    startHold(quantityInput.id, 1, 999, true);
                    updatePrice();
                };
                plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, 999, true); updatePrice(); };
                plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                quantityInputHolder.appendChild(minusBtn);
                quantityInputHolder.appendChild(quantityInput);
                quantityInputHolder.appendChild(plusBtn);
                priceAndQuantDiv.appendChild(quantityInputHolder);

                const updatePrice = () => {
                    const qty = parseInt(quantityInput.value, 10) || 1;
                    priceSpan.textContent = item.cost * qty;
                };

                // Also optional: in case someone types manually (if you remove readOnly later)
                quantityInput.addEventListener('input', updatePrice);
                quantityInput.addEventListener('change', updatePrice);
            }


            if (ownedIndexes.has(assetIndex)) {
                if (item.oneOfKind) {
                    itemDiv.classList.add('owned');
                    btn.classList.add('owned');
                    btn.textContent = 'Nupirkta';
                    btn.disabled = true;

                    const ownedBadge = document.createElement('div');
                    ownedBadge.className = 'owned-badge';
                    ownedBadge.innerHTML = '<span class="owned-badge-icon"><img src="../images/icons/icon-check.svg"></span>';
                    previewHolder.appendChild(ownedBadge);
                }
            }

            priceAndQuantDiv.appendChild(priceDiv);
            infoDiv.appendChild(priceAndQuantDiv);

            btn.addEventListener('click', () => {
                const quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                handlePurchase(item, assetIndex, quantity, selectedCategory, btn);
            });

            if (previewButton && !(ownedIndexes.has(assetIndex) && item.oneOfKind)) {
                previewHolder.appendChild(previewButton);
            }
            itemDiv.appendChild(previewHolder);
            itemDiv.appendChild(infoDiv);
            itemDiv.appendChild(btn);
        } else {
            const requiresDiv = document.createElement('div');
            requiresDiv.className = 'item-requires';
            requiresDiv.textContent = 'Reikalinga: ' + unmetRequirements.join(', ');
            if (previewButton && !(ownedIndexes.has(assetIndex) && item.oneOfKind)) {
                itemDiv.appendChild(previewButton);
            }
            itemDiv.appendChild(previewHolder);
            itemDiv.appendChild(infoDiv);
            itemDiv.appendChild(requiresDiv);
        }

        shopContainer.appendChild(itemDiv);
    }

    // Show message if no items found
    if (shopContainer.children.length === 0) {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = `Nra nieko tinkamo iam augintiniui.`;
        messageDiv.className = 'no-matching-supplies-message';
        shopContainer.appendChild(messageDiv);
    }

    scalePreview();
}

// Toggle functionality for unpurchased only
const toggle = document.getElementById('shop-not-owned-toggle');
toggle.addEventListener('change', () => {
    updateShopState();
    const selectedCategory = document.getElementById('shop-category-select').value;
    const activeDepartment = document.querySelector('.department-btn.active .department-label').textContent;
    let dept;
    if (activeDepartment === 'Baldai') dept = 'furniture';
    if (activeDepartment === 'Gyvnliai') dept = 'pets';
    if (activeDepartment === 'Maistas' || activeDepartment === 'Reikmenys') dept = 'pet-supplies';
    renderShopItems(selectedCategory, dept, activePetSupplyTab);
});

function renderObjectAssetsDropdown() {
    const dropdown = document.getElementById('object-category-select');
    const usageToggle = document.getElementById('object-usage-toggle'); // checkbox
    const container = document.querySelector('.object-assets');

    if (!dropdown || !container || !usageToggle) return;

    usageToggle.checked = false;

    // Gather categories from currently owned object assets
    const categoryCounts = {};
    let totalAssets = 0;

    for (const key in userObjectAssets) {
        const asset = userObjectAssets[key];
        if (!asset || asset.assetIndex == null) continue;

        const item = gameAssetIndex[asset.assetIndex];
        if (!item || !item.category) continue;

        totalAssets++;
        item.category.forEach(cat => {
            categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
        });
    }

    // Clear existing options
    dropdown.innerHTML = '';

    // Add "All" option
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = `Visi`;
    allOption.selected = true;
    dropdown.appendChild(allOption);

    // Add categories (sorted alphabetically for consistency)
    Object.keys(categoryCounts).sort().forEach(cat => {
        const option = document.createElement('option');
        option.value = cat;
        option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
        dropdown.appendChild(option);
    });

    // Initial render
    renderObjectAssets('all', false);

    // Filter on dropdown change
    dropdown.addEventListener('change', () => {
        renderObjectAssets(dropdown.value, usageToggle.checked);
    });

    // Filter on toggle change
    usageToggle.addEventListener('change', () => {
        renderObjectAssets(dropdown.value, usageToggle.checked);
    });
}


function renderObjectAssets(selectedCategory = 'all', unusedOnly = false) {
    const container = document.querySelector('.object-assets');
    if (!container) return;

    container.innerHTML = '';

    for (const key in userObjectAssets) {
        const asset = userObjectAssets[key];
        const assetIndex = asset.assetIndex;
        const item = gameAssetIndex[assetIndex];
        if (!item) continue;

        // Category filter
        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;
        // Usage filter
        if (unusedOnly && asset.position && asset.position.length > 0) continue;

        const itemDiv = document.createElement('div');
        itemDiv.className = `shop-item ${item.category.join(' ')}`;

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${item['css-class']}`;

        const previewHolder = document.createElement('div');
        previewHolder.className = `item-preview-holder`;

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';

        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = item.title;

        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = item.description;
        descP.innerHTML += generateConsumableItemDescription(item)

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        const btn = document.createElement('button');
        btn.className = 'use-btn';

        if (asset.position && asset.position.length > 0) {
            btn.textContent = 'Naudojama';
            btn.disabled = true;
            btn.className = 'use-btn used';
        } else {
            btn.textContent = 'Naudoti';
            btn.disabled = false;

            btn.addEventListener('click', () => {
                let tempDivId = renderSingleRoomObject(key);

                document.querySelectorAll('.game-content-panel').forEach(p => p.classList.remove('active'));
                document.getElementById('pet-room-container').classList.add('active');

                const navButtons = document.querySelectorAll('.nav-item');
                navButtons.forEach(btn => btn.classList.remove('active'));
                navButtons[0].classList.add('active')
                
                userObjectAssets[tempDivId].position = getObjectCoordinates(tempDivId);

                updateStatsBeforeRerunningInitGameAndRenderPets();
                initGame();

                // Attempt to place the item at a valid position
                const placementMap = generatePlacementMap(tempDivId);
                const validPosition = findValidPosition(placementMap, tempDivId);

                if (validPosition) {
                    userObjectAssets[tempDivId].position = validPosition;
                    sendObjectAssetsUpdateToDatabase();
                    updateStatsBeforeRerunningInitGameAndRenderPets();
                    initGame();
                } else {
                    userObjectAssets[tempDivId].position = [];
                    document.getElementById(tempDivId).remove();
                    if (gameAssetIndex[userObjectAssets[tempDivId].assetIndex].placingIndex === 13 || gameAssetIndex[userObjectAssets[tempDivId].assetIndex]["css-class"].includes("window-sill")) {
                        messageToTheUser("Nra tinkamo dydio lango arba j ustoja kiti daiktai!")
                    } else {
                        messageToTheUser("Nepakanka vietos!")
                    }
                    predictAndSetZIndex();
                }
            });
        }

        if (asset.position && asset.position.length === 0) {
        const itemDeleteBtnHolder = document.createElement('div');
        itemDeleteBtnHolder.className = 'item-delete-btn-holder';
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'item-delete-btn';
        deleteBtn.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 6 L6 18 M6 6 L18 18" stroke="#F5F5F7" stroke-width="2"/></svg>';

        // Trigger custom confirmation
        deleteBtn.addEventListener('click', () => {
            showCustomConfirm(`Ar tikrai nori imest  daikt? Jo susigrinti negalsi.`, removeObjectFromUserAssets, key)
        });
        // Append delete button next to other buttons
        itemDeleteBtnHolder.appendChild(deleteBtn)
        previewDiv.appendChild(itemDeleteBtnHolder);
    }

        previewHolder.appendChild(previewDiv)
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(btn);

        container.appendChild(itemDiv);
    }

    scalePreview();
}

function removeObjectFromUserAssets(assetKey) {
    delete userObjectAssets[assetKey];
    sendObjectAssetsUpdateToDatabase();
    renderObjectAssets('all', false);
}

// Render a single object in the room
function renderSingleRoomObject(assetId) {
    const roomObjectsContainer = document.querySelector("#roomObjectsContainer");
    const asset = userObjectAssets[assetId];
    const item = gameAssetIndex[asset.assetIndex];

    const div = document.createElement("div");
    div.className = `room-object ${item["css-class"]}`;
    div.id = assetId;
    roomObjectsContainer.appendChild(div);

    div.style.left = `0px`;
    div.style.top = `0px`;

    return assetId;
}

function findValidPosition(placementMap, assetId) {
    let tempDiv = document.getElementById(assetId);

    // Calculate dimensions in tiles
    const objectWidth = Math.ceil(tempDiv.offsetWidth / unitSize);
    const objectHeight = Math.ceil(tempDiv.offsetHeight / unitSize);

    // Search placement map for first fitting position
    for (let row = 0; row < placementMap.length; row++) {
        for (let col = 0; col < placementMap[0].length; col++) {
            let fits = true;
            for (let y = 0; y < objectHeight; y++) {
                for (let x = 0; x < objectWidth; x++) {
                    if (!placementMap[row + y] || !placementMap[row + y][col + x]?.canPlace) {
                        fits = false;
                        break;
                    }
                }
                if (!fits) break;
            }
            if (fits) return [col, row + objectHeight - 1];
        }
    }
    return null;
}


function scalePreview() {
    const holders = document.querySelectorAll(".item-preview-holder");

    holders.forEach(holder => {
        const preview = holder.querySelector(".item-preview");
        if (!preview) return; // safety check

        const holderW = holder.clientWidth;
        const holderH = holder.clientHeight;
        const previewW = preview.scrollWidth;
        const previewH = preview.scrollHeight;

        const scale = Math.min(holderW / previewW, holderH / previewH, 1);
        preview.style.setProperty("--scale", scale);
    });
}


// CREATE SHOPPING FUNCTIONALITY END

function renderPetAssetsDropdown(selectedPetType = null) {
    const dropdown = document.getElementById('pet-category-select');
    const container = document.getElementById('pet-supplies');
    
    if (!container) return;

    // If no pet selected, show message
    if (!selectedPetType) {
        container.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Pasirink augintin!';
        messageDiv.className = 'no-selection-message';
        container.appendChild(messageDiv);
        return;
    }

    // Check if there are any supplies at all
    if (!userPetAssets.supplies || Object.keys(userPetAssets.supplies).length === 0) {
        container.innerHTML = '';
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Maisto nra. Gali nupirkti parduotuvje.';
        messageDiv.className = 'no-supplies-message';
        container.appendChild(messageDiv);
        return;
    }

    // If dropdown exists, set up category filtering
    if (dropdown) {
        // Gather categories from currently owned Maistas (filtered by selected pet)
        const categoryCounts = {};
        let totalAssets = 0;
        
        for (const key in userPetAssets.supplies) {
            const asset = userPetAssets.supplies[key];
            if (!asset || asset.assetIndex == null) continue;
            
            const item = gameAssetIndex[asset.assetIndex];
            if (!item || !item.category) continue;

            // Skip skins (items with 'skin' in their css-class)
            if (item['css-class'] && item['css-class'].includes('skin')) continue;

            // Filter by selected pet type
            if (selectedPetType) {
                const cssClass = item['css-class'] || '';
                if (!cssClass.includes(selectedPetType.split('-')[0])) continue;
            }
            
            totalAssets++;
            item.category.forEach(cat => {
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });
        }

        // Clear existing options
        dropdown.innerHTML = '';

        // Add "All" option
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = `Visi`;
        allOption.selected = true;
        dropdown.appendChild(allOption);

        // Add categories (sorted alphabetically for consistency)
        Object.keys(categoryCounts).sort().forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = `${cat.charAt(0).toUpperCase() + cat.slice(1)}`;
            dropdown.appendChild(option);
        });

        // Filter on dropdown change
        dropdown.onchange = () => {
            renderPetSupplies(dropdown.value, selectedPetType);
        };
    }

    // Initial render
    renderPetSupplies('all', selectedPetType);
}

function renderPetSupplies(selectedCategory = 'all', selectedPetType = null) {
    const container = document.getElementById('pet-supplies');
    if (!container) return;

    container.innerHTML = '';

    // If no pet selected, show message
    if (!selectedPetType) {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Pasirink augintin!';
        messageDiv.className = 'no-selection-message';
        container.appendChild(messageDiv);
        return;
    }

    const petIdentifier = selectedPetType.split('-')[0];
    let hasMatchingSupplies = false;

    // Render Maistas
    for (const key in userPetAssets.supplies) {
        const asset = userPetAssets.supplies[key];
        const assetIndex = asset.assetIndex;
        const item = gameAssetIndex[assetIndex];
        
        if (!item) continue;

        // Skip skins (items with 'skin' in their css-class)
        if (item['css-class'] && item['css-class'].includes('skin')) continue;

        // Category filter
        if (selectedCategory !== 'all' && !item.category.includes(selectedCategory)) continue;

        // Filter by selected pet type
        const cssClass = item['css-class'] || '';
        if (!cssClass.includes(petIdentifier)) {
            continue;
        }

        hasMatchingSupplies = true;

        const itemDiv = document.createElement('div');
        itemDiv.className = `shop-item ${item.category.join(' ')}`;

        const previewDiv = document.createElement('div');
        previewDiv.className = `item-preview ${item['css-class']}`;

        const previewHolder = document.createElement('div');
        previewHolder.className = 'item-preview-holder';

        const infoDiv = document.createElement('div');
        infoDiv.className = 'item-info';

        const nameH3 = document.createElement('h3');
        nameH3.className = 'item-name';
        nameH3.textContent = item.title;

        const descP = document.createElement('p');
        descP.className = 'item-description';
        descP.innerHTML = item.description;
        descP.innerHTML += generateConsumableItemDescription(item)

        // Add quantity display for supplies
        if (asset.quantity) {
            const quantitySpan = document.createElement('span');
            quantitySpan.className = 'item-quantity';
            quantitySpan.textContent = ` (x${asset.quantity})`;
            nameH3.appendChild(quantitySpan);
        }

        infoDiv.appendChild(nameH3);
        infoDiv.appendChild(descP);

        let quantityInput = null;
        if (!item.oneOfKind && item.stackable !== false) {
            const quantityInputHolder = document.createElement('div');
            quantityInputHolder.className = 'pet-supply-use-quantity-holder input-wrapper';

            const quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.min = 1;
            quantityInput.max = asset.quantity; // don't allow more than owned
            quantityInput.value = 1;
            quantityInput.className = 'pet-supply-use-quantity';
            quantityInput.readOnly = true; // prevent manual typing if using buttons

            // Buttons
            const minusBtn = document.createElement('button');
            minusBtn.className = 'control-btn';
            minusBtn.textContent = '';
            minusBtn.onmousedown = () => startHold(quantityInput.id, 1, asset.quantity, false, updateQuantity);
            minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
            minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, asset.quantity, false, updateQuantity); };
            minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

            const plusBtn = document.createElement('button');
            plusBtn.className = 'control-btn';
            plusBtn.textContent = '+';
            plusBtn.onmousedown = () => startHold(quantityInput.id, 1, asset.quantity, true, updateQuantity);
            plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
            plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, asset.quantity, true, updateQuantity); };
            plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

            quantityInput.id = `pet-supply-qty-${asset.assetIndex}`;

            quantityInputHolder.appendChild(minusBtn);
            quantityInputHolder.appendChild(quantityInput);
            quantityInputHolder.appendChild(plusBtn);

            // Update function
            function updateQuantity(input) {
                if (!input) input = quantityInput;
                let value = parseInt(input.value, 10);
                const min = parseInt(input.min, 10);
                const max = parseInt(input.max, 10);
                if (isNaN(value) || value < min) value = min;
                if (value > max) value = max;
                input.value = value;
            }

            // Optional: if you want manual input allowed
            quantityInput.addEventListener('input', () => updateQuantity(quantityInput));
            quantityInput.addEventListener('change', () => updateQuantity(quantityInput));

            infoDiv.appendChild(quantityInputHolder);
        }

        const btn = document.createElement('button');
        btn.className = 'use-btn';

        // Handle different types of Maistas
        if (item.stackable === false && item.oneOfKind) {
            // Non-consumable items (like beds, toys)
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                console.log(`Using ${item.title}`);
            });
        } else {
            // Consumable items
            btn.textContent = 'Naudoti';
            if (item.stackable === false && item.oneOfKind) {
            // Non-consumable items (like beds, toys)
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                usePetSupply(key);
            });
        } else {
            // Consumable items with quantity support
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                const useQuantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                if (asset.quantity >= useQuantity) {
                    usePetSupply(key, useQuantity);
                }
            });
        }
        }

        previewHolder.appendChild(previewDiv);
        itemDiv.appendChild(previewHolder);
        itemDiv.appendChild(infoDiv);
        itemDiv.appendChild(btn);
        container.appendChild(itemDiv);
    }

    // If no matching supplies found after filtering
    if (!hasMatchingSupplies) {
        const messageDiv = document.createElement('div');
        messageDiv.textContent = `Maisto tinkamo iam augintiniui nra. Gali nupirkti parduotuvje.`;
        messageDiv.className = 'no-matching-supplies-message';
        container.appendChild(messageDiv);
    }

    scalePreview();
}

function usePetSupply (itemIndex, useQuantity=1) {
    selectedConsumable = [itemIndex, useQuantity];
    const item = userPetAssets["supplies"][itemIndex]
    const itemInfo = gameAssetIndex[item.assetIndex]
    const provides = itemInfo["provides"][0]
    const providesFor = itemInfo["provides"][1]
    if (provides === "food") {
        document.getElementById("pet-room-button").click();
        selectFullSpeciesBowls (providesFor)

    } else if (provides === "love") {
        selectedConsumable = [itemIndex, useQuantity];
        
        document.getElementById("pet-room-button").click();

        messageToTheUser(`Pasirink augintin.`, false)
    }
}

function selectFullSpeciesBowls (providesFor) {
    const objects = document.querySelectorAll('.room-object');
    let foodBowls = []
    providesFor.forEach(item => {
    const matching = Array.from(objects).filter(obj =>
        obj.className.includes(`${item}-food-bowl`) && !obj.className.includes("furniture-preview") && !obj.className.includes("full")
    );
        foodBowls.push(...matching); // add to the overall list
    });

    if (foodBowls.length === 0) {
        messageToTheUser(`Nra tinkamo tucio maisto dubenlio.`)
    } else {
        highlightSpecificObjects(foodBowls);
    }
}

function highlightSpecificObjects(objects) {
    objects.forEach(obj => {
        const coords = getObjectCoordinates(obj.id)
        const objectWidth = Math.ceil(obj.offsetWidth / unitSize);
        const objectHeight = Math.ceil(obj.offsetHeight / unitSize);
        const occupiedTiles = getTilesOccupiedByObject(coords, objectWidth, objectHeight)
          
        for (let i = 0; i < occupiedTiles.length; i++) {
            console.log(occupiedTiles[i])
            createPlacementHighlight(occupiedTiles[i][0], occupiedTiles[i][1], true)
        }  
    });
    
    messageToTheUser(`Pasirink maisto dubenl.`, false)
}

function getTilesOccupiedByObject(bottomLeft, width, height) {
    if (!bottomLeft || !Array.isArray(bottomLeft) || bottomLeft.length < 2) {
        return [];
    }

    const [x, y] = bottomLeft;
    const tiles = [];

    for (let dx = 0; dx < width; dx++) {
        for (let dy = 0; dy < height; dy++) {
            tiles.push([x + dx, y - dy]); 
        }
    }
    return tiles;
}

function renderPetSkins(selectedPetType = null) {
    const container = document.getElementById('pet-skins');
    if (!container) return;

    container.innerHTML = '';

    // If specific pet selected, only show that pet's skins
    if (selectedPetType && userPetAssets.pets[selectedPetType] && userPetAssets.pets[selectedPetType].skins) {
        const pet = userPetAssets.pets[selectedPetType];
        
        for (const skinKey in pet.skins) {
            const skin = pet.skins[skinKey];
            const assetIndex = skin.assetIndex;
            const item = gameAssetIndex[assetIndex];
            
            if (!item) continue;

            // Simplified skin check - look for 'skin' in css-class
            if (!item['css-class'] || !item['css-class'].includes('skin')) continue;

            if (selectedPetType && !item['css-class'].includes(selectedPetType)) continue;

            const itemDiv = document.createElement('div');
            itemDiv.className = `shop-item ${item.category.join(' ')}`;

            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']}`;

            const previewHolder = document.createElement('div');
            previewHolder.className = 'item-preview-holder';

            const infoDiv = document.createElement('div');
            infoDiv.className = 'item-info';

            const nameH3 = document.createElement('h3');
            nameH3.className = 'item-name';
            nameH3.textContent = item.title;

            const descP = document.createElement('p');
            descP.className = 'item-description';
            descP.innerHTML = item.description;
            descP.innerHTML += generateConsumableItemDescription(item)

            infoDiv.appendChild(nameH3);
            infoDiv.appendChild(descP);

            const btn = document.createElement('button');
            
            if (skin.equiped) {
                btn.textContent = 'Naudojama';
                btn.disabled = true;
                btn.className = 'use-btn equipped';
            } else {
                btn.textContent = 'Naudoti';
                btn.className = 'use-btn';
                btn.addEventListener('click', () => {
                    // Unequip other skins of the same pet type
                    for (const otherSkinKey in pet.skins) {
                        pet.skins[otherSkinKey].equiped = false;
                    }
                    // Equip this skin
                    skin.equiped = true;
                    
                    sendPetAssetsUpdateToDatabase();
                    renderUsersPetAssets();
                });
            }

            previewHolder.appendChild(previewDiv);
            itemDiv.appendChild(previewHolder);
            itemDiv.appendChild(infoDiv);
            itemDiv.appendChild(btn);
            container.appendChild(itemDiv);
        }
    } else {
        // Show message when no specific pet is selected
        const messageDiv = document.createElement('div');
        messageDiv.textContent = 'Please select a pet to view their skins';
        messageDiv.className = 'no-selection-message';
        container.appendChild(messageDiv);
    }

    scalePreview();
}

function ensurePetSelection() {
    // Ensure a pet is always selected when pets are available
    if ((!selectedPet || !userPetAssets.pets[selectedPet]) && Object.keys(userPetAssets.pets).length > 0) {
        selectedPet = Object.keys(userPetAssets.pets)[0];
        syncPetSelection();
    }
}

function renderPetListForPetSection() {
    const container = document.getElementById('pet-list-owned');
    if (!container) return;

    container.innerHTML = '';

    // Ensure we have a selected pet if pets exist
    if (!selectedPet && Object.keys(userPetAssets.pets).length > 0) {
        selectedPet = Object.keys(userPetAssets.pets)[0];
    }

    // Render buttons for each owned pet
    for (const petType in userPetAssets.pets) {
        const pet = userPetAssets.pets[petType];
        
        // Find the equipped skin to show preview
        let equippedSkinAssetIndex = null;
        for (const skinKey in pet.skins) {
            if (pet.skins[skinKey].equiped) {
                equippedSkinAssetIndex = pet.skins[skinKey].assetIndex;
                break;
            }
        }

        // If no equipped skin, use the first available skin
        if (!equippedSkinAssetIndex && Object.keys(pet.skins).length > 0) {
            const firstSkinKey = Object.keys(pet.skins)[0];
            equippedSkinAssetIndex = pet.skins[firstSkinKey].assetIndex;
        }

        const petItem = gameAssetIndex[equippedSkinAssetIndex];
        if (!petItem) continue;

        // --- Pet button ---
        const petBtn = document.createElement('button');
        petBtn.className = `pet-btn ${selectedPet === petType ? 'active' : ''}`;
        
        const previewDiv = document.createElement('div');
        previewDiv.className = `pet-preview ${petItem["css-class"].split(" ").slice(0, 2).join(" ")}`;
        petBtn.appendChild(previewDiv);

        petBtn.addEventListener('click', () => {
            selectedPet = petType;
            
            // Update active state for pet section buttons only
            document.querySelectorAll('#pet-list-owned .pet-btn').forEach(btn => btn.classList.remove('active'));
            petBtn.classList.add('active');

            // Check which content is currently visible and refresh it
            const petSkinsContainer = document.getElementById('pet-skins');
            const petSuppliesContainer = document.getElementById('pet-supplies');
            
            if (petSuppliesContainer && petSuppliesContainer.style.display !== 'none') {
                renderPetAssetsDropdown(selectedPet);
            } else if (petSkinsContainer && petSkinsContainer.style.display !== 'none') {
                renderPetSkins(selectedPet);
            } else {
                // Fallback: check active department button
                const activeDepartment = document.querySelector('#pet-asset-container .department-btn.active .department-label').textContent;
                if (activeDepartment === 'Ivaizda') {
                    renderPetSkins(selectedPet);
                } else if (activeDepartment === 'Maistas' || activeDepartment === 'Reikmenys') {
                    renderPetAssetsDropdown(selectedPet);
                }
            }
        });

        // --- Delete Pet button ---
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'pet-delete-btn';
        deleteBtn.textContent = 'Atiduoti';
        deleteBtn.addEventListener('click', () => {
            showCustomConfirm("Ar tikrai nori atiduoti  augintin  gyvunli namus? Jo susigrinti negalsi.", deletePetConfirmed, petType);
        });

        const petSectionPetButtonContainer = document.createElement('div');
        petSectionPetButtonContainer.className = 'pet-section-pet-button-container';

        petSectionPetButtonContainer.appendChild(deleteBtn)
        petSectionPetButtonContainer.appendChild(petBtn)
        
        container.appendChild(petSectionPetButtonContainer);
    }
}

function showCustomConfirm(text, onConfirm, item) {
    const modal = document.getElementById('customConfirmModal');
    const modalText = document.getElementById('customModalText');
    const yesBtn = document.getElementById('customConfirmYes');
    const noBtn = document.getElementById('customConfirmNo');

    // Set text
    modalText.textContent = text;

    // Show modal
    modal.style.display = 'flex';

    // Remove previous click handlers
    yesBtn.onclick = null;
    noBtn.onclick = null;

    // Yes click
    yesBtn.onclick = () => {
        onConfirm(item);
        modal.style.display = 'none';
    };

    // No click
    noBtn.onclick = () => {
        modal.style.display = 'none';
    };
}

function deletePetConfirmed(petId) {
    delete userPetAssets["pets"][petId];
    
    // Reset selectedPet if the deleted pet was selected
    if (selectedPet === petId) {
        selectedPet = null;
    }

    const petDiv = document.getElementById(petId);

    if (petDiv) {
        petDiv.remove();
    }
    
    sendPetAssetsUpdateToDatabase();
    deletePetStatsInDatabase(petId)
    renderUsersPetAssets();
    updateStatsBeforeRerunningInitGameAndRenderPets();
    renderPets();
    enablePetDragging();
    createPetButtons();
}

async function deletePetStatsInDatabase(petId) {
    try {
        const response = await apiFetch(apiBase + 'petGame/deletePetStats', {
            method: 'POST', // or 'DELETE' if backend is updated
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                studentId: userData.userId,
                petId: petId
            })
        });

        if (!response) {
            return;
        }

        if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
        }

        console.log(`Successfully deleted pet stats for: ${petId}`);

        // Optionally remove the pets element from the UI
        const petDiv = document.getElementById(petId);
        if (petDiv) {
            petDiv.remove();
        }

    } catch (error) {
        console.error("Error deleting pet stats:", error);
    }
}

document.addEventListener("DOMContentLoaded", () => {
  const checkbox = document.getElementById("shop-not-owned-toggle");
  const switchText = document.querySelector(".switch-text-shop");

  if (checkbox && switchText) {
    checkbox.addEventListener("change", () => {
      switchText.textContent = checkbox.checked ? "" : "NETURIU";
    });
  }

  const checkbox2 = document.getElementById("object-usage-toggle");
  const switchText2 = document.querySelector(".switch-text-object");

  if (checkbox2 && switchText2) {
    checkbox2.addEventListener("change", () => {
      switchText2.textContent = checkbox2.checked ? "" : "NENAUD.";
    });
}
});


function renderUsersPetAssets() {
    renderPetListForPetSection();

    const departmentBtns = document.querySelectorAll('#pet-asset-container .department-btn');
    const petSkinsContainer = document.getElementById('pet-skins');
    const petSuppliesContainer = document.getElementById('pet-supplies');

    departmentBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            departmentBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            const departmentLabel = btn.querySelector('.department-label').textContent;
            
            // Ensure pet selection before rendering content
            ensurePetSelection();
            
            // Get the currently selected pet (now guaranteed to exist)
            let currentSelectedPet = selectedPet;
            const dropdown = document.getElementById('pet-category-select');
            
            if (departmentLabel === 'Ivaizda') {
                petSkinsContainer.style.display = 'grid';
                petSuppliesContainer.style.display = 'none';
                renderPetSkins(currentSelectedPet);
                dropdown.style.display = "none";
            } else if (departmentLabel === 'Maistas' || departmentLabel === 'Reikmenys') {
                petSkinsContainer.style.display = 'none';
                petSuppliesContainer.style.display = 'grid';
                dropdown.style.display = "flex";
                renderPetAssetsDropdown(currentSelectedPet);
            }
        });
    });

    // Ensure pet selection and render initial content
    ensurePetSelection();
    renderPetAssetsDropdown(selectedPet);
    document.getElementById('pet-category-select').style.display = "flex";
}

// Generate segments dynamically
function createSegments(barId, maxValue = 12) {
    const bar = document.getElementById(barId);
    if (!bar) return;
    const segmentsContainer = bar.querySelector('.segments');
    segmentsContainer.innerHTML = ''; // clear existing
    for (let i = 0; i < maxValue; i++) {
        const span = document.createElement('span');
        span.className = 'segment';
        segmentsContainer.appendChild(span);
    }
}

// Initialize bars for all stats
['food-bar', 'water-bar', 'love-bar'].forEach(barId => createSegments(barId));


const allPets = document.querySelectorAll("#petContainer .pet");
let activePetId = allPets[0]; // default to first pet

function createPetButtons() {
    const container = document.getElementById('pet-buttons');
    const checkboxHolder = document.getElementById('pet-on-walk-checkbox-holder');

    container.innerHTML = ''; // clear existing buttons
    checkboxHolder.innerHTML = ''; // clear existing checkboxes

    const allPets = document.querySelectorAll("#petContainer .pet");

    allPets.forEach((pet, index) => {
        // --- Create pet button ---
        const btn = document.createElement('button');
        btn.innerHTML = `
                        <div class="pet-stats-selection-button-text">
                            ${userPetAssets["pets"][pet.id].name}
                        <div id="pet-stats-selection-button-indicator-${pet.id}" class="pet-stats-selection-button-indicator"></div>
                        </div>
                        `;

        btn.className = index === 0 ? 'active' : ''; // first button active by default
        btn.classList.add("pet-stats-selection-button");

        // --- Create associated checkbox div ---
        const walkDiv = document.createElement('div');
        walkDiv.className = 'pet-on-walk-holder';
        walkDiv.style.display = 'none'; // hidden by default

        const label = document.createElement('label');
        label.className = 'switch'; // for styling

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `pet-on-walk-toggle-${pet.id}`;
        checkbox.className = "pet-on-walk-toggle";
        const skins = userPetAssets.pets[pet.id].skins
        const equippedSkin = Object.values(skins).find(skin => skin.equiped);
        equippedSkinName = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];
        checkbox.checked = petOnWalk === equippedSkinName;

        const span = document.createElement('span');
        span.className = 'switch-slider';

        // Add text inside the switch
        const switchText = document.createElement('span');
        switchText.className = 'switch-text switch-text-pet';
        switchText.textContent = checkbox.checked ? '' : 'KARTU';
        span.appendChild(switchText);

        label.appendChild(checkbox);
        label.appendChild(span);
        walkDiv.appendChild(label);
        checkboxHolder.appendChild(walkDiv);

        // --- Button click logic ---
        btn.onclick = () => {
            // Remove active class from all buttons
            container.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active'); // mark clicked button active

            // Show only the checkbox associated with this pet
            checkboxHolder.querySelectorAll('.pet-on-walk-holder').forEach(div => div.style.display = 'none');
            walkDiv.style.display = 'flex';

            displayPetStats(pet.id);
        };

        // --- Checkbox logic ---
        checkbox.onchange = () => {
            if (checkbox.checked) {
                // untick all other checkboxes
                checkboxHolder.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    if (cb !== checkbox) cb.checked = false;
                });
                const skins = userPetAssets.pets[pet.id].skins
                const equippedSkin = Object.values(skins).find(skin => skin.equiped);
                petOnWalk = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];
                console.log(petOnWalk)
                sendPetOnWalkUpdateToServer();
                switchText.textContent = '';
                // update other switches
                checkboxHolder.querySelectorAll('.switch-text-pet').forEach(st => {
                    if (st !== switchText) st.textContent = 'KARTU';
                });
            } else {
                petOnWalk = "";
                sendPetOnWalkUpdateToServer();
                switchText.textContent = 'KARTU';
            }
        };

        container.appendChild(btn);

        // Show the checkbox of the initially active button
        if (index === 0) {
            walkDiv.style.display = 'flex';
        }
    });
}

async function sendPetOnWalkUpdateToServer() {
    try {
        const response = await apiFetch(apiBase + 'petGame/petOnWalk', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': userData.token
            },
            body: JSON.stringify({ studentId: userData.userId, petOnWalk: petOnWalk })
        });

        if (!response) {
            return;
        }

        if (response.ok) {
            document.querySelector('.some-pet-element')?.classList.add('tick-svg');
            userData.petOnWalk = petOnWalk
            localStorage.setItem('userData', JSON.stringify(userData));
            return true;
        } else {
            console.error(`Failed to update pet stats: ${response.status}`);
            messageToTheUser("Nepavyko pasiimti augintinio kartu  uduotis. Bandyk vl vliau.")
            return false;
        }
    } catch (error) {
        console.error('Error sending pet stats update:', error);
        messageToTheUser("Nepavyko pasiimti augintinio kartu  uduotis. Bandyk vl vliau.")
        return false;
    }
}

function updatePetOnWalkStatsInLocalStorage (petId, statList) {
    const skins = userPetAssets.pets[petId].skins
    const equippedSkin = Object.values(skins).find(skin => skin.equiped);
    const equippedSkinName = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];

    if (petOnWalk === equippedSkinName) {
        userData.petStats = statList
        localStorage.setItem('userData', JSON.stringify(userData));
    }
}


// Display stats for the selected pet
function displayPetStats(activePetId) {
    const currentPet = document.getElementById(activePetId);
    const currentTime = Math.floor(Date.now() / 1000 / 60);
    const timeElapsed = currentTime - currentPet._stats.date;
    const statDecrease = Math.floor(timeElapsed * PET_STATS_EXPIRATION);

    const petSpecies = activePetId.split("-")[0];
    const bonusStats = bonusFromDailySupplyItems();

    currentPet._stats.food = Math.max(bonusStats[petSpecies]?.food ?? 0, currentPet._stats.food - statDecrease);
    currentPet._stats.foodNew = Math.max(bonusStats[petSpecies]?.food ?? 0, currentPet._stats.foodNew - statDecrease);
    currentPet._stats.water = Math.max(bonusStats[petSpecies]?.water ?? 0, currentPet._stats.water - statDecrease);
    currentPet._stats.waterNew = Math.max(bonusStats[petSpecies]?.water ?? 0, currentPet._stats.waterNew - statDecrease);
    currentPet._stats.love = Math.max(bonusStats[petSpecies]?.love ?? 0, currentPet._stats.love - statDecrease);
    currentPet._stats.loveNew = Math.max(bonusStats[petSpecies]?.love ?? 0, currentPet._stats.loveNew - statDecrease);
    currentPet._stats.date = currentTime;

    updatePetOnWalkStatsInLocalStorage(activePetId, [currentPet._stats.foodNew, currentPet._stats.waterNew, currentPet._stats.loveNew, currentPet._stats.date])

    setPetStatsBar("food-bar", currentPet._stats.food+1);
    setPetStatsBar("water-bar", currentPet._stats.water+1);
    setPetStatsBar("love-bar", currentPet._stats.love+1);

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        calculateHappinesIndexForPet(pet.id)
    });

    function setPetStatsBar(barId, value) {
        const bar = document.getElementById(barId);
        if (!bar) return;
        const segments = bar.getElementsByClassName('segment');

        let color;
        if (value <= 2) color = '#e74c3c';
        else if (value <= 5) color = '#f1c40f';
        else color = '#2ecc71';

        for (let i = 0; i < segments.length; i++) {
            segments[i].style.backgroundColor = i < value ? color : 'rgba(0,0,0,0)';
        }
    }
}

function increasePetStatsInDatabase(petId, stat, amount) {
    const currentPet = document.getElementById(petId)

    const currentTime = Math.floor(Date.now() / 1000 / 60);
    const timeElapsed = currentTime - currentPet._stats.date;
    const statDecrease = Math.floor(timeElapsed * PET_STATS_EXPIRATION);

    const petSpecies = petId.split("-")[0];
    const bonusStats = bonusFromDailySupplyItems();

    currentPet._stats.food = Math.max(bonusStats[petSpecies]["food"], currentPet._stats.food - statDecrease);
    currentPet._stats.foodNew = Math.max(bonusStats[petSpecies]["food"], currentPet._stats.foodNew - statDecrease);
    currentPet._stats.water = Math.max(bonusStats[petSpecies]["water"], currentPet._stats.water - statDecrease);
    currentPet._stats.waterNew = Math.max(bonusStats[petSpecies]["water"], currentPet._stats.waterNew - statDecrease);
    currentPet._stats.love = Math.max(bonusStats[petSpecies]["love"], currentPet._stats.love - statDecrease);
    currentPet._stats.loveNew = Math.max(bonusStats[petSpecies]["love"], currentPet._stats.loveNew - statDecrease);

    let newAmount = currentPet._stats[stat] + amount;
    if (newAmount > 10) newAmount = 10;
    currentPet._stats[`${stat}New`] = newAmount
    currentPet._stats.date = Math.floor(Date.now() / 1000 / 60);
    sendPetStatsUpdateToDatabase(petId);
}



function increasePetStatsInDisplay(petId, stat) {
    const pet = document.getElementById(petId)

    pet._stats[`${stat}`] = pet._stats[`${stat}New`]
    
    const statsPetButtons = document.querySelectorAll("button.pet-stats-selection-button");
    const targetStatsButton = Array.from(statsPetButtons).find(btn => btn.textContent.trim() === userPetAssets["pets"][petId].name);

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        calculateHappinesIndexForPet(pet.id)
    });
    
    if (targetStatsButton) {
        targetStatsButton.click();
    }
}


function displayWaterBowlFillingOptions(obj) {
    if (obj.className.includes("full")) {
        messageToTheUser("Dubenelis jau pilnas!")
        return
    }

    const speciesSuitableForBowl = [...new Set(
        Array.from(obj.classList)
            .filter(cls => cls.includes("water-bowl") && cls !== "water-bowl" && !cls.includes("furniture-preview"))
            .map(cls => cls.split("-")[0])
    )]
    .map(species => speciesTranslationDict[species] || species)  // translate each if available
    .join(", ");

    const waterBowlOptionsElement = document.createElement('div');
    waterBowlOptionsElement.className = 'water-bowl-options-container';

    const btn = document.createElement('button');
        btn.className = 'fill-water-bowl-btn';
        btn.textContent = 'Pripildyti';
        btn.addEventListener('click', () => {
            closeObjectPopup();

            if (!taxesData.waterTax.paid) {
                messageToTheUser("Nra vandens. Sumokk vandens mokest!","error");
                return
            }
            
            obj.classList.add("full")
            initUserTriggeredAction("water", obj)
        });

        waterBowlOptionsElement.appendChild(btn);

    openObjectPopup(waterBowlOptionsElement, 'Vandens dubenlis', `Tinka: ${speciesSuitableForBowl}`)
}

function displayBathFillingOption(obj) {
    if (obj._full && obj._full === true) {
        messageToTheUser("Vonia jau pripilta!")
        return
    }

    const speciesSuitableForBath = [...new Set(
        Array.from(obj.classList)
            .filter(cls => cls.includes("-bath") && !cls.includes("furniture-preview"))
            .map(cls => cls.split("-")[0])
    )]
    .map(species => speciesTranslationDict[species] || species)
    .join(", ");

    const bathOptionsElement = document.createElement('div');
    bathOptionsElement.className = 'bath-options-container';

    const btn = document.createElement('button');
        btn.className = 'fill-bath-btn';
        btn.textContent = 'Pripildyti';
        btn.addEventListener('click', () => {
            closeObjectPopup();

            if (!taxesData.waterTax.paid) {
                messageToTheUser("Nra vandens. Sumokk vandens mokest!","error");
                return
            }
            
            obj._full = true;

            const bathType = Array.from(obj.classList).find(cls => cls.startsWith("bath-"))
            setObjectAnimation(obj, `${bathType}-filled`)
            initUserTriggeredAction("bath", obj)
        });

        bathOptionsElement.appendChild(btn);

    openObjectPopup(bathOptionsElement, 'Vonia', `Tinka: ${speciesSuitableForBath}`)
}


function displayFoodOptions(obj) {
    if (obj.className.includes("full")) {
        messageToTheUser("Dubenelis jau pilnas!");
        return;
    }

    if (selectedConsumable.length !== 0 &&
        gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex]["provides"][0] === "food"
    ) {
        const selectedFoodInfo = gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex];
        const targetClasses = selectedFoodInfo.provides[1];

        if (!targetClasses.some(cls => obj.className.includes(cls))) {
            messageToTheUser("Dubenlis netinkamas iam maistui.");
            return;
        }

        clearPlacementHighlights();

        obj.classList.add("full");
        obj._foodContent = [selectedFoodInfo["provides"], selectedConsumable[1]];

        initUserTriggeredAction("food", obj);

        const updatedQuantity = userPetAssets["supplies"][selectedConsumable[0]]["quantity"] - selectedConsumable[1];
        if (updatedQuantity <= 0) {
            delete userPetAssets.supplies[selectedConsumable[0]];
        } else {
            userPetAssets.supplies[selectedConsumable[0]]["quantity"] = updatedQuantity;
        }
        selectedConsumable = [];
        clearPlacementHighlights();
        sendPetAssetsUpdateToDatabase();
    } else {
        selectedConsumable = [];
        const matchedSupplies = [];

        Object.entries(userPetAssets.supplies).forEach(([supplyKey, supply]) => {
            const item = gameAssetIndex[supply.assetIndex];
            if (item && item["provides"][0] === "food") {
                const targetClasses = item.provides[1];
                targetClasses.forEach(cls => {
                    for (const c of obj.classList) {
                        if (c.includes(cls)) {
                            matchedSupplies.push({ key: supplyKey, supply, item });
                            break;
                        }
                    }
                });
            }
        });

        // Create container element
        const foodOptionsElement = document.createElement('div');
        foodOptionsElement.className = 'food-options-container';

        const speciesSuitableForBowl = [...new Set(
            Array.from(obj.classList)
                .filter(cls => cls.includes("food-bowl") && cls !== "food-bowl")
                .map(cls => cls.split("-")[0])
        )]
            .map(species => speciesTranslationDict[species] || species)
            .join(", ");

        if (matchedSupplies.length === 0) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const noItemMessage = document.createElement('div');
            noItemMessage.className = 'no-item-message';
            noItemMessage.innerHTML = "Maisto tinkamo dti   dubenl nra. Gali nupirkti parduotuvje.";

            foodOptionsElement.append(noItemMessage);
        }

        matchedSupplies.forEach(({ key, supply, item }) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']}`;

            const previewHolder = document.createElement('div');
            previewHolder.className = 'food-item-preview-holder';

            previewHolder.appendChild(previewDiv)

            const nameH3 = document.createElement('h3');
            nameH3.className = 'food-item-name';
            nameH3.textContent = item.title;

            const description = document.createElement('div');
            description.className = 'food-item-description';
            description.innerHTML = item.description + generateConsumableItemDescription(item);

            const quantitySpan = document.createElement('span');
            quantitySpan.className = 'item-quantity';
            quantitySpan.textContent = ` (x${supply.quantity})`;

            const nameAndDescriptionHolder = document.createElement('div');
            nameAndDescriptionHolder.className = 'food-item-name-description-holder';

            nameH3.appendChild(quantitySpan);
            nameAndDescriptionHolder.appendChild(nameH3);
            nameAndDescriptionHolder.appendChild(description);

            const previewAndTextHolder = document.createElement('div');
            previewAndTextHolder.className = 'food-item-preview-text-holder';
            previewAndTextHolder.appendChild(previewHolder);
            previewAndTextHolder.appendChild(nameAndDescriptionHolder);

            // Quantity input if stackable
            let quantityInput = null;
            let quantityInputHolder = null;

            if (supply.quantity) {
                quantityInputHolder = document.createElement('div');
                quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';

                quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = 1;
                quantityInput.max = supply.quantity;
                quantityInput.step = 1;
                quantityInput.value = 1;
                quantityInput.className = 'food-quantity-input';
                quantityInput.readOnly = true;
                quantityInput.id = `food-qty-${supply.assetIndex}`;

                const minusBtn = document.createElement('button');
                minusBtn.className = 'control-btn';
                minusBtn.textContent = '';
                minusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, false, updateQuantity);
                minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, false, updateQuantity); };
                minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                const plusBtn = document.createElement('button');
                plusBtn.className = 'control-btn';
                plusBtn.textContent = '+';
                plusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, true, updateQuantity);
                plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, true, updateQuantity); };
                plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                quantityInputHolder.appendChild(minusBtn);
                quantityInputHolder.appendChild(quantityInput);
                quantityInputHolder.appendChild(plusBtn);

                const quantAndBtnHolder = document.createElement('div');
                quantAndBtnHolder.className = 'food-item-quant-btn-holder';
                quantAndBtnHolder.appendChild(quantityInputHolder);

                // Keep value within min/max if manually edited
                quantityInput.addEventListener('input', () => {
                    let value = parseInt(quantityInput.value, 10);
                    const max = parseInt(quantityInput.max, 10);
                    const min = parseInt(quantityInput.min, 10);
                    if (isNaN(value) || value < min) value = min;
                    if (value > max) value = max;
                    quantityInput.value = value;
                    updateQuantity(quantityInput);
                });
                quantityInput.addEventListener('change', () => updateQuantity(quantityInput));

                function updateQuantity(input) {
                    console.log('Selected quantity:', input.value);
                }

                itemDiv.appendChild(previewAndTextHolder);
                itemDiv.appendChild(quantAndBtnHolder);
            } else {
                const quantAndBtnHolder = document.createElement('div');
                quantAndBtnHolder.className = 'food-item-quant-btn-holder';
                itemDiv.appendChild(previewAndTextHolder);
                itemDiv.appendChild(quantAndBtnHolder);
            }

            // Use button
            const btn = document.createElement('button');
            btn.className = 'food-use-btn';
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                const useQuantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                if (supply.quantity >= useQuantity) {
                    supply.quantity -= useQuantity;
                    if (supply.quantity <= 0) {
                        delete userPetAssets.supplies[key];
                    } else {
                        userPetAssets.supplies[key]["quantity"] = supply.quantity;
                    }
                    sendPetAssetsUpdateToDatabase();
                    closeObjectPopup();
                    obj.classList.add("full");
                    obj._foodContent = [item["provides"], useQuantity];
                    initUserTriggeredAction("food", obj);
                }
            });

            itemDiv.querySelector('.food-item-quant-btn-holder')?.appendChild(btn);
            foodOptionsElement.appendChild(itemDiv);
        });

        openObjectPopup(foodOptionsElement, "Maisto dubenlis", `Tinka: ${speciesSuitableForBowl}`);
    }
}


function displayPetTreatOptions(obj) {
    if (selectedConsumable.length !== 0) {
        const selectedFoodInfo = gameAssetIndex[userPetAssets["supplies"][selectedConsumable[0]].assetIndex];

        if (selectedFoodInfo["provides"][0] === "love") {
            const targetClasses = selectedFoodInfo.provides[1];

            if (!targetClasses.some(cls => obj.className.includes(cls))) {
                messageToTheUser("Skanukas netinka iam augintiniui.");
                return;
            }

            initUserTriggeredAction("love", [obj, selectedFoodInfo["provides"][2], [selectedConsumable[1]]]);

            const updatedQuantity = userPetAssets["supplies"][selectedConsumable[0]]["quantity"] - selectedConsumable[1];
            if (updatedQuantity <= 0) {
                delete userPetAssets.supplies[selectedConsumable[0]];
            } else {
                userPetAssets.supplies[selectedConsumable[0]]["quantity"] = updatedQuantity;
            }
            selectedConsumable = [];
            sendPetAssetsUpdateToDatabase();
        }
    } else {
        const matchedSupplies = [];

        Object.entries(userPetAssets.supplies).forEach(([supplyKey, supply]) => {
            const item = gameAssetIndex[supply.assetIndex];
            if (item && item["provides"][0] === "love") {
                const targetClasses = item.provides[1];
                targetClasses.forEach(cls => {
                    for (const c of obj.classList) {
                        if (c.includes(cls)) {
                            matchedSupplies.push({ key: supplyKey, supply, item });
                            break;
                        }
                    }
                });
            }
        });

        const treatsOptionsElement = document.createElement('div');
        treatsOptionsElement.className = 'treats-options-container';

        if (matchedSupplies.length === 0) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const noItemMessage = document.createElement('div');
            noItemMessage.className = 'no-item-message';
            noItemMessage.innerHTML = "Skaniuk tinkam iam augintiniui nra. Gali nupirkti parduotuvje.";

            treatsOptionsElement.append(noItemMessage);
        }

        matchedSupplies.forEach(({ key, supply, item }) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'food-item';

            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']}`;

            const previewHolder = document.createElement('div');
            previewHolder.className = 'food-item-preview-holder';

            previewHolder.appendChild(previewDiv);

            const nameH3 = document.createElement('h3');
            nameH3.className = 'food-item-name';
            nameH3.textContent = item.title;

            const description = document.createElement('div');
            description.className = 'food-item-description';
            description.innerHTML = item.description + generateConsumableItemDescription(item);

            const quantitySpan = document.createElement('span');
            quantitySpan.className = 'item-quantity';
            quantitySpan.textContent = ` (x${supply.quantity})`;

            const nameAndDescriptionHolder = document.createElement('div');
            nameAndDescriptionHolder.className = 'food-item-name-description-holder';

            nameH3.appendChild(quantitySpan);
            nameAndDescriptionHolder.appendChild(nameH3);
            nameAndDescriptionHolder.appendChild(description);

            const previewAndTextHolder = document.createElement('div');
            previewAndTextHolder.className = 'food-item-preview-text-holder';
            previewAndTextHolder.appendChild(previewHolder);
            previewAndTextHolder.appendChild(nameAndDescriptionHolder);

            // Quantity input with buttons
            let quantityInput = null;
            let quantityInputHolder = null;

            if (supply.quantity) {
                quantityInputHolder = document.createElement('div');
                quantityInputHolder.className = 'purchase-quantity-holder input-wrapper';

                quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = 1;
                quantityInput.max = supply.quantity;
                quantityInput.step = 1;
                quantityInput.value = 1;
                quantityInput.className = 'food-quantity-input';
                quantityInput.readOnly = true;
                quantityInput.id = `treat-qty-${supply.assetIndex}`;

                const minusBtn = document.createElement('button');
                minusBtn.className = 'control-btn';
                minusBtn.textContent = '';
                minusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, false, updateQuantity);
                minusBtn.onmouseup = minusBtn.onmouseleave = stopHold;
                minusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, false, updateQuantity); };
                minusBtn.ontouchend = minusBtn.ontouchcancel = stopHold;

                const plusBtn = document.createElement('button');
                plusBtn.className = 'control-btn';
                plusBtn.textContent = '+';
                plusBtn.onmousedown = () => startHold(quantityInput.id, 1, supply.quantity, true, updateQuantity);
                plusBtn.onmouseup = plusBtn.onmouseleave = stopHold;
                plusBtn.ontouchstart = (e) => { e.preventDefault(); startHold(quantityInput.id, 1, supply.quantity, true, updateQuantity); };
                plusBtn.ontouchend = plusBtn.ontouchcancel = stopHold;

                quantityInputHolder.appendChild(minusBtn);
                quantityInputHolder.appendChild(quantityInput);
                quantityInputHolder.appendChild(plusBtn);

                // Keep value within min/max if manually edited
                quantityInput.addEventListener('input', () => {
                    let value = parseInt(quantityInput.value, 10);
                    const max = parseInt(quantityInput.max, 10);
                    const min = parseInt(quantityInput.min, 10);
                    if (isNaN(value) || value < min) value = min;
                    if (value > max) value = max;
                    quantityInput.value = value;
                    updateQuantity(quantityInput);
                });
                quantityInput.addEventListener('change', () => updateQuantity(quantityInput));

                function updateQuantity(input) {
                    console.log('Selected quantity:', input.value);
                }
            }

            const quantAndBtnHolder = document.createElement('div');
            quantAndBtnHolder.className = 'food-item-quant-btn-holder';
            if (quantityInputHolder) quantAndBtnHolder.appendChild(quantityInputHolder);

            // Use button
            const btn = document.createElement('button');
            btn.className = 'treat-use-btn';
            btn.textContent = 'Naudoti';
            btn.addEventListener('click', () => {
                const useQuantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                if (supply.quantity >= useQuantity) {
                    supply.quantity -= useQuantity;
                    if (supply.quantity <= 0) {
                        delete userPetAssets.supplies[key];
                    } else {
                        userPetAssets.supplies[key]["quantity"] = supply.quantity;
                    }
                    sendPetAssetsUpdateToDatabase();
                    closeObjectPopup();

                    initUserTriggeredAction("love", [obj, item["provides"][2], useQuantity]);
                }
            });

            quantAndBtnHolder.appendChild(btn);

            itemDiv.appendChild(previewAndTextHolder);
            itemDiv.appendChild(quantAndBtnHolder);

            treatsOptionsElement.appendChild(itemDiv);
        });

        openObjectPopup(
            treatsOptionsElement,
            `<div id="pet-container-${obj.id}">
                <span id="pet-name-${obj.id}">${userPetAssets["pets"][obj.id].name}</span>
                <button class="edit-name-button" onclick="editPetName('${obj.id}', this)">
                    <span class="edit-icon"><img src="../images/icons/icon-edit.svg"></span>
                </button>
            </div>`,
            ''
        );
    }
}


function generateConsumableItemDescription(item) {
    if (!item || item.provides.length !== 3) return '';

    const providesType = item.provides[0];
    const providesQuantity = item.provides[2];

    let container = `<div class="item-description-icons">`;

    container += `
        <svg class="item-description-icon">
            <use href="#icon-${providesType}"></use>
        </svg> x ${providesQuantity}
    `;

    if (!item.petAsset) {
        container += 'per dien'
    }

    container += `</div>`;
    return container;
}

document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        const allPets = document.querySelectorAll("#petContainer .pet");
        allPets.forEach(pet => {
            managePetActions(pet);
        });
    }
});

let autonomousPetActionCounter = 1;
let startingActions = {
    "cat-1": [startSleeping],
    "cat-2": [startSleeping]
};


async function startSleeping(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-sleeps`);

    const timeMin = 1000;
    const timeMax = 3000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    
    setObjectAnimation(pet, `${pet.id}-lays-idle`);

    const timeMin2 = 1000;
    const timeMax2 = 3000;
    const randomDuration2 = Math.floor(Math.random() * (timeMax2 - timeMin2 + 1)) + timeMin2;
    await cancellableWait(randomDuration2, signal);
    
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

function managePetActions(pet) {

    if (pet._busy) {
        return
    }

    const petRoomContainer = document.getElementById("pet-room-container");
    if (!petRoomContainer || 
        petRoomContainer.style.display === "none" || 
        !petRoomContainer.offsetParent || 
        document.hidden) {
        
        // Abort any ongoing action for this pet
        if (petControllers[pet.id]) {
            petControllers[pet.id].abort();
            setObjectAnimation(pet, `${pet.id}-stands-idle`);
            delete petControllers[pet.id]; // Clean up the controller
        }
        return; // Exit the function without starting new actions
    }

    // cancel any ongoing action for this pet
    if (petControllers[pet.id]) {
        petControllers[pet.id].abort();
        setObjectAnimation(pet, `${pet.id}-stands-idle`);
    }

    // create a new controller for this action chain
    const controller = new AbortController();
    petControllers[pet.id] = controller;

    if (startingActions[pet.id]?.length > 0) {
        const fn = startingActions[pet.id].shift(); // gets actual function
        fn(pet, controller.signal).catch(err => {
            if (err.name !== "AbortError") console.error(err);
        });
        return
    }

    if (pendingPetActions[pet.id] && pendingPetActions[pet.id].length !== 0) {
        const [fn, args] = pendingPetActions[pet.id][0];
        fn(...args, controller.signal).catch(err => {
            if (err.name !== "AbortError") console.error(err);
        });
    } else {

        let situationalPetActions = [];

        // Push arrays
        if (pet._stats.food <= 3) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["hungry"]);
        }

        if (pet._stats.water <= 3) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["thirsty"]);
        }

        if (pet._stats.love <= 3) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["sad"]);
        }

        if (!calculateHappinesIndexForPet(pet.id)) {
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["angry"]);
            situationalPetActions.push(petAutonomousActionsSituational[pet.id]["sad"]);
        }

        // Flatten the array of arrays into a single list of strings
        situationalPetActions = situationalPetActions.flat();

        let randomSituationalAction = null;
        if (situationalPetActions.length > 0) {
            // Now this will be a single string
            randomSituationalAction = situationalPetActions[Math.floor(Math.random() * situationalPetActions.length)];
        }

        if (autonomousPetActionCounter % 2 === 0) {
            // Even counter  pick random action from the list (if available)
            let randomNormalAction = petAutonomousActions[pet.id]?.length
                ? petAutonomousActions[pet.id][Math.floor(Math.random() * petAutonomousActions[pet.id].length)]
                : null;
            
            let randomAction; // Fixed: declare randomAction variable
            if (randomSituationalAction) {
                randomAction = [randomNormalAction, randomSituationalAction][Math.floor(Math.random() * 2)];
            } else {
                randomAction = randomNormalAction;
            }

            if (randomAction && typeof window[randomAction] === "function") {
                window[randomAction](pet, controller.signal).catch(err => {
                    if (err.name !== "AbortError") console.error(err);
                });
            }

            autonomousPetActionCounter++;
        } else {
            petWalksAround(pet, controller.signal);
            autonomousPetActionCounter++;
        }
    }
}

async function petDances(pet, signal) {
  if (signal.aborted) {
    cancelMovement(pet.id);
    throw new DOMException("Aborted", "AbortError");
  }

  cancelMovement(pet.id);
  setObjectAnimation(pet, `${pet.id}-dances`);

  await cancellableWait(4000, signal);

  if (signal.aborted) {
    cancelMovement(pet.id);
    throw new DOMException("Aborted", "AbortError");
  }

  pendingPetActions[pet.id].shift();
  managePetActions(pet);
}


async function petHappy(pet, quantity, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if (!quantity) return;

    cancelMovement(pet.id)

    setObjectAnimation(pet, `${pet.id}-happy`);

    await cancellableWait(2000, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    increasePetStatsInDisplay(pet.id, "love")

    pendingPetActions[pet.id].shift();

    managePetActions(pet);
}

async function petEats(pet, object, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if (!object) return;

    const provides = object._foodContent;
    const providesFor = provides[0][1];
    const providesQuantity = provides[0][2] * provides[1];

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]["assetIndex"]]["interactive-spot"];
    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [objectCoords[0] + objectInteractivePart[0], objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteractReverse = canPlaceObjectAt(objectInteractiveBottomRightCoords[0], objectInteractiveBottomRightCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if ((ableToPostitionToInteract && !ableToPostitionToInteractReverse) ||
        (ableToPostitionToInteract && petCoords[0] - objectCoords[0] >= 0)) {

        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "left");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "food");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else if (ableToPostitionToInteractReverse) {
        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveBottomRightCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "right");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "food");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else {
        messageToTheUser(`Augintiniai negali prieiti prie maisto. Perstatyk baldus!`);
        pendingPetActions[pet.id].shift();
        managePetActions(pet);
    }
}

async function petDrinks(pet, object, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if (!object) return;

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]["assetIndex"]]["interactive-spot"];
    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [objectCoords[0] + objectInteractivePart[0], objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteractReverse = canPlaceObjectAt(objectInteractiveBottomRightCoords[0], objectInteractiveBottomRightCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    if ((ableToPostitionToInteract && !ableToPostitionToInteractReverse) ||
        (ableToPostitionToInteract && petCoords[0] - objectCoords[0] >= 0)) {

        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "left");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "water");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else if (ableToPostitionToInteractReverse) {
        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveBottomRightCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-eats`);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "right");
        }

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, `${pet.id}-sits-idle`);
        increasePetStatsInDisplay(pet.id, "water");
        object.classList.remove("full");

        pendingPetActions[pet.id].shift();
        managePetActions(pet);

    } else {
        messageToTheUser(`Augintiniai negali prieiti prie maisto. Perstatyk baldus!`);
        pendingPetActions[pet.id].shift();
        managePetActions(pet);
    }
}


async function petBathes(pet, object, signal) {
    if (signal.aborted) {
        cancelMovement(pet.id)
        throw new DOMException("Aborted", "AbortError");
    }

    if (!object) return;

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]["assetIndex"]]["interactive-spot"];
    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [objectCoords[0] + objectInteractivePart[0], objectCoords[1] - objectInteractivePart[1]];

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];

    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());
    let ableToPostitionToInteractAlt = canPlaceObjectAt(objectCoords[0], objectCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

    let finalBathInteractionCoords = null;
    if (ableToPostitionToInteract) {
        finalBathInteractionCoords = objectInteractiveCoords
    } else if (ableToPostitionToInteractAlt) {
        finalBathInteractionCoords = objectCoords
    }

    if (finalBathInteractionCoords) {

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        await movePetToTile(pet, getObjectCoordinates(pet.id), finalBathInteractionCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        pet.style.visibility = "hidden";

        const bathType = Array.from(object.classList).find(cls => cls.startsWith("bath-"))

        const skins = userPetAssets.pets[pet.id].skins;

        let equippedSkin = Object.values(skins).find(skin => skin.equiped);
        
        if (!equippedSkin) {
            const firstSkinKey = Object.keys(skins)[0];
            equippedSkin = skins[firstSkinKey];
            equippedSkin.equiped = true;
            sendPetAssetsUpdateToDatabase();
        }

        const equippedSkinSecondClass = gameAssetIndex[equippedSkin.assetIndex]["css-class"].split(" ")[1];

        object.classList.add(equippedSkinSecondClass);

        setObjectAnimation(object, `${bathType}-with-pet`)
        pendingPetActions[pet.id].shift();
        pet._busy = true;

        await cancellableWait(5000, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        pet.style.visibility = "visible";

        setObjectAnimation(object, `${bathType}-empty`);
        object._full = false;
        pet._busy = false;

        managePetActions(pet);
    } else {
        messageToTheUser(`Augintinis negali prieiti prie vonios. Perstatyk baldus!`);
        pendingPetActions[pet.id].shift();
        managePetActions(pet);
    }
}

async function petSleeps(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    const objectContainer = document.getElementById("roomObjectsContainer");
    const allObjects = objectContainer.querySelectorAll("*");

    const petContainer = document.getElementById("petContainer");
    let tilesOccupiedByPets = [];

    const allPets = document.querySelectorAll("#petContainer .pet");
    allPets.forEach(pet => {
        const petPos = getObjectCoordinates(pet.id);
        const petWidth = Math.ceil(pet.offsetWidth / unitSize);
        const petHeight = Math.ceil(pet.offsetHeight / unitSize);
        tilesOccupiedByPets.push(...getTilesOccupiedByObject(petPos, petWidth, petHeight));
    });

    const petBeds = Array.from(allObjects).filter(el =>
        Array.from(el.classList).some(cls => cls.includes("cat-bed"))
    );

    const freeBeds = petBeds.filter(bed => {
        if (bed._occupied && bed._occupied !== pet.id) return false;
        const bedPos = getObjectCoordinates(bed.id);
        const bedWidth = Math.ceil(bed.offsetWidth / unitSize);
        const bedHeight = Math.ceil(bed.offsetHeight / unitSize);
        const bedTiles = getTilesOccupiedByObject(bedPos, bedWidth, bedHeight);
        return !bedTiles.some(tile => tilesOccupiedByPets.includes(tile));
    });

    if (freeBeds.length === 0) return;

    const object = freeBeds[Math.floor(Math.random() * freeBeds.length)];
    object._occupied = pet.id;
    addEnterLeaveListener(object, pet);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]["assetIndex"]]["interactive-spot"];
    let objectCoords = getObjectCoordinates(object.id);
    let objectInteractiveCoords = [objectCoords[0] + objectInteractivePart[0], objectCoords[1] - objectInteractivePart[1]];

    await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, 300, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    setObjectAnimation(pet, `${pet.id}-sleeps`);

    const timeMin = 15000;
    const timeMax = 45000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;

    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    setObjectAnimation(pet, `${pet.id}-sits-idle`);
    managePetActions(pet);
}

async function petWalksAround(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    pet = document.getElementById(pet.id)
    const suitableWalkingTiles = generateWalkabilityMap();
    const validCoords = findValidPlacements(suitableWalkingTiles, pet);

    if (validCoords.length === 0) {
        return;
    }

    // Pick a random coordinate
    const randomIndex = Math.floor(Math.random() * validCoords.length);
    const randomCoord = validCoords[randomIndex];
    const petPos = getObjectCoordinates(pet.id)

    if (!endCoordsValidityChecker(petPos[0], petPos[1], randomCoord[0], randomCoord[1], pet.id, suitableWalkingTiles)) {
        if (petControllers[pet.id]) {
            petControllers[pet.id].abort();
            setObjectAnimation(pet, `${pet.id}-stands-idle`);
            delete petControllers[pet.id]; // Clean up the controller
        }
        return
    }
    await movePetToTile(pet, getObjectCoordinates(pet.id), randomCoord, 300, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    managePetActions(pet);
}

function findValidPlacements(walkabilityMap, pet) {
    const rows = walkabilityMap.length;
    const cols = walkabilityMap[0].length;
    const validCoords = [];
    
    const petWidth = pet.offsetWidth;
    const petHeight = pet.offsetHeight;
    const petWidthInTiles = Math.ceil(petWidth / unitSize);
    const petHeightInTiles = Math.ceil(petHeight / unitSize);
    
    //  Fix: Start row from petHeightInTiles-1 to ensure topRow is never < 0
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col <= cols - petWidthInTiles; col++) {
            
            // Check if bottom row is walkable
            let bottomRowWalkable = true;
            for (let c = col; c < col + petWidthInTiles; c++) {
                if (!walkabilityMap[row][c] || !walkabilityMap[row][c].walkable) {
                    bottomRowWalkable = false;
                    break;
                }
            }
            
            if (bottomRowWalkable) {
                validCoords.push([col, row]);
            }
        }
    }
        
    return validCoords;
}

function endCoordsValidityChecker (startCol, startRow, endCol, endRow, objectId, walkabilityMap) {
    // Get object size in tiles
    const object = document.getElementById(objectId);
    if (!object) {
        console.error("Object not found:", objectId);
        return null;
    }

    const objWidth = object.offsetWidth;
    const objHeight = object.offsetHeight;
    const unitSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--unit-size'));
    const widthInTiles = Math.ceil(objWidth / unitSize);

    // Add safety check
    if (!walkabilityMap || walkabilityMap.length === 0) {
        console.error("Failed to generate walkability map");
        return false;
    }

    // Validate start & end
    if (!canPlaceObjectAt(startCol, startRow, objWidth, objHeight, walkabilityMap)) {
        return false;
    }
    if (!canPlaceObjectAt(endCol, endRow, objWidth, objHeight, walkabilityMap)) {
        console.log(endCol, endRow)
        return false;
    }
    return true;
}

async function petStandsIdle(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-stands-idle`);

    const timeMin = 3000;
    const timeMax = 5000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function petSitsIdle(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-sits-idle`);

    const timeMin = 3000;
    const timeMax = 5000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function petLaysIdle(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-lays-idle`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function petTalks(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-talks`);

    const timeMin = 2000;
    const timeMax = 4000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1LicksPaw(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-licks-paw`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Cries(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-cries`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Sad(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-sits-idle-thinks`);

    const timeMin = 5000;
    const timeMax = 10000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Angry(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-angry`);

    const timeMin = 2000;
    const timeMax = 4000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Angry2(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }
    
    setObjectAnimation(pet, `${pet.id}-angry-2`);

    const timeMin = 3000;
    const timeMax = 6000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;
    await cancellableWait(randomDuration, signal);
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    managePetActions(pet);
}

async function cat1Hungry(pet, signal) {
        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    const petSpecies = pet.classList[0].split('-')[0]

    const roomObjectsContainer = document.getElementById("roomObjectsContainer");

    // Find all elements whose class includes both "food-bowl" and the species substring
    const matchingFoodBowls = Array.from(roomObjectsContainer.querySelectorAll("*")).filter(el => {
        const classStr = el.className; // full class string
        return classStr.includes("food-bowl") && classStr.includes(petSpecies) && !classStr.includes("furniture-preview");
    });

    let object;


    if (matchingFoodBowls.length > 0) {
        const randomIndex = Math.floor(Math.random() * matchingFoodBowls.length);
        object = matchingFoodBowls[randomIndex];
    } else {
        return
    }

    let petCoords = getObjectCoordinates(pet.id);

    let objectInteractivePart = gameAssetIndex[userObjectAssets[object.id]["assetIndex"]]["interactive-spot"];
    let objectCoords = getObjectCoordinates(object.id);

    let objectInteractiveCoords = [objectCoords[0] + objectInteractivePart[0], objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteract = canPlaceObjectAt(objectInteractiveCoords[0], objectInteractiveCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

    let objectWidthInTiles = Math.ceil(object.offsetWidth / unitSize);
    let objectHightInTiles = Math.ceil(object.offsetHeight / unitSize);
    let petWidthInTiles = Math.ceil(pet.offsetHeight / unitSize);
    let objectInteractiveBottomRightCoords = [objectCoords[0] + objectWidthInTiles - objectInteractivePart[0] - petWidthInTiles, objectCoords[1] - objectInteractivePart[1]];
    let ableToPostitionToInteractReverse = canPlaceObjectAt(objectInteractiveBottomRightCoords[0], objectInteractiveBottomRightCoords[1], pet.offsetWidth, pet.offsetHeight, generateWalkabilityMap());

        if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

    const animations = ["cat-1-excited", "cat-1-talks"]
    const randomAnimation = animations[Math.floor(Math.random() * animations.length)];

    const timeMin = 10000;
    const timeMax = 20000;
    const randomDuration = Math.floor(Math.random() * (timeMax - timeMin + 1)) + timeMin;

    if ((ableToPostitionToInteract && !ableToPostitionToInteractReverse) ||
        (ableToPostitionToInteract && petCoords[0] - objectCoords[0] >= 0)) {

        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }


        setObjectAnimation(pet, randomAnimation);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "left");
        }

        await cancellableWait(randomDuration, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        managePetActions(pet);

    } else if (ableToPostitionToInteractReverse) {
        await movePetToTile(pet, getObjectCoordinates(pet.id), objectInteractiveBottomRightCoords, 300, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        setObjectAnimation(pet, randomAnimation);
        if (objectWidthInTiles - objectInteractivePart[0] * 2 !== petWidthInTiles) {
            changeCatFacingDirection(pet, "right");
        }

        await cancellableWait(randomDuration, signal);
            if (signal.aborted) {
            cancelMovement(pet.id)
            throw new DOMException("Aborted", "AbortError");
        }

        managePetActions(pet);

    }
}


function cancellableWait(ms, signal) {
    return new Promise((resolve, reject) => {
        const id = setTimeout(() => resolve(), ms);
        signal.addEventListener("abort", () => {
            clearTimeout(id);
            reject(new DOMException("Aborted", "AbortError"));
        }, { once: true });
    });
}


const petAutonomousActions = {
    "cat-1": ["petStandsIdle", "petSitsIdle", "petLaysIdle", "petSleeps", "petTalks", "cat1LicksPaw"],
    "cat-2": ["petStandsIdle", "petSitsIdle", "petLaysIdle", "petSleeps", "petTalks", "cat1LicksPaw"]
    }

const petAutonomousActionsSituational = {
    "cat-1": {
        "hungry": ["cat1Hungry"],
        "thirsty": [],
        "sad": ["cat1Cries", "cat1Sad"],
        "angry": ["cat1Angry", "cat1Angry2"]
        },
    "cat-2": {
        "hungry": ["cat1Hungry"],
        "thirsty": [],
        "sad": ["cat1Cries", "cat1Sad"],
        "angry": ["cat1Angry", "cat1Angry2"]
        }
    }


function initUserTriggeredAction(type, object) {
    if (type === "food") {
        const provides = object._foodContent

        const petContainer = document.getElementById("petContainer");
        const petDivs = petContainer.querySelectorAll("div.pet");

        const providesFor = provides[0][1];
        const providesQuantity = provides[0][2] * provides[1];

        const suitablePets = Array.from(petDivs).filter(div =>
        Array.from(div.classList).some(cls =>
            providesFor.some(kw => cls.includes(kw))
        )
        );

        let lowest = [];
        let minFood = Infinity;

        suitablePets.forEach(div => {
            const stats = div._stats;
            if (!stats) return;

            const food = stats.foodNew;
            if (food < minFood) {
                minFood = food;
                lowest = [div];
            } else if (food === minFood) {
                lowest.push(div);
            }
        });

        if (suitablePets.length === 0) {
            return
        }

        let selectedPet = null;
        if (lowest.length > 0) {
            selectedPet = lowest[Math.floor(Math.random() * lowest.length)];
        }

        if (!pendingPetActions[selectedPet.id]) {
            pendingPetActions[selectedPet.id] = [];
        }

        increasePetStatsInDatabase(selectedPet.id, "food", providesQuantity)
        pendingPetActions[selectedPet.id].unshift([petEats, [selectedPet, object]]);
        managePetActions(selectedPet);
    
    } else if (type === "water") {        
        const bowlClasses = Array.from(object.classList);

        const petContainer = document.getElementById("petContainer");
        const petDivs = petContainer.querySelectorAll("div.pet");

        const suitablePets = Array.from(petDivs).filter(div => {
            const petSpecies = div.id.split("-")[0];

            // Check if petSpecies is a substring of any bowl class
            return bowlClasses.some(cls => cls.includes(petSpecies));
        });

        let lowest = [];
        let minWater = Infinity;

        suitablePets.forEach(div => {
            const stats = div._stats;
            if (!stats) return;

            const water = stats.waterNew;
            if (water < minWater) {
                minWater = water;
                lowest = [div];
            } else if (water === minWater) {
                lowest.push(div);
            }
        });

        if (suitablePets.length === 0) {
            return
        }

        let selectedPet = null;
        if (lowest.length > 0) {
        selectedPet = lowest[Math.floor(Math.random() * lowest.length)];
        }

        if (!pendingPetActions[selectedPet.id]) {
            pendingPetActions[selectedPet.id] = [];
        }

        increasePetStatsInDatabase(selectedPet.id, "water", 10)
        pendingPetActions[selectedPet.id].unshift([petDrinks, [selectedPet, object]]);
        managePetActions(selectedPet);
    
    } else if (type === "love") {
        if (!pendingPetActions[object[0].id]) {
            pendingPetActions[object[0].id] = [];
        }
        
        increasePetStatsInDatabase(object[0].id, "love", object[1] * object[2])
        
        pendingPetActions[object[0].id].unshift([petHappy, [object[0], object[1]]]);
        managePetActions(object[0]);
    
    } else if (type === "music") {
        const pets = document.querySelectorAll('.pet');
        pets.forEach((pet) => {
            if (!pendingPetActions[pet.id]) {
                pendingPetActions[pet.id] = [];
            }

            // Queue the dance action for this pet
            pendingPetActions[pet.id].unshift([petDances, [pet]]);

            managePetActions(pet);
        });
    } else if (type === "bath") {
        const bathClasses = Array.from(object.classList);

        const petContainer = document.getElementById("petContainer");
        const petDivs = petContainer.querySelectorAll("div.pet");

        const suitablePets = Array.from(petDivs).filter(div => {
            const petSpecies = div.id.split("-")[0];

            // Check if petSpecies is a substring of any bowl class
            return bathClasses.some(cls => cls.includes(petSpecies));
        });

        if (suitablePets.length === 0) {
            return
        }

        let selectedPet = suitablePets[Math.floor(Math.random() * suitablePets.length)];

        if (!pendingPetActions[selectedPet.id]) {
            pendingPetActions[selectedPet.id] = [];
        }

        pendingPetActions[selectedPet.id].unshift([petBathes, [selectedPet, object]]);
        managePetActions(selectedPet);
    }
}

function addEnterLeaveListener(targetObject, petObject) {
    let hasEntered = false;
    
    // Use tile-based collision detection instead of bounding rectangles
    function isOverlapping() {
        const overlappingObjects = detectTileCollision(petObject.id);
        return overlappingObjects.includes(targetObject);
    }
    
    // Check initial state
    const startedInside = isOverlapping();
    if (startedInside) {
        hasEntered = true; // Pet starts inside, wait for it to leave
    }
    
    const intervalId = setInterval(() => {
        const currentlyOverlapping = isOverlapping();
        
        if (!hasEntered) {
            // Waiting for pet to enter
            if (currentlyOverlapping) {
                hasEntered = true;
            }
        } else {
            // Pet has entered (or started inside), waiting for it to leave
            if (!currentlyOverlapping) {
                delete targetObject._occupied;
                cleanup();
                return;
            }
        }
    }, 50); // Check every 50ms for smoother detection
    
    // Timeout after 15 seconds
    const timeoutId = setTimeout(() => {
        cleanup();
    }, 15000);
    
    function cleanup() {
        clearInterval(intervalId);
        clearTimeout(timeoutId);
    }
    
    return cleanup;
}

function taxesNavChoiceIndicator() {
    const navigationTaxesElement = document.querySelector(".taxes-nav-icon");
    if (!navigationTaxesElement) return;

    const currentTime = Math.floor(Date.now() / 1000 / 60);
    const taxPaymentPeriodInMinutes = taxPaymentPeriod * 24 * 60;

    let hasOverdue = false;
    let hasPending = false;

    for (const taxKey in taxesData) {
        const tax = taxesData[taxKey];
        if (!tax) continue;

        const taxDueDateInMinutes = tax.date + taxPaymentPeriodInMinutes;
        const graceEndDateInMinutes =
            tax.date + taxPaymentPeriodInMinutes + (taxGracePeriod * 24 * 60);

        if (tax.paid && currentTime < taxDueDateInMinutes) {
            // still paid  do nothing
        } else if (currentTime >= taxDueDateInMinutes && currentTime < graceEndDateInMinutes) {
            hasPending = true;
        } else {
            hasOverdue = true;
        }
    }

    // Remove any old indicator first
    const oldIndicator = document.querySelector("#tax-indicator");
    if (oldIndicator) oldIndicator.remove();

    // Add new indicator if needed
    if (hasOverdue) {
        const indicatorDiv = document.createElement("div");
        indicatorDiv.id = "tax-indicator";
        indicatorDiv.style.backgroundColor = '#ef4444'
        navigationTaxesElement.appendChild(indicatorDiv);
    } else if (hasPending) {
        const indicatorDiv = document.createElement("div");
        indicatorDiv.id = "tax-indicator";
        indicatorDiv.style.backgroundColor = '#f59e0b'
        navigationTaxesElement.appendChild(indicatorDiv);
        
    }
}

function renderTaxesSection() {
    const taxPaymentPeriodInMinutes = taxPaymentPeriod * 24 * 60;
    const recordsList = document.querySelector(".records-list");
    const currentTime = Math.floor(Date.now() / 1000 / 60);

    recordsList.querySelectorAll(".tax-record").forEach(record => {
        const infoDiv = record.querySelector(".record-info");
        const dateSpan = infoDiv.querySelector(".record-date");
        const statusBadge = record.querySelector(".status-badge");
        let payBtn;
        let taxCostElement;
        let daysRemainingElement;

        // Determine which tax this record corresponds to
        let taxKey = "";
        if (infoDiv.classList.contains("water-tax")) {
            taxKey = "waterTax";
            taxCostElement = record.querySelector("#water-tax-cost");
            payBtn = record.querySelector(".pay-tax-btn.water");
            daysRemainingElement = record.querySelector("#days-remaining-water");
        }
        if (infoDiv.classList.contains("electricity-tax")) {
            taxKey = "electricityTax";
            taxCostElement = record.querySelector("#electricity-tax-cost");
            payBtn = record.querySelector(".pay-tax-btn.electricity");
            daysRemainingElement = record.querySelector("#days-remaining-electricity");
        }

        // Update cost display
        taxCostElement.innerHTML = `<div class="item-price-coin-icon tax-price"><span class="coin-icon"><img src="../images/icons/icon-sudedu-coin.png"></span><span class="coin-amount"></span></div> ${taxPrice[taxKey]}`;

        const tax = taxesData[taxKey];
        const taxDueDateInMinutes = tax.date + taxPaymentPeriodInMinutes;
        const graceEndDateInMinutes = tax.date + taxPaymentPeriodInMinutes + (taxGracePeriod * 24 * 60);

        // Convert to readable date format
        const timestamp = taxDueDateInMinutes * 60 * 1000;
        const date = new Date(timestamp);
        const paymentDueDate = date.toISOString().split("T")[0];
        const daysRemaining = Math.ceil((graceEndDateInMinutes - currentTime) / 60 / 24)

        // Determine status
        let status = "";
        if (tax.paid && currentTime < taxDueDateInMinutes) {
            status = "paid";        // still covered
        } else if (currentTime >= taxDueDateInMinutes && currentTime < graceEndDateInMinutes) {
            status = "pending";     // grace period
        } else {
            status = "overdue";     // past grace period
        }

        // Update tax-record class
        record.className = `tax-record ${status}`;
        daysRemainingElement.innerHTML = '';

        // Update status badge and date text
        if (status === "pending") {
            statusBadge.textContent = "Laukiama";
            statusBadge.style.backgroundColor = "#f59e0b";
            dateSpan.textContent = `Mokjimas iki: ${paymentDueDate}`;
            let daysRemainingEnding;
            if (daysRemaining === 1) {
                daysRemainingEnding = 'diena';
            } else {
                daysRemainingEnding = 'dienos';
            }
            daysRemainingElement.innerHTML = `Liko ${daysRemaining} ${daysRemainingEnding}`;
        } else if (status === "paid") {
            statusBadge.textContent = "Sumokta";
            statusBadge.style.backgroundColor = "#10b981";
            dateSpan.textContent = `Kitas mokjimas: ${paymentDueDate}`;
        } else if (status === "overdue") {
            statusBadge.textContent = "Nesumokta";
            statusBadge.style.backgroundColor = "#ef4444";
            dateSpan.textContent = `Mokjimas iki: ${paymentDueDate}`;
        }

        // Update button safely (remove old listeners)
        if (payBtn) {
            const newBtn = payBtn.cloneNode(true); // clone resets event listeners
            payBtn.replaceWith(newBtn);

            if (status === "pending" || status === "overdue") {
                newBtn.textContent = "Mokti";
                newBtn.disabled = false;
                newBtn.addEventListener("click", () => payTax(taxKey));
            } else if (status === "paid") {
                newBtn.classList.add("paid");
                newBtn.textContent = "Mokti";
                newBtn.disabled = true;
            }
        }
    });
}

async function payTax(taxType) {
    const originalMoney = userMoney;

    // Calculate total cost
    const totalCost = taxPrice[taxType];
    
    // Check if user has enough money
    if (userMoney < totalCost) {
        messageToTheUser("Nepakanka ping!", 'error');
        return;
    }

    userMoney -= totalCost;

    const moneyUpdateSuccess = await sendMoneyUpdateToDatabase();
        
    if (!moneyUpdateSuccess) {
        // Revert all changes
        userMoney = originalMoney;
        messageToTheUser("Nepavyko susisiekti su serveriu. Bandyk vl vliau.", 'error');
        console.log('Purchase failed - money update failed');
        return;
    }

    const currentTime = Math.floor(Date.now() / 1000 / 60);
    
    // Update the specific tax locally
    taxesData[taxType].date = currentTime;
    taxesData[taxType].paid = true;
    
    // Create array with updated tax date for server
    const taxesArray = [taxesData.waterTax.date, taxesData.electricityTax.date];
    
    // Send to server
    sendTaxUpdate(taxesArray);
    
    // Re-render the taxes section
    renderTaxesSection();
    taxesNavChoiceIndicator();
}

async function sendTaxUpdate(taxesArray) {

    const response = await apiFetch(apiBase + 'petGame/taxes', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': userData.token
        },
        body: JSON.stringify({studentId: userData.userId, taxes: taxesArray})
    });

    if (!response) {
        return;
    }

    if (!response.ok) {
        throw new Error(`Error ${response.status}: ${response.statusText}`);
    }
}

function bonusFromDailySupplyItems() {
    let continiousStatsBonus = {};

    // Loop through all placed user objects
    for (const [objId, objData] of Object.entries(userObjectAssets)) {
        // Skip items that are not placed (no position)
        if (!objData.position || objData.position.length === 0) continue;

        const asset = gameAssetIndex[objData.assetIndex];
        if (!asset || !asset.provides || asset.provides.length !== 3) continue;

        const [stat, pets, value] = asset.provides; // e.g. ["love", ["cat", "dog"], 2]

        pets.forEach(pet => {
            if (!continiousStatsBonus[pet]) {
                continiousStatsBonus[pet] = { food: 0, water: 0, love: 0 };
            }
            continiousStatsBonus[pet][stat] += value;
        });
    }

    return continiousStatsBonus;
}


function editPetName(petId, buttonEl) {
    const petNameSpan = document.getElementById(`pet-name-${petId}`);

    const input = document.createElement('input');
    input.type = 'text';
    input.value = petNameSpan.textContent;
    input.maxLength = 10;
    input.id = `pet-name-input-${petId}`;
    input.className = 'pet-name-field';
    petNameSpan.replaceWith(input);
    input.focus();

    input.addEventListener('input', () => {
        input.style.width = Math.max(input.value.length - 1, 5) + 'ch';
    });

    // Trigger once to set initial width
    input.dispatchEvent(new Event('input'));

    buttonEl.innerHTML = '<span class="edit-icon"><img src="../images/icons/icon-check-black.svg"></span>';
    buttonEl.setAttribute('onclick', `savePetName('${petId}', this)`);
}

function savePetName(petId, buttonEl) {
  const input = document.getElementById(`pet-name-input-${petId}`);
  const newName = input.value.trim();

  if (!newName) {
    messageToTheUser("Augintiniui reikia vardo!");
    return;
  }

  for (const otherId in userPetAssets["pets"]) {
    if (otherId !== petId && userPetAssets["pets"][otherId].name === newName) {
      messageToTheUser("Toks vardas jau uimtas!");
      return;
    }
  }

  changePetName(petId, newName);

  const newSpan = document.createElement('span');
  newSpan.id = `pet-name-${petId}`;
  newSpan.textContent = newName;
  input.replaceWith(newSpan);

  buttonEl.innerHTML = '<span class="edit-icon"><img src="../images/icons/icon-edit.svg"></span>';
  buttonEl.setAttribute('onclick', `editPetName('${petId}', this)`);
}

function changePetName(petId, newName) {
  userPetAssets["pets"][petId].name = newName;
  sendPetAssetsUpdateToDatabase();
  initGame();
}


function calculateHappinesIndexForPet (petId) {
    pet = document.getElementById(petId)
    const foodAmount = pet._stats.food
    const waterAmount = pet._stats.water
    const loveAmount = pet._stats.love

    const happinesIndex = Math.round(((foodAmount + waterAmount + loveAmount) / 30) * 100) / 100;

    const indicator = document.getElementById(`pet-stats-selection-button-indicator-${petId}`)

    if (foodAmount === 0 || waterAmount === 0) {
        indicator.style.display = "flex";
        return false
    } else if (happinesIndex < 0.35) {
        indicator.style.display = "flex";
        return false
    } else {
        indicator.style.display = "none";
        return true
    }
}

let holdInterval = null;
let holdTimeout = null;
let holdSpeed = 200; // initial speed in ms
const minSpeed = 50; // fastest speed in ms
const speedIncrease = 0.9; // multiplier to speed up (lower = faster)

// Increment input value
function incrementValue(inputId, min = 1, max = 999) {
    const input = document.getElementById(inputId);
    let value = parseInt(input.value) || min;
    if (value < max) {
        input.value = value + 1;
    }
}

// Decrement input value
function decrementValue(inputId, min = 1, max = 999) {
    const input = document.getElementById(inputId);
    let value = parseInt(input.value) || min;
    if (value > min) {
        input.value = value - 1;
    }
}

// Start holding for auto increment/decrement
function startHold(inputId, min, max, isIncrement) {
    // Immediate first action
    if (isIncrement) incrementValue(inputId, min, max);
    else decrementValue(inputId, min, max);

    holdSpeed = 200; // reset speed

    holdTimeout = setTimeout(() => {
        const repeat = () => {
            if (isIncrement) incrementValue(inputId, min, max);
            else decrementValue(inputId, min, max);

            // gradually speed up
            if (holdSpeed > minSpeed) {
                holdSpeed = Math.max(minSpeed, holdSpeed * speedIncrease);
            }

            clearInterval(holdInterval);
            holdInterval = setInterval(repeat, holdSpeed);
        };

        holdInterval = setInterval(repeat, holdSpeed);
    }, 300); // initial delay
}

// Stop hold
function stopHold() {
    clearTimeout(holdTimeout);
    clearInterval(holdInterval);
    holdInterval = null;
    holdTimeout = null;
    holdSpeed = 200;
}


// Validate manual input (optional)
document.querySelectorAll('input.purchase-quantity').forEach(input => {
    input.addEventListener('change', function() {
        const min = parseInt(this.min) || 1;
        const max = parseInt(this.max) || 999;
        let value = parseInt(this.value) || min;
        if (value < min) this.value = min;
        else if (value > max) this.value = max;

    });
});

window.onload = function () {
    const savedController = localStorage.getItem('controller');
    if (savedController) {
        controller = JSON.parse(savedController);
        redirectToAppropriateLanguage(controller.language);
        resetControllerTaskSettings();
    } else {
        controller.language = "LT";
        localStorage.setItem('controller', JSON.stringify(controller));
    }
    navigationResponsiveLayout();
    document.querySelector('#gameContainer').removeAttribute('hidden');
};

async function fetchMessageGiftsFromServer() {
    try {
        const response = await apiFetch(apiBase + 'petGame/deliverMessages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': userData.token // must match your backend auth
            },
            body: JSON.stringify({ studentId: userData.userId })
        });

        if (!response) return;

        if (response.ok) {
            const data = await response.json();
            if (data.success && data.gifts.length > 0) {
                handleReceivedMessagesAndGifts(data.gifts);
            }
        } else {
            console.error(`Failed to fetch message gifts: ${response.status}`);
        }
    } catch (error) {
        console.error('Error fetching message gifts:', error);
    }
}

async function handleReceivedMessagesAndGifts(gifts) {
  if (!receivedMessages) receivedMessages = [];
  if (!userPetAssets) userPetAssets = {};
  if (!userPetAssets.pets) userPetAssets.pets = {};
  if (!userPetAssets.supplies) userPetAssets.supplies = {};
  if (!userObjectAssets) userObjectAssets = {};

  for (const gift of gifts) {
    try {
      const quantity = gift.quantity || 1;

      // If theres no giftId, its just a message
      if (gift.giftId == null) {
        receivedMessages.push({ id: gift.giftId, message: gift.message });
        continue;
      }

      const itemDetails = gameAssetIndex[gift.giftId];
      if (!itemDetails) {
        console.warn(`Gift item ID ${gift.giftId} not found in gameAssetIndex`);
        continue;
      }

      const item = itemDetails;
      const cssClasses = item['css-class'].split(' ');
      const isPetAsset = item.petAsset === true;
      const isSkin = cssClasses.includes('skin');
      const isPet = item.pet === true;

      if (isPetAsset) {
        // PET ASSET LOGIC
        if (isSkin) {
          // SKIN logic
          const petType = cssClasses[0];
          if (!userPetAssets.pets[petType]) {
            userPetAssets.pets[petType] = { skins: {}, name: item.petName };
          }
          if (!userPetAssets.pets[petType].skins)
            userPetAssets.pets[petType].skins = {};

          // Add as unique skin (not stackable)
          const existingSkins = Object.keys(userPetAssets.pets[petType].skins);
          const skinNumber = existingSkins.length + 1;
          const newSkinKey = `${petType}-${skinNumber}`;
          userPetAssets.pets[petType].skins[newSkinKey] = {
            assetIndex: gift.giftId,
            equiped: false,
          };
        } else {
          // SUPPLY logic (can be stackable)
          if (!userPetAssets.supplies) userPetAssets.supplies = {};

          if (item.stackable) {
            // Stack with existing
            let existingSupplyKey = null;
            for (const key in userPetAssets.supplies) {
              if (userPetAssets.supplies[key].assetIndex === gift.giftId) {
                existingSupplyKey = key;
                break;
              }
            }

            if (existingSupplyKey) {
              userPetAssets.supplies[existingSupplyKey].quantity += quantity;
            } else {
              const newSupplyKey = `S${Object.keys(userPetAssets.supplies).length + 1}`;
              userPetAssets.supplies[newSupplyKey] = {
                assetIndex: gift.giftId,
                quantity: quantity,
              };
            }
          } else {
            // Non-stackable pet item
            for (let i = 0; i < quantity; i++) {
              const newSupplyKey = `S${Object.keys(userPetAssets.supplies).length + 1}`;
              userPetAssets.supplies[newSupplyKey] = {
                assetIndex: gift.giftId,
                quantity: 1,
              };
            }
          }
        }

        // Update pet assets
        await sendPetAssetsUpdateToDatabase();

        // If its a pet, trigger pet-related updates
        if (isPet) {
          updateStatsBeforeRerunningInitGameAndRenderPets();
          renderPets();
          enablePetDragging();
          createPetButtons();
        }

      } else {
        // OBJECT ASSET LOGIC
        if (item.oneOfKind) {
          const newKey = `O${Object.keys(userObjectAssets).length + 1}`;
          userObjectAssets[newKey] = { assetIndex: gift.giftId, position: [] };
        } else {
          for (let i = 0; i < quantity; i++) {
            const newKey = `O${Object.keys(userObjectAssets).length + 1}`;
            userObjectAssets[newKey] = { assetIndex: gift.giftId, position: [] };
          }
        }
        await sendObjectAssetsUpdateToDatabase();
      }

      // Show message + notification
      receivedMessages.push({ id: gift.giftId, message: gift.message });

    } catch (err) {
      console.error('Error handling gift:', err, gift);
    }
  }

  displayReceivedMessages();
}



function displayReceivedMessages () {
    if (receivedMessages.length > 0) {
        const message = receivedMessages.shift();
        
        const messageTextDiv = document.createElement('div');
        messageTextDiv.innerHTML = message.message;

        const finalMessage = document.createElement('div');
        finalMessage.appendChild(messageTextDiv)

        if (message.id) {
            const item = gameAssetIndex[message.id];

             // Assume `item` has a 'css-class' property and `message` has a 'message' property
            const previewContainer = document.createElement('div');
            previewContainer.className = 'preview';

            // Create the gift box
            const giftBox = document.createElement('div');
            giftBox.className = 'gift-box';
            previewContainer.appendChild(giftBox);

            // Pick a random gift image
            const gifts = ['../images/pet-game/gift-box-1.png', '../images/pet-game/gift-box-2.png', '../images/pet-game/gift-box-3.png'];
            const randomGift = gifts[Math.floor(Math.random() * gifts.length)];
            giftBox.style.backgroundImage = `url('${randomGift}')`;

            // Create the item preview holder
            const previewHolder = document.createElement('div');
            previewHolder.className = 'item-preview-holder gift-preview-holder';

            // Create the item preview div
            const previewDiv = document.createElement('div');
            previewDiv.className = `item-preview ${item['css-class']} gift-preview`;

            previewHolder.appendChild(previewDiv);
            previewContainer.appendChild(previewHolder);

            const previewContainerOuter = document.createElement('div');
            previewContainerOuter.className = 'preview-outer';

            previewContainerOuter.appendChild(previewContainer)

            finalMessage.appendChild(previewContainerOuter)
        }

        openObjectPopup(content=finalMessage, title='inut nuo SUDEDU', subtitle = '', functionToTrigger=displayReceivedMessages, saferClosing=true)
    }
}


    </script>
</body>
</html>